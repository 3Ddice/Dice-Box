var Hr = Object.defineProperty;
var Kr = (c, e, t) => e in c ? Hr(c, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : c[e] = t;
var gt = (c, e, t) => (Kr(c, typeof e != "symbol" ? e + "" : e, t), t), Ts = (c, e, t) => {
  if (!e.has(c))
    throw TypeError("Cannot " + t);
};
var K = (c, e, t) => (Ts(c, e, "read from private field"), t ? t.call(c) : e.get(c)), et = (c, e, t) => {
  if (e.has(c))
    throw TypeError("Cannot add the same private member more than once");
  e instanceof WeakSet ? e.add(c) : e.set(c, t);
}, nt = (c, e, t, i) => (Ts(c, e, "write to private field"), i ? i.call(c, t) : e.set(c, t), t), _i = (c, e, t, i) => ({
  set _(s) {
    nt(c, e, s, t);
  },
  get _() {
    return K(c, e, i);
  }
}), js = (c, e, t) => (Ts(c, e, "access private method"), t);
import { d as Tr } from "./dice-box.es.js";
class ne {
  static WithinEpsilon(e, t, i = 1401298e-51) {
    return Math.abs(e - t) <= i;
  }
  static ToHex(e) {
    const t = e.toString(16);
    return e <= 15 ? ("0" + t).toUpperCase() : t.toUpperCase();
  }
  static Sign(e) {
    return e = +e, e === 0 || isNaN(e) ? e : e > 0 ? 1 : -1;
  }
  static Clamp(e, t = 0, i = 1) {
    return Math.min(i, Math.max(t, e));
  }
  static Log2(e) {
    return Math.log(e) * Math.LOG2E;
  }
  static ILog2(e) {
    if (Math.log2)
      return Math.floor(Math.log2(e));
    if (e < 0)
      return NaN;
    if (e === 0)
      return -1 / 0;
    let t = 0;
    if (e < 1) {
      for (; e < 1; )
        t++, e = e * 2;
      t = -t;
    } else if (e > 1)
      for (; e > 1; )
        t++, e = Math.floor(e / 2);
    return t;
  }
  static Repeat(e, t) {
    return e - Math.floor(e / t) * t;
  }
  static Normalize(e, t, i) {
    return (e - t) / (i - t);
  }
  static Denormalize(e, t, i) {
    return e * (i - t) + t;
  }
  static DeltaAngle(e, t) {
    let i = ne.Repeat(t - e, 360);
    return i > 180 && (i -= 360), i;
  }
  static PingPong(e, t) {
    const i = ne.Repeat(e, t * 2);
    return t - Math.abs(i - t);
  }
  static SmoothStep(e, t, i) {
    let s = ne.Clamp(i);
    return s = -2 * s * s * s + 3 * s * s, t * s + e * (1 - s);
  }
  static MoveTowards(e, t, i) {
    let s = 0;
    return Math.abs(t - e) <= i ? s = t : s = e + ne.Sign(t - e) * i, s;
  }
  static MoveTowardsAngle(e, t, i) {
    const s = ne.DeltaAngle(e, t);
    let r = 0;
    return -i < s && s < i ? r = t : (t = e + s, r = ne.MoveTowards(e, t, i)), r;
  }
  static Lerp(e, t, i) {
    return e + (t - e) * i;
  }
  static LerpAngle(e, t, i) {
    let s = ne.Repeat(t - e, 360);
    return s > 180 && (s -= 360), e + s * ne.Clamp(i);
  }
  static InverseLerp(e, t, i) {
    let s = 0;
    return e != t ? s = ne.Clamp((i - e) / (t - e)) : s = 0, s;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n;
    return e * o + i * h + t * l + s * u;
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = r * r;
    return (n - r) * 6 * e + (3 * n - 4 * r + 1) * t + (-n + r) * 6 * i + (3 * n - 2 * r) * s;
  }
  static RandomRange(e, t) {
    return e === t ? e : Math.random() * (t - e) + e;
  }
  static RangeToPercent(e, t, i) {
    return (e - t) / (i - t);
  }
  static PercentToRange(e, t, i) {
    return (i - t) * e + t;
  }
  static NormalizeRadians(e) {
    return e -= ne.TwoPi * Math.floor((e + Math.PI) / ne.TwoPi), e;
  }
  static HCF(e, t) {
    const i = e % t;
    return i === 0 ? t : ne.HCF(t, i);
  }
}
ne.TwoPi = Math.PI * 2;
const Ti = 1 / 2.2, bi = 2.2, Re = 1e-3;
class Ye {
  static BuildArray(e, t) {
    const i = [];
    for (let s = 0; s < e; ++s)
      i.push(t());
    return i;
  }
  static BuildTuple(e, t) {
    return Ye.BuildArray(e, t);
  }
}
function Yr(c, e, t) {
  const i = c[e];
  if (typeof i != "function")
    return null;
  const s = function() {
    const r = c.length, n = s.previous.apply(c, arguments);
    return t(e, r), n;
  };
  return i.next = s, s.previous = i, c[e] = s, () => {
    const r = s.previous;
    if (!r)
      return;
    const n = s.next;
    n ? (r.next = n, n.previous = r) : (r.next = void 0, c[e] = r), s.next = void 0, s.previous = void 0;
  };
}
const Zr = ["push", "splice", "pop", "shift", "unshift"];
function br(c, e) {
  const t = Zr.map((i) => Yr(c, i, e));
  return () => {
    t.forEach((i) => {
      i == null || i();
    });
  };
}
const Sr = {};
function st(c, e) {
  Sr[c] = e;
}
function ci(c) {
  return Sr[c];
}
class Ne {
  static SetMatrixPrecision(e) {
    if (Ne.MatrixTrackPrecisionChange = !1, e && !Ne.MatrixUse64Bits && Ne.MatrixTrackedMatrices)
      for (let t = 0; t < Ne.MatrixTrackedMatrices.length; ++t) {
        const i = Ne.MatrixTrackedMatrices[t], s = i._m;
        i._m = new Array(16);
        for (let r = 0; r < 16; ++r)
          i._m[r] = s[r];
      }
    Ne.MatrixUse64Bits = e, Ne.MatrixCurrentType = Ne.MatrixUse64Bits ? Array : Float32Array, Ne.MatrixTrackedMatrices = null;
  }
}
Ne.MatrixUse64Bits = !1;
Ne.MatrixTrackPrecisionChange = !0;
Ne.MatrixCurrentType = Float32Array;
Ne.MatrixTrackedMatrices = [];
class fe {
  static get LastCreatedEngine() {
    return this.Instances.length === 0 ? null : this.Instances[this.Instances.length - 1];
  }
  static get LastCreatedScene() {
    return this._LastCreatedScene;
  }
}
fe.Instances = new Array();
fe._LastCreatedScene = null;
fe.UseFallbackTexture = !0;
fe.FallbackTexture = "";
const it = (c) => parseInt(c.toString().replace(/\W/g, ""));
class Te {
  constructor(e = 0, t = 0) {
    this.x = e, this.y = t;
  }
  toString() {
    return `{X: ${this.x} Y: ${this.y}}`;
  }
  getClassName() {
    return "Vector2";
  }
  getHashCode() {
    const e = it(this.x), t = it(this.y);
    let i = e;
    return i = i * 397 ^ t, i;
  }
  toArray(e, t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, this;
  }
  fromArray(e, t = 0) {
    return Te.FromArrayToRef(e, t, this), this;
  }
  asArray() {
    const e = new Array();
    return this.toArray(e, 0), e;
  }
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this;
  }
  copyFromFloats(e, t) {
    return this.x = e, this.y = t, this;
  }
  set(e, t) {
    return this.copyFromFloats(e, t);
  }
  add(e) {
    return new this.constructor(this.x + e.x, this.y + e.y);
  }
  addToRef(e, t) {
    return t.x = this.x + e.x, t.y = this.y + e.y, t;
  }
  addInPlace(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addVector3(e) {
    return new this.constructor(this.x + e.x, this.y + e.y);
  }
  subtract(e) {
    return new this.constructor(this.x - e.x, this.y - e.y);
  }
  subtractToRef(e, t) {
    return t.x = this.x - e.x, t.y = this.y - e.y, t;
  }
  subtractInPlace(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  multiplyInPlace(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  multiply(e) {
    return new this.constructor(this.x * e.x, this.y * e.y);
  }
  multiplyToRef(e, t) {
    return t.x = this.x * e.x, t.y = this.y * e.y, t;
  }
  multiplyByFloats(e, t) {
    return new this.constructor(this.x * e, this.y * t);
  }
  divide(e) {
    return new this.constructor(this.x / e.x, this.y / e.y);
  }
  divideToRef(e, t) {
    return t.x = this.x / e.x, t.y = this.y / e.y, t;
  }
  divideInPlace(e) {
    return this.divideToRef(e, this);
  }
  negate() {
    return new this.constructor(-this.x, -this.y);
  }
  negateInPlace() {
    return this.x *= -1, this.y *= -1, this;
  }
  negateToRef(e) {
    return e.copyFromFloats(this.x * -1, this.y * -1);
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this;
  }
  scale(e) {
    const t = new this.constructor(0, 0);
    return this.scaleToRef(e, t), t;
  }
  scaleToRef(e, t) {
    return t.x = this.x * e, t.y = this.y * e, t;
  }
  scaleAndAddToRef(e, t) {
    return t.x += this.x * e, t.y += this.y * e, t;
  }
  equals(e) {
    return e && this.x === e.x && this.y === e.y;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && ne.WithinEpsilon(this.x, e.x, t) && ne.WithinEpsilon(this.y, e.y, t);
  }
  floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y));
  }
  fract() {
    return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
  }
  rotateToRef(e, t) {
    const i = Math.cos(e), s = Math.sin(e);
    return t.x = i * this.x - s * this.y, t.y = s * this.x + i * this.y, t;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y;
  }
  normalize() {
    return Te.NormalizeToRef(this, this), this;
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  static Zero() {
    return new Te(0, 0);
  }
  static One() {
    return new Te(1, 1);
  }
  static get ZeroReadOnly() {
    return Te._ZeroReadOnly;
  }
  static FromArray(e, t = 0) {
    return new Te(e[t], e[t + 1]);
  }
  static FromArrayToRef(e, t, i) {
    return i.x = e[t], i.y = e[t + 1], i;
  }
  static CatmullRom(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 0.5 * (2 * t.x + (-e.x + i.x) * r + (2 * e.x - 5 * t.x + 4 * i.x - s.x) * n + (-e.x + 3 * t.x - 3 * i.x + s.x) * a), h = 0.5 * (2 * t.y + (-e.y + i.y) * r + (2 * e.y - 5 * t.y + 4 * i.y - s.y) * n + (-e.y + 3 * t.y - 3 * i.y + s.y) * a);
    return new e.constructor(o, h);
  }
  static Clamp(e, t, i) {
    let s = e.x;
    s = s > i.x ? i.x : s, s = s < t.x ? t.x : s;
    let r = e.y;
    return r = r > i.y ? i.y : r, r = r < t.y ? t.y : r, new e.constructor(s, r);
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, d = e.x * o + i.x * h + t.x * l + s.x * u, f = e.y * o + i.y * h + t.y * l + s.y * u;
    return new e.constructor(d, f);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = new e.constructor();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    return n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y, n;
  }
  static Lerp(e, t, i) {
    const s = e.x + (t.x - e.x) * i, r = e.y + (t.y - e.y) * i;
    return new e.constructor(s, r);
  }
  static Dot(e, t) {
    return e.x * t.x + e.y * t.y;
  }
  static Normalize(e) {
    const t = new e.constructor();
    return this.NormalizeToRef(e, t), t;
  }
  static NormalizeToRef(e, t) {
    const i = e.length();
    return i === 0 || (t.x = e.x / i, t.y = e.y / i), t;
  }
  static Minimize(e, t) {
    const i = e.x < t.x ? e.x : t.x, s = e.y < t.y ? e.y : t.y;
    return new e.constructor(i, s);
  }
  static Maximize(e, t) {
    const i = e.x > t.x ? e.x : t.x, s = e.y > t.y ? e.y : t.y;
    return new e.constructor(i, s);
  }
  static Transform(e, t) {
    const i = new e.constructor();
    return Te.TransformToRef(e, t, i), i;
  }
  static TransformToRef(e, t, i) {
    const s = t.m, r = e.x * s[0] + e.y * s[4] + s[12], n = e.x * s[1] + e.y * s[5] + s[13];
    return i.x = r, i.y = n, i;
  }
  static PointInTriangle(e, t, i, s) {
    const r = 0.5 * (-i.y * s.x + t.y * (-i.x + s.x) + t.x * (i.y - s.y) + i.x * s.y), n = r < 0 ? -1 : 1, a = (t.y * s.x - t.x * s.y + (s.y - t.y) * e.x + (t.x - s.x) * e.y) * n, o = (t.x * i.y - t.y * i.x + (t.y - i.y) * e.x + (i.x - t.x) * e.y) * n;
    return a > 0 && o > 0 && a + o < 2 * r * n;
  }
  static Distance(e, t) {
    return Math.sqrt(Te.DistanceSquared(e, t));
  }
  static DistanceSquared(e, t) {
    const i = e.x - t.x, s = e.y - t.y;
    return i * i + s * s;
  }
  static Center(e, t) {
    const i = new e.constructor();
    return Te.CenterToRef(e, t, i);
  }
  static CenterToRef(e, t, i) {
    return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2);
  }
  static DistanceOfPointFromSegment(e, t, i) {
    const s = Te.DistanceSquared(t, i);
    if (s === 0)
      return Te.Distance(e, t);
    const r = i.subtract(t), n = Math.max(0, Math.min(1, Te.Dot(e.subtract(t), r) / s)), a = t.add(r.multiplyByFloats(n, n));
    return Te.Distance(e, a);
  }
}
Te._ZeroReadOnly = Te.Zero();
class p {
  constructor(e = 0, t = 0, i = 0) {
    this._isDirty = !0, this._x = e, this._y = t, this._z = i;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._isDirty = !0;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._isDirty = !0;
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._isDirty = !0;
  }
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;
  }
  getClassName() {
    return "Vector3";
  }
  getHashCode() {
    const e = it(this._x), t = it(this._y), i = it(this._z);
    let s = e;
    return s = s * 397 ^ t, s = s * 397 ^ i, s;
  }
  asArray() {
    const e = [];
    return this.toArray(e, 0), e;
  }
  toArray(e, t = 0) {
    return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, this;
  }
  fromArray(e, t = 0) {
    return p.FromArrayToRef(e, t, this), this;
  }
  toQuaternion() {
    return Y.RotationYawPitchRoll(this._y, this._x, this._z);
  }
  addInPlace(e) {
    return this.addInPlaceFromFloats(e._x, e._y, e._z);
  }
  addInPlaceFromFloats(e, t, i) {
    return this.x += e, this.y += t, this.z += i, this;
  }
  add(e) {
    return new this.constructor(this._x + e._x, this._y + e._y, this._z + e._z);
  }
  addToRef(e, t) {
    return t.copyFromFloats(this._x + e._x, this._y + e._y, this._z + e._z);
  }
  subtractInPlace(e) {
    return this.x -= e._x, this.y -= e._y, this.z -= e._z, this;
  }
  subtract(e) {
    return new this.constructor(this._x - e._x, this._y - e._y, this._z - e._z);
  }
  subtractToRef(e, t) {
    return this.subtractFromFloatsToRef(e._x, e._y, e._z, t);
  }
  subtractFromFloats(e, t, i) {
    return new this.constructor(this._x - e, this._y - t, this._z - i);
  }
  subtractFromFloatsToRef(e, t, i, s) {
    return s.copyFromFloats(this._x - e, this._y - t, this._z - i);
  }
  negate() {
    return new this.constructor(-this._x, -this._y, -this._z);
  }
  negateInPlace() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }
  negateToRef(e) {
    return e.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this.z *= e, this;
  }
  scale(e) {
    return new this.constructor(this._x * e, this._y * e, this._z * e);
  }
  scaleToRef(e, t) {
    return t.copyFromFloats(this._x * e, this._y * e, this._z * e);
  }
  getNormalToRef(e) {
    const t = this.length();
    let i = Math.acos(this.y / t);
    const s = Math.atan2(this.z, this.x);
    i > Math.PI / 2 ? i -= Math.PI / 2 : i += Math.PI / 2;
    const r = t * Math.sin(i) * Math.cos(s), n = t * Math.cos(i), a = t * Math.sin(i) * Math.sin(s);
    return e.set(r, n, a), e;
  }
  applyRotationQuaternionToRef(e, t) {
    const i = e.w * this.x + e.y * this.z - e.z * this.y, s = e.w * this.y + e.z * this.x - e.x * this.z, r = e.w * this.z + e.x * this.y - e.y * this.x, n = -e.x * this.x - e.y * this.y - e.z * this.z;
    return t.x = i * e.w + n * -e.x + s * -e.z - r * -e.y, t.y = s * e.w + n * -e.y + r * -e.x - i * -e.z, t.z = r * e.w + n * -e.z + i * -e.y - s * -e.x, t;
  }
  applyRotationQuaternionInPlace(e) {
    return this.applyRotationQuaternionToRef(e, this);
  }
  applyRotationQuaternion(e) {
    return this.applyRotationQuaternionToRef(e, new this.constructor());
  }
  scaleAndAddToRef(e, t) {
    return t.addInPlaceFromFloats(this._x * e, this._y * e, this._z * e);
  }
  projectOnPlane(e, t) {
    const i = new this.constructor();
    return this.projectOnPlaneToRef(e, t, i), i;
  }
  projectOnPlaneToRef(e, t, i) {
    const s = e.normal, r = e.d, n = H.Vector3[0];
    this.subtractToRef(t, n), n.normalize();
    const a = p.Dot(n, s);
    if (Math.abs(a) < Math.pow(10, -10))
      i.setAll(1 / 0);
    else {
      const o = -(p.Dot(t, s) + r) / a, h = n.scaleInPlace(o);
      t.addToRef(h, i);
    }
    return i;
  }
  equals(e) {
    return e && this._x === e._x && this._y === e._y && this._z === e._z;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && ne.WithinEpsilon(this._x, e._x, t) && ne.WithinEpsilon(this._y, e._y, t) && ne.WithinEpsilon(this._z, e._z, t);
  }
  equalsToFloats(e, t, i) {
    return this._x === e && this._y === t && this._z === i;
  }
  multiplyInPlace(e) {
    return this.x *= e._x, this.y *= e._y, this.z *= e._z, this;
  }
  multiply(e) {
    return this.multiplyByFloats(e._x, e._y, e._z);
  }
  multiplyToRef(e, t) {
    return t.copyFromFloats(this._x * e._x, this._y * e._y, this._z * e._z);
  }
  multiplyByFloats(e, t, i) {
    return new this.constructor(this._x * e, this._y * t, this._z * i);
  }
  divide(e) {
    return new this.constructor(this._x / e._x, this._y / e._y, this._z / e._z);
  }
  divideToRef(e, t) {
    return t.copyFromFloats(this._x / e._x, this._y / e._y, this._z / e._z);
  }
  divideInPlace(e) {
    return this.divideToRef(e, this);
  }
  minimizeInPlace(e) {
    return this.minimizeInPlaceFromFloats(e._x, e._y, e._z);
  }
  maximizeInPlace(e) {
    return this.maximizeInPlaceFromFloats(e._x, e._y, e._z);
  }
  minimizeInPlaceFromFloats(e, t, i) {
    return e < this._x && (this.x = e), t < this._y && (this.y = t), i < this._z && (this.z = i), this;
  }
  maximizeInPlaceFromFloats(e, t, i) {
    return e > this._x && (this.x = e), t > this._y && (this.y = t), i > this._z && (this.z = i), this;
  }
  isNonUniformWithinEpsilon(e) {
    const t = Math.abs(this._x), i = Math.abs(this._y);
    if (!ne.WithinEpsilon(t, i, e))
      return !0;
    const s = Math.abs(this._z);
    return !ne.WithinEpsilon(t, s, e) || !ne.WithinEpsilon(i, s, e);
  }
  get isNonUniform() {
    const e = Math.abs(this._x), t = Math.abs(this._y);
    if (e !== t)
      return !0;
    const i = Math.abs(this._z);
    return e !== i;
  }
  floor() {
    return new this.constructor(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
  }
  fract() {
    return new this.constructor(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
  }
  length() {
    return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
  }
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z;
  }
  get hasAZeroComponent() {
    return this._x * this._y * this._z === 0;
  }
  normalize() {
    return this.normalizeFromLength(this.length());
  }
  reorderInPlace(e) {
    return e = e.toLowerCase(), e === "xyz" ? this : (H.Vector3[0].copyFrom(this), ["x", "y", "z"].forEach((t, i) => {
      this[t] = H.Vector3[0][e[i]];
    }), this);
  }
  rotateByQuaternionToRef(e, t) {
    return e.toRotationMatrix(H.Matrix[0]), p.TransformCoordinatesToRef(this, H.Matrix[0], t), t;
  }
  rotateByQuaternionAroundPointToRef(e, t, i) {
    return this.subtractToRef(t, H.Vector3[0]), H.Vector3[0].rotateByQuaternionToRef(e, H.Vector3[0]), t.addToRef(H.Vector3[0], i), i;
  }
  cross(e) {
    const t = new this.constructor();
    return p.CrossToRef(this, e, t);
  }
  normalizeFromLength(e) {
    return e === 0 || e === 1 ? this : this.scaleInPlace(1 / e);
  }
  normalizeToNew() {
    const e = new this.constructor(0, 0, 0);
    return this.normalizeToRef(e), e;
  }
  normalizeToRef(e) {
    const t = this.length();
    return t === 0 || t === 1 ? e.copyFromFloats(this._x, this._y, this._z) : this.scaleToRef(1 / t, e);
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z);
  }
  copyFrom(e) {
    return this.copyFromFloats(e._x, e._y, e._z);
  }
  copyFromFloats(e, t, i) {
    return this.x = e, this.y = t, this.z = i, this;
  }
  set(e, t, i) {
    return this.copyFromFloats(e, t, i);
  }
  setAll(e) {
    return this.x = this.y = this.z = e, this;
  }
  static GetClipFactor(e, t, i, s) {
    const r = p.Dot(e, i) - s, n = p.Dot(t, i) - s;
    return r / (r - n);
  }
  static GetAngleBetweenVectors(e, t, i) {
    const s = e.normalizeToRef(H.Vector3[1]), r = t.normalizeToRef(H.Vector3[2]);
    let n = p.Dot(s, r);
    n = ne.Clamp(n, -1, 1);
    const a = Math.acos(n), o = H.Vector3[3];
    return p.CrossToRef(s, r, o), p.Dot(o, i) > 0 ? isNaN(a) ? 0 : a : isNaN(a) ? -Math.PI : -Math.acos(n);
  }
  static GetAngleBetweenVectorsOnPlane(e, t, i) {
    H.Vector3[0].copyFrom(e);
    const s = H.Vector3[0];
    H.Vector3[1].copyFrom(t);
    const r = H.Vector3[1];
    H.Vector3[2].copyFrom(i);
    const n = H.Vector3[2], a = H.Vector3[3], o = H.Vector3[4];
    s.normalize(), r.normalize(), n.normalize(), p.CrossToRef(n, s, a), p.CrossToRef(a, n, o);
    const h = Math.atan2(p.Dot(r, a), p.Dot(r, o));
    return ne.NormalizeRadians(h);
  }
  static PitchYawRollToMoveBetweenPointsToRef(e, t, i) {
    const s = D.Vector3[0];
    return t.subtractToRef(e, s), i.y = Math.atan2(s.x, s.z) || 0, i.x = Math.atan2(Math.sqrt(s.x ** 2 + s.z ** 2), s.y) || 0, i.z = 0, i;
  }
  static PitchYawRollToMoveBetweenPoints(e, t) {
    const i = p.Zero();
    return p.PitchYawRollToMoveBetweenPointsToRef(e, t, i);
  }
  static SlerpToRef(e, t, i, s) {
    i = ne.Clamp(i, 0, 1);
    const r = H.Vector3[0], n = H.Vector3[1];
    r.copyFrom(e);
    const a = r.length();
    r.normalizeFromLength(a), n.copyFrom(t);
    const o = n.length();
    n.normalizeFromLength(o);
    const h = p.Dot(r, n);
    let l, u;
    if (h < 1 - Re) {
      const d = Math.acos(h), f = 1 / Math.sin(d);
      l = Math.sin((1 - i) * d) * f, u = Math.sin(i * d) * f;
    } else
      l = 1 - i, u = i;
    return r.scaleInPlace(l), n.scaleInPlace(u), s.copyFrom(r).addInPlace(n), s.scaleInPlace(ne.Lerp(a, o, i)), s;
  }
  static SmoothToRef(e, t, i, s, r) {
    return p.SlerpToRef(e, t, s === 0 ? 1 : i / s, r), r;
  }
  static FromArray(e, t = 0) {
    return new p(e[t], e[t + 1], e[t + 2]);
  }
  static FromFloatArray(e, t) {
    return p.FromArray(e, t);
  }
  static FromArrayToRef(e, t, i) {
    return i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i;
  }
  static FromFloatArrayToRef(e, t, i) {
    return p.FromArrayToRef(e, t, i);
  }
  static FromFloatsToRef(e, t, i, s) {
    return s.copyFromFloats(e, t, i), s;
  }
  static Zero() {
    return new p(0, 0, 0);
  }
  static One() {
    return new p(1, 1, 1);
  }
  static Up() {
    return new p(0, 1, 0);
  }
  static get UpReadOnly() {
    return p._UpReadOnly;
  }
  static get DownReadOnly() {
    return p._DownReadOnly;
  }
  static get RightReadOnly() {
    return p._RightReadOnly;
  }
  static get LeftReadOnly() {
    return p._LeftReadOnly;
  }
  static get LeftHandedForwardReadOnly() {
    return p._LeftHandedForwardReadOnly;
  }
  static get RightHandedForwardReadOnly() {
    return p._RightHandedForwardReadOnly;
  }
  static get ZeroReadOnly() {
    return p._ZeroReadOnly;
  }
  static Down() {
    return new p(0, -1, 0);
  }
  static Forward(e = !1) {
    return new p(0, 0, e ? -1 : 1);
  }
  static Backward(e = !1) {
    return new p(0, 0, e ? 1 : -1);
  }
  static Right() {
    return new p(1, 0, 0);
  }
  static Left() {
    return new p(-1, 0, 0);
  }
  static TransformCoordinates(e, t) {
    const i = p.Zero();
    return p.TransformCoordinatesToRef(e, t, i), i;
  }
  static TransformCoordinatesToRef(e, t, i) {
    return p.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i), i;
  }
  static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) {
    const n = s.m, a = e * n[0] + t * n[4] + i * n[8] + n[12], o = e * n[1] + t * n[5] + i * n[9] + n[13], h = e * n[2] + t * n[6] + i * n[10] + n[14], l = 1 / (e * n[3] + t * n[7] + i * n[11] + n[15]);
    return r.x = a * l, r.y = o * l, r.z = h * l, r;
  }
  static TransformNormal(e, t) {
    const i = p.Zero();
    return p.TransformNormalToRef(e, t, i), i;
  }
  static TransformNormalToRef(e, t, i) {
    return this.TransformNormalFromFloatsToRef(e._x, e._y, e._z, t, i), i;
  }
  static TransformNormalFromFloatsToRef(e, t, i, s, r) {
    const n = s.m;
    return r.x = e * n[0] + t * n[4] + i * n[8], r.y = e * n[1] + t * n[5] + i * n[9], r.z = e * n[2] + t * n[6] + i * n[10], r;
  }
  static CatmullRom(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 0.5 * (2 * t._x + (-e._x + i._x) * r + (2 * e._x - 5 * t._x + 4 * i._x - s._x) * n + (-e._x + 3 * t._x - 3 * i._x + s._x) * a), h = 0.5 * (2 * t._y + (-e._y + i._y) * r + (2 * e._y - 5 * t._y + 4 * i._y - s._y) * n + (-e._y + 3 * t._y - 3 * i._y + s._y) * a), l = 0.5 * (2 * t._z + (-e._z + i._z) * r + (2 * e._z - 5 * t._z + 4 * i._z - s._z) * n + (-e._z + 3 * t._z - 3 * i._z + s._z) * a);
    return new e.constructor(o, h, l);
  }
  static Clamp(e, t, i) {
    const s = new e.constructor();
    return p.ClampToRef(e, t, i, s), s;
  }
  static ClampToRef(e, t, i, s) {
    let r = e._x;
    r = r > i._x ? i._x : r, r = r < t._x ? t._x : r;
    let n = e._y;
    n = n > i._y ? i._y : n, n = n < t._y ? t._y : n;
    let a = e._z;
    return a = a > i._z ? i._z : a, a = a < t._z ? t._z : a, s.copyFromFloats(r, n, a), s;
  }
  static CheckExtends(e, t, i) {
    t.minimizeInPlace(e), i.maximizeInPlace(e);
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, d = e._x * o + i._x * h + t._x * l + s._x * u, f = e._y * o + i._y * h + t._y * l + s._y * u, _ = e._z * o + i._z * h + t._z * l + s._z * u;
    return new e.constructor(d, f, _);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = new e.constructor();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    return n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y, n.z = (a - r) * 6 * e.z + (3 * a - 4 * r + 1) * t.z + (-a + r) * 6 * i.z + (3 * a - 2 * r) * s.z, n;
  }
  static Lerp(e, t, i) {
    const s = new e.constructor(0, 0, 0);
    return p.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    return s.x = e._x + (t._x - e._x) * i, s.y = e._y + (t._y - e._y) * i, s.z = e._z + (t._z - e._z) * i, s;
  }
  static Dot(e, t) {
    return e._x * t._x + e._y * t._y + e._z * t._z;
  }
  static Cross(e, t) {
    const i = new e.constructor();
    return p.CrossToRef(e, t, i), i;
  }
  static CrossToRef(e, t, i) {
    const s = e._y * t._z - e._z * t._y, r = e._z * t._x - e._x * t._z, n = e._x * t._y - e._y * t._x;
    return i.copyFromFloats(s, r, n), i;
  }
  static Normalize(e) {
    const t = p.Zero();
    return p.NormalizeToRef(e, t), t;
  }
  static NormalizeToRef(e, t) {
    return e.normalizeToRef(t), t;
  }
  static Project(e, t, i, s) {
    const r = new e.constructor();
    return p.ProjectToRef(e, t, i, s, r), r;
  }
  static ProjectToRef(e, t, i, s, r) {
    const n = s.width, a = s.height, o = s.x, h = s.y, l = H.Matrix[1];
    x.FromValuesToRef(n / 2, 0, 0, 0, 0, -a / 2, 0, 0, 0, 0, 0.5, 0, o + n / 2, a / 2 + h, 0.5, 1, l);
    const u = H.Matrix[0];
    return t.multiplyToRef(i, u), u.multiplyToRef(l, u), p.TransformCoordinatesToRef(e, u, r), r;
  }
  static Reflect(e, t) {
    return this.ReflectToRef(e, t, new p());
  }
  static ReflectToRef(e, t, i) {
    const s = D.Vector3[0];
    return s.copyFrom(t).scaleInPlace(2 * p.Dot(e, t)), i.copyFrom(e).subtractInPlace(s);
  }
  static _UnprojectFromInvertedMatrixToRef(e, t, i) {
    p.TransformCoordinatesToRef(e, t, i);
    const s = t.m, r = e._x * s[3] + e._y * s[7] + e._z * s[11] + s[15];
    return ne.WithinEpsilon(r, 1) && i.scaleInPlace(1 / r), i;
  }
  static UnprojectFromTransform(e, t, i, s, r) {
    return this.Unproject(e, t, i, s, r, x.IdentityReadOnly);
  }
  static Unproject(e, t, i, s, r, n) {
    const a = new e.constructor();
    return p.UnprojectToRef(e, t, i, s, r, n, a), a;
  }
  static UnprojectToRef(e, t, i, s, r, n, a) {
    return p.UnprojectFloatsToRef(e._x, e._y, e._z, t, i, s, r, n, a), a;
  }
  static UnprojectFloatsToRef(e, t, i, s, r, n, a, o, h) {
    var l;
    const u = H.Matrix[0];
    n.multiplyToRef(a, u), u.multiplyToRef(o, u), u.invert();
    const d = H.Vector3[0];
    return d.x = e / s * 2 - 1, d.y = -(t / r * 2 - 1), !((l = fe.LastCreatedEngine) === null || l === void 0) && l.isNDCHalfZRange ? d.z = i : d.z = 2 * i - 1, p._UnprojectFromInvertedMatrixToRef(d, u, h), h;
  }
  static Minimize(e, t) {
    const i = new e.constructor();
    return i.copyFrom(e), i.minimizeInPlace(t), i;
  }
  static Maximize(e, t) {
    const i = new e.constructor();
    return i.copyFrom(e), i.maximizeInPlace(t), i;
  }
  static Distance(e, t) {
    return Math.sqrt(p.DistanceSquared(e, t));
  }
  static DistanceSquared(e, t) {
    const i = e._x - t._x, s = e._y - t._y, r = e._z - t._z;
    return i * i + s * s + r * r;
  }
  static ProjectOnTriangleToRef(e, t, i, s, r) {
    const n = H.Vector3[0], a = H.Vector3[1], o = H.Vector3[2], h = H.Vector3[3], l = H.Vector3[4];
    i.subtractToRef(t, n), s.subtractToRef(t, a), s.subtractToRef(i, o);
    const u = n.length(), d = a.length(), f = o.length();
    if (u < Re || d < Re || f < Re)
      return r.copyFrom(t), p.Distance(e, t);
    e.subtractToRef(t, l), p.CrossToRef(n, a, h);
    const _ = h.length();
    if (_ < Re)
      return r.copyFrom(t), p.Distance(e, t);
    h.normalizeFromLength(_);
    let E = l.length();
    if (E < Re)
      return r.copyFrom(t), 0;
    l.normalizeFromLength(E);
    const m = p.Dot(h, l), v = H.Vector3[5], S = H.Vector3[6];
    v.copyFrom(h).scaleInPlace(-E * m), S.copyFrom(e).addInPlace(v);
    const y = H.Vector3[4], A = H.Vector3[5], C = H.Vector3[7], b = H.Vector3[8];
    y.copyFrom(n).scaleInPlace(1 / u), b.copyFrom(a).scaleInPlace(1 / d), y.addInPlace(b).scaleInPlace(-1), A.copyFrom(n).scaleInPlace(-1 / u), b.copyFrom(o).scaleInPlace(1 / f), A.addInPlace(b).scaleInPlace(-1), C.copyFrom(o).scaleInPlace(-1 / f), b.copyFrom(a).scaleInPlace(-1 / d), C.addInPlace(b).scaleInPlace(-1);
    const M = H.Vector3[9];
    let L;
    M.copyFrom(S).subtractInPlace(t), p.CrossToRef(y, M, b), L = p.Dot(b, h);
    const k = L;
    M.copyFrom(S).subtractInPlace(i), p.CrossToRef(A, M, b), L = p.Dot(b, h);
    const F = L;
    M.copyFrom(S).subtractInPlace(s), p.CrossToRef(C, M, b), L = p.Dot(b, h);
    const ue = L, ce = H.Vector3[10];
    let ie, ee;
    k > 0 && F < 0 ? (ce.copyFrom(n), ie = t, ee = i) : F > 0 && ue < 0 ? (ce.copyFrom(o), ie = i, ee = s) : (ce.copyFrom(a).scaleInPlace(-1), ie = s, ee = t);
    const Ce = H.Vector3[9], Ie = H.Vector3[4];
    if (ie.subtractToRef(S, b), ee.subtractToRef(S, Ce), p.CrossToRef(b, Ce, Ie), !(p.Dot(Ie, h) < 0))
      return r.copyFrom(S), Math.abs(E * m);
    const Ue = H.Vector3[5];
    p.CrossToRef(ce, Ie, Ue), Ue.normalize();
    const ke = H.Vector3[9];
    ke.copyFrom(ie).subtractInPlace(S);
    const ht = ke.length();
    if (ht < Re)
      return r.copyFrom(ie), p.Distance(e, ie);
    ke.normalizeFromLength(ht);
    const rt = p.Dot(Ue, ke), Mt = H.Vector3[7];
    Mt.copyFrom(S).addInPlace(Ue.scaleInPlace(ht * rt)), b.copyFrom(Mt).subtractInPlace(ie), E = ce.length(), ce.normalizeFromLength(E);
    let Kt = p.Dot(b, ce) / Math.max(E, Re);
    return Kt = ne.Clamp(Kt, 0, 1), Mt.copyFrom(ie).addInPlace(ce.scaleInPlace(Kt * E)), r.copyFrom(Mt), p.Distance(e, Mt);
  }
  static Center(e, t) {
    return p.CenterToRef(e, t, p.Zero());
  }
  static CenterToRef(e, t, i) {
    return i.copyFromFloats((e._x + t._x) / 2, (e._y + t._y) / 2, (e._z + t._z) / 2);
  }
  static RotationFromAxis(e, t, i) {
    const s = new e.constructor();
    return p.RotationFromAxisToRef(e, t, i, s), s;
  }
  static RotationFromAxisToRef(e, t, i, s) {
    const r = H.Quaternion[0];
    return Y.RotationQuaternionFromAxisToRef(e, t, i, r), r.toEulerAnglesToRef(s), s;
  }
}
p._UpReadOnly = p.Up();
p._DownReadOnly = p.Down();
p._LeftHandedForwardReadOnly = p.Forward(!1);
p._RightHandedForwardReadOnly = p.Forward(!0);
p._RightReadOnly = p.Right();
p._LeftReadOnly = p.Left();
p._ZeroReadOnly = p.Zero();
class Ae {
  constructor(e = 0, t = 0, i = 0, s = 0) {
    this.x = e, this.y = t, this.z = i, this.w = s;
  }
  toString() {
    return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;
  }
  getClassName() {
    return "Vector4";
  }
  getHashCode() {
    const e = it(this.x), t = it(this.y), i = it(this.z), s = it(this.w);
    let r = e;
    return r = r * 397 ^ t, r = r * 397 ^ i, r = r * 397 ^ s, r;
  }
  asArray() {
    const e = new Array();
    return this.toArray(e, 0), e;
  }
  toArray(e, t) {
    return t === void 0 && (t = 0), e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this;
  }
  fromArray(e, t = 0) {
    return Ae.FromArrayToRef(e, t, this), this;
  }
  addInPlace(e) {
    return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this;
  }
  add(e) {
    return new this.constructor(this.x + e.x, this.y + e.y, this.z + e.z, this.w + e.w);
  }
  addToRef(e, t) {
    return t.x = this.x + e.x, t.y = this.y + e.y, t.z = this.z + e.z, t.w = this.w + e.w, t;
  }
  subtractInPlace(e) {
    return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this;
  }
  subtract(e) {
    return new this.constructor(this.x - e.x, this.y - e.y, this.z - e.z, this.w - e.w);
  }
  subtractToRef(e, t) {
    return t.x = this.x - e.x, t.y = this.y - e.y, t.z = this.z - e.z, t.w = this.w - e.w, t;
  }
  subtractFromFloats(e, t, i, s) {
    return new this.constructor(this.x - e, this.y - t, this.z - i, this.w - s);
  }
  subtractFromFloatsToRef(e, t, i, s, r) {
    return r.x = this.x - e, r.y = this.y - t, r.z = this.z - i, r.w = this.w - s, r;
  }
  negate() {
    return new this.constructor(-this.x, -this.y, -this.z, -this.w);
  }
  negateInPlace() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this.w *= -1, this;
  }
  negateToRef(e) {
    return e.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  scale(e) {
    return new this.constructor(this.x * e, this.y * e, this.z * e, this.w * e);
  }
  scaleToRef(e, t) {
    return t.x = this.x * e, t.y = this.y * e, t.z = this.z * e, t.w = this.w * e, t;
  }
  scaleAndAddToRef(e, t) {
    return t.x += this.x * e, t.y += this.y * e, t.z += this.z * e, t.w += this.w * e, t;
  }
  equals(e) {
    return e && this.x === e.x && this.y === e.y && this.z === e.z && this.w === e.w;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && ne.WithinEpsilon(this.x, e.x, t) && ne.WithinEpsilon(this.y, e.y, t) && ne.WithinEpsilon(this.z, e.z, t) && ne.WithinEpsilon(this.w, e.w, t);
  }
  equalsToFloats(e, t, i, s) {
    return this.x === e && this.y === t && this.z === i && this.w === s;
  }
  multiplyInPlace(e) {
    return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this;
  }
  multiply(e) {
    return new this.constructor(this.x * e.x, this.y * e.y, this.z * e.z, this.w * e.w);
  }
  multiplyToRef(e, t) {
    return t.x = this.x * e.x, t.y = this.y * e.y, t.z = this.z * e.z, t.w = this.w * e.w, t;
  }
  multiplyByFloats(e, t, i, s) {
    return new this.constructor(this.x * e, this.y * t, this.z * i, this.w * s);
  }
  divide(e) {
    return new this.constructor(this.x / e.x, this.y / e.y, this.z / e.z, this.w / e.w);
  }
  divideToRef(e, t) {
    return t.x = this.x / e.x, t.y = this.y / e.y, t.z = this.z / e.z, t.w = this.w / e.w, t;
  }
  divideInPlace(e) {
    return this.divideToRef(e, this);
  }
  minimizeInPlace(e) {
    return e.x < this.x && (this.x = e.x), e.y < this.y && (this.y = e.y), e.z < this.z && (this.z = e.z), e.w < this.w && (this.w = e.w), this;
  }
  maximizeInPlace(e) {
    return e.x > this.x && (this.x = e.x), e.y > this.y && (this.y = e.y), e.z > this.z && (this.z = e.z), e.w > this.w && (this.w = e.w), this;
  }
  floor() {
    return new this.constructor(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
  }
  fract() {
    return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
  }
  lengthSquared() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
  }
  normalize() {
    const e = this.length();
    return e === 0 ? this : this.scaleInPlace(1 / e);
  }
  toVector3() {
    return new p(this.x, this.y, this.z);
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w);
  }
  copyFrom(e) {
    return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w, this;
  }
  copyFromFloats(e, t, i, s) {
    return this.x = e, this.y = t, this.z = i, this.w = s, this;
  }
  set(e, t, i, s) {
    return this.copyFromFloats(e, t, i, s);
  }
  setAll(e) {
    return this.x = this.y = this.z = this.w = e, this;
  }
  static FromArray(e, t) {
    return t || (t = 0), new Ae(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }
  static FromArrayToRef(e, t, i) {
    return i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3], i;
  }
  static FromFloatArrayToRef(e, t, i) {
    return Ae.FromArrayToRef(e, t, i), i;
  }
  static FromFloatsToRef(e, t, i, s, r) {
    return r.x = e, r.y = t, r.z = i, r.w = s, r;
  }
  static Zero() {
    return new Ae(0, 0, 0, 0);
  }
  static One() {
    return new Ae(1, 1, 1, 1);
  }
  static get ZeroReadOnly() {
    return Ae._ZeroReadOnly;
  }
  static Normalize(e) {
    const t = Ae.Zero();
    return Ae.NormalizeToRef(e, t), t;
  }
  static NormalizeToRef(e, t) {
    return t.copyFrom(e), t.normalize(), t;
  }
  static Minimize(e, t) {
    const i = new e.constructor();
    return i.copyFrom(e), i.minimizeInPlace(t), i;
  }
  static Maximize(e, t) {
    const i = new e.constructor();
    return i.copyFrom(e), i.maximizeInPlace(t), i;
  }
  static Distance(e, t) {
    return Math.sqrt(Ae.DistanceSquared(e, t));
  }
  static DistanceSquared(e, t) {
    const i = e.x - t.x, s = e.y - t.y, r = e.z - t.z, n = e.w - t.w;
    return i * i + s * s + r * r + n * n;
  }
  static Center(e, t) {
    return Ae.CenterToRef(e, t, Ae.Zero());
  }
  static CenterToRef(e, t, i) {
    return i.copyFromFloats((e.x + t.x) / 2, (e.y + t.y) / 2, (e.z + t.z) / 2, (e.w + t.w) / 2);
  }
  static TransformCoordinates(e, t) {
    const i = Ae.Zero();
    return Ae.TransformCoordinatesToRef(e, t, i), i;
  }
  static TransformCoordinatesToRef(e, t, i) {
    return Ae.TransformCoordinatesFromFloatsToRef(e._x, e._y, e._z, t, i), i;
  }
  static TransformCoordinatesFromFloatsToRef(e, t, i, s, r) {
    const n = s.m, a = e * n[0] + t * n[4] + i * n[8] + n[12], o = e * n[1] + t * n[5] + i * n[9] + n[13], h = e * n[2] + t * n[6] + i * n[10] + n[14], l = e * n[3] + t * n[7] + i * n[11] + n[15];
    return r.x = a, r.y = o, r.z = h, r.w = l, r;
  }
  static TransformNormal(e, t) {
    const i = new e.constructor();
    return Ae.TransformNormalToRef(e, t, i), i;
  }
  static TransformNormalToRef(e, t, i) {
    const s = t.m, r = e.x * s[0] + e.y * s[4] + e.z * s[8], n = e.x * s[1] + e.y * s[5] + e.z * s[9], a = e.x * s[2] + e.y * s[6] + e.z * s[10];
    return i.x = r, i.y = n, i.z = a, i.w = e.w, i;
  }
  static TransformNormalFromFloatsToRef(e, t, i, s, r, n) {
    const a = r.m;
    return n.x = e * a[0] + t * a[4] + i * a[8], n.y = e * a[1] + t * a[5] + i * a[9], n.z = e * a[2] + t * a[6] + i * a[10], n.w = s, n;
  }
  static FromVector3(e, t = 0) {
    return new Ae(e._x, e._y, e._z, t);
  }
}
Ae._ZeroReadOnly = Ae.Zero();
class Y {
  constructor(e = 0, t = 0, i = 0, s = 1) {
    this._isDirty = !0, this._x = e, this._y = t, this._z = i, this._w = s;
  }
  get x() {
    return this._x;
  }
  set x(e) {
    this._x = e, this._isDirty = !0;
  }
  get y() {
    return this._y;
  }
  set y(e) {
    this._y = e, this._isDirty = !0;
  }
  get z() {
    return this._z;
  }
  set z(e) {
    this._z = e, this._isDirty = !0;
  }
  get w() {
    return this._w;
  }
  set w(e) {
    this._w = e, this._isDirty = !0;
  }
  toString() {
    return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;
  }
  getClassName() {
    return "Quaternion";
  }
  getHashCode() {
    const e = it(this._x), t = it(this._y), i = it(this._z), s = it(this._w);
    let r = e;
    return r = r * 397 ^ t, r = r * 397 ^ i, r = r * 397 ^ s, r;
  }
  asArray() {
    return [this._x, this._y, this._z, this._w];
  }
  toArray(e, t = 0) {
    return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, this;
  }
  equals(e) {
    return e && this._x === e._x && this._y === e._y && this._z === e._z && this._w === e._w;
  }
  equalsWithEpsilon(e, t = Re) {
    return e && ne.WithinEpsilon(this._x, e._x, t) && ne.WithinEpsilon(this._y, e._y, t) && ne.WithinEpsilon(this._z, e._z, t) && ne.WithinEpsilon(this._w, e._w, t);
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copyFrom(e) {
    return this.x = e._x, this.y = e._y, this.z = e._z, this.w = e._w, this;
  }
  copyFromFloats(e, t, i, s) {
    return this.x = e, this.y = t, this.z = i, this.w = s, this;
  }
  set(e, t, i, s) {
    return this.copyFromFloats(e, t, i, s);
  }
  add(e) {
    return new this.constructor(this._x + e._x, this._y + e._y, this._z + e._z, this._w + e._w);
  }
  addInPlace(e) {
    return this._x += e._x, this._y += e._y, this._z += e._z, this._w += e._w, this;
  }
  subtract(e) {
    return new this.constructor(this._x - e._x, this._y - e._y, this._z - e._z, this._w - e._w);
  }
  subtractInPlace(e) {
    return this._x -= e._x, this._y -= e._y, this._z -= e._z, this._w -= e._w, this;
  }
  scale(e) {
    return new this.constructor(this._x * e, this._y * e, this._z * e, this._w * e);
  }
  scaleToRef(e, t) {
    return t.x = this._x * e, t.y = this._y * e, t.z = this._z * e, t.w = this._w * e, t;
  }
  scaleInPlace(e) {
    return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.x += this._x * e, t.y += this._y * e, t.z += this._z * e, t.w += this._w * e, t;
  }
  multiply(e) {
    const t = new this.constructor(0, 0, 0, 1);
    return this.multiplyToRef(e, t), t;
  }
  multiplyToRef(e, t) {
    const i = this._x * e._w + this._y * e._z - this._z * e._y + this._w * e._x, s = -this._x * e._z + this._y * e._w + this._z * e._x + this._w * e._y, r = this._x * e._y - this._y * e._x + this._z * e._w + this._w * e._z, n = -this._x * e._x - this._y * e._y - this._z * e._z + this._w * e._w;
    return t.copyFromFloats(i, s, r, n), t;
  }
  multiplyInPlace(e) {
    return this.multiplyToRef(e, this), this;
  }
  conjugateToRef(e) {
    return e.copyFromFloats(-this._x, -this._y, -this._z, this._w), e;
  }
  conjugateInPlace() {
    return this.x *= -1, this.y *= -1, this.z *= -1, this;
  }
  conjugate() {
    return new this.constructor(-this._x, -this._y, -this._z, this._w);
  }
  invert() {
    const e = this.conjugate(), t = this.lengthSquared();
    return t == 0 || t == 1 || e.scaleInPlace(1 / t), e;
  }
  invertInPlace() {
    this.conjugateInPlace();
    const e = this.lengthSquared();
    return e == 0 || e == 1 ? this : (this.scaleInPlace(1 / e), this);
  }
  lengthSquared() {
    return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
  }
  length() {
    return Math.sqrt(this.lengthSquared());
  }
  normalize() {
    const e = this.length();
    if (e === 0)
      return this;
    const t = 1 / e;
    return this.scaleInPlace(t), this;
  }
  normalizeToNew() {
    const e = this.length();
    if (e === 0)
      return this.clone();
    const t = 1 / e;
    return this.scale(t);
  }
  toEulerAngles() {
    const e = p.Zero();
    return this.toEulerAnglesToRef(e), e;
  }
  toEulerAnglesToRef(e) {
    const t = this._z, i = this._x, s = this._y, r = this._w, n = s * t - i * r, a = 0.4999999;
    if (n < -a)
      e.y = 2 * Math.atan2(s, r), e.x = Math.PI / 2, e.z = 0;
    else if (n > a)
      e.y = 2 * Math.atan2(s, r), e.x = -Math.PI / 2, e.z = 0;
    else {
      const o = r * r, h = t * t, l = i * i, u = s * s;
      e.z = Math.atan2(2 * (i * s + t * r), -h - l + u + o), e.x = Math.asin(-2 * n), e.y = Math.atan2(2 * (t * i + s * r), h - l - u + o);
    }
    return e;
  }
  toRotationMatrix(e) {
    return x.FromQuaternionToRef(this, e), e;
  }
  fromRotationMatrix(e) {
    return Y.FromRotationMatrixToRef(e, this), this;
  }
  static FromRotationMatrix(e) {
    const t = new Y();
    return Y.FromRotationMatrixToRef(e, t), t;
  }
  static FromRotationMatrixToRef(e, t) {
    const i = e.m, s = i[0], r = i[4], n = i[8], a = i[1], o = i[5], h = i[9], l = i[2], u = i[6], d = i[10], f = s + o + d;
    let _;
    return f > 0 ? (_ = 0.5 / Math.sqrt(f + 1), t.w = 0.25 / _, t.x = (u - h) * _, t.y = (n - l) * _, t.z = (a - r) * _) : s > o && s > d ? (_ = 2 * Math.sqrt(1 + s - o - d), t.w = (u - h) / _, t.x = 0.25 * _, t.y = (r + a) / _, t.z = (n + l) / _) : o > d ? (_ = 2 * Math.sqrt(1 + o - s - d), t.w = (n - l) / _, t.x = (r + a) / _, t.y = 0.25 * _, t.z = (h + u) / _) : (_ = 2 * Math.sqrt(1 + d - s - o), t.w = (a - r) / _, t.x = (n + l) / _, t.y = (h + u) / _, t.z = 0.25 * _), t;
  }
  static Dot(e, t) {
    return e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w;
  }
  static AreClose(e, t, i = 0.1) {
    const s = Y.Dot(e, t);
    return 1 - s * s <= i;
  }
  static SmoothToRef(e, t, i, s, r) {
    let n = s === 0 ? 1 : i / s;
    return n = ne.Clamp(n, 0, 1), Y.SlerpToRef(e, t, n, r), r;
  }
  static Zero() {
    return new Y(0, 0, 0, 0);
  }
  static Inverse(e) {
    return new e.constructor(-e._x, -e._y, -e._z, e._w);
  }
  static InverseToRef(e, t) {
    return t.set(-e._x, -e._y, -e._z, e._w), t;
  }
  static Identity() {
    return new Y(0, 0, 0, 1);
  }
  static IsIdentity(e) {
    return e && e._x === 0 && e._y === 0 && e._z === 0 && e._w === 1;
  }
  static RotationAxis(e, t) {
    return Y.RotationAxisToRef(e, t, new Y());
  }
  static RotationAxisToRef(e, t, i) {
    const s = Math.sin(t / 2);
    return e.normalize(), i.w = Math.cos(t / 2), i.x = e._x * s, i.y = e._y * s, i.z = e._z * s, i;
  }
  static FromArray(e, t) {
    return t || (t = 0), new Y(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }
  static FromArrayToRef(e, t, i) {
    return i.x = e[t], i.y = e[t + 1], i.z = e[t + 2], i.w = e[t + 3], i;
  }
  static FromEulerAngles(e, t, i) {
    const s = new Y();
    return Y.RotationYawPitchRollToRef(t, e, i, s), s;
  }
  static FromEulerAnglesToRef(e, t, i, s) {
    return Y.RotationYawPitchRollToRef(t, e, i, s), s;
  }
  static FromEulerVector(e) {
    const t = new Y();
    return Y.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t;
  }
  static FromEulerVectorToRef(e, t) {
    return Y.RotationYawPitchRollToRef(e._y, e._x, e._z, t), t;
  }
  static FromUnitVectorsToRef(e, t, i) {
    const s = p.Dot(e, t) + 1;
    return s < Re ? Math.abs(e.x) > Math.abs(e.z) ? i.set(-e.y, e.x, 0, 0) : i.set(0, -e.z, e.y, 0) : (p.CrossToRef(e, t, D.Vector3[0]), i.set(D.Vector3[0].x, D.Vector3[0].y, D.Vector3[0].z, s)), i.normalize();
  }
  static RotationYawPitchRoll(e, t, i) {
    const s = new Y();
    return Y.RotationYawPitchRollToRef(e, t, i, s), s;
  }
  static RotationYawPitchRollToRef(e, t, i, s) {
    const r = i * 0.5, n = t * 0.5, a = e * 0.5, o = Math.sin(r), h = Math.cos(r), l = Math.sin(n), u = Math.cos(n), d = Math.sin(a), f = Math.cos(a);
    return s.x = f * l * h + d * u * o, s.y = d * u * h - f * l * o, s.z = f * u * o - d * l * h, s.w = f * u * h + d * l * o, s;
  }
  static RotationAlphaBetaGamma(e, t, i) {
    const s = new Y();
    return Y.RotationAlphaBetaGammaToRef(e, t, i, s), s;
  }
  static RotationAlphaBetaGammaToRef(e, t, i, s) {
    const r = (i + e) * 0.5, n = (i - e) * 0.5, a = t * 0.5;
    return s.x = Math.cos(n) * Math.sin(a), s.y = Math.sin(n) * Math.sin(a), s.z = Math.sin(r) * Math.cos(a), s.w = Math.cos(r) * Math.cos(a), s;
  }
  static RotationQuaternionFromAxis(e, t, i) {
    const s = new Y(0, 0, 0, 0);
    return Y.RotationQuaternionFromAxisToRef(e, t, i, s), s;
  }
  static RotationQuaternionFromAxisToRef(e, t, i, s) {
    const r = H.Matrix[0];
    return x.FromXYZAxesToRef(e.normalize(), t.normalize(), i.normalize(), r), Y.FromRotationMatrixToRef(r, s), s;
  }
  static FromLookDirectionLH(e, t) {
    const i = new Y();
    return Y.FromLookDirectionLHToRef(e, t, i), i;
  }
  static FromLookDirectionLHToRef(e, t, i) {
    const s = H.Matrix[0];
    return x.LookDirectionLHToRef(e, t, s), Y.FromRotationMatrixToRef(s, i), i;
  }
  static FromLookDirectionRH(e, t) {
    const i = new Y();
    return Y.FromLookDirectionRHToRef(e, t, i), i;
  }
  static FromLookDirectionRHToRef(e, t, i) {
    const s = H.Matrix[0];
    return x.LookDirectionRHToRef(e, t, s), Y.FromRotationMatrixToRef(s, i);
  }
  static Slerp(e, t, i) {
    const s = Y.Identity();
    return Y.SlerpToRef(e, t, i, s), s;
  }
  static SlerpToRef(e, t, i, s) {
    let r, n, a = e._x * t._x + e._y * t._y + e._z * t._z + e._w * t._w, o = !1;
    if (a < 0 && (o = !0, a = -a), a > 0.999999)
      n = 1 - i, r = o ? -i : i;
    else {
      const h = Math.acos(a), l = 1 / Math.sin(h);
      n = Math.sin((1 - i) * h) * l, r = o ? -Math.sin(i * h) * l : Math.sin(i * h) * l;
    }
    return s.x = n * e._x + r * t._x, s.y = n * e._y + r * t._y, s.z = n * e._z + r * t._z, s.w = n * e._w + r * t._w, s;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, d = e._x * o + i._x * h + t._x * l + s._x * u, f = e._y * o + i._y * h + t._y * l + s._y * u, _ = e._z * o + i._z * h + t._z * l + s._z * u, E = e._w * o + i._w * h + t._w * l + s._w * u;
    return new e.constructor(d, f, _, E);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = new e.constructor();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    return n.x = (a - r) * 6 * e.x + (3 * a - 4 * r + 1) * t.x + (-a + r) * 6 * i.x + (3 * a - 2 * r) * s.x, n.y = (a - r) * 6 * e.y + (3 * a - 4 * r + 1) * t.y + (-a + r) * 6 * i.y + (3 * a - 2 * r) * s.y, n.z = (a - r) * 6 * e.z + (3 * a - 4 * r + 1) * t.z + (-a + r) * 6 * i.z + (3 * a - 2 * r) * s.z, n.w = (a - r) * 6 * e.w + (3 * a - 4 * r + 1) * t.w + (-a + r) * 6 * i.w + (3 * a - 2 * r) * s.w, n;
  }
}
class x {
  constructor() {
    this._isIdentity = !1, this._isIdentityDirty = !0, this._isIdentity3x2 = !0, this._isIdentity3x2Dirty = !0, this.updateFlag = -1, Ne.MatrixTrackPrecisionChange && Ne.MatrixTrackedMatrices.push(this), this._m = new Ne.MatrixCurrentType(16), this.markAsUpdated();
  }
  static get Use64Bits() {
    return Ne.MatrixUse64Bits;
  }
  get m() {
    return this._m;
  }
  markAsUpdated() {
    this.updateFlag = x._UpdateFlagSeed++, this._isIdentity = !1, this._isIdentity3x2 = !1, this._isIdentityDirty = !0, this._isIdentity3x2Dirty = !0;
  }
  _updateIdentityStatus(e, t = !1, i = !1, s = !0) {
    this._isIdentity = e, this._isIdentity3x2 = e || i, this._isIdentityDirty = this._isIdentity ? !1 : t, this._isIdentity3x2Dirty = this._isIdentity3x2 ? !1 : s;
  }
  isIdentity() {
    if (this._isIdentityDirty) {
      this._isIdentityDirty = !1;
      const e = this._m;
      this._isIdentity = e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 0 && e[4] === 0 && e[5] === 1 && e[6] === 0 && e[7] === 0 && e[8] === 0 && e[9] === 0 && e[10] === 1 && e[11] === 0 && e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1;
    }
    return this._isIdentity;
  }
  isIdentityAs3x2() {
    return this._isIdentity3x2Dirty && (this._isIdentity3x2Dirty = !1, this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1 ? this._isIdentity3x2 = !1 : this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0 ? this._isIdentity3x2 = !1 : this._isIdentity3x2 = !0), this._isIdentity3x2;
  }
  determinant() {
    if (this._isIdentity === !0)
      return 1;
    const e = this._m, t = e[0], i = e[1], s = e[2], r = e[3], n = e[4], a = e[5], o = e[6], h = e[7], l = e[8], u = e[9], d = e[10], f = e[11], _ = e[12], E = e[13], m = e[14], v = e[15], S = d * v - m * f, y = u * v - E * f, A = u * m - E * d, C = l * v - _ * f, b = l * m - d * _, M = l * E - _ * u, L = +(a * S - o * y + h * A), k = -(n * S - o * C + h * b), F = +(n * y - a * C + h * M), ue = -(n * A - a * b + o * M);
    return t * L + i * k + s * F + r * ue;
  }
  toArray() {
    return this._m;
  }
  asArray() {
    return this._m;
  }
  invert() {
    return this.invertToRef(this), this;
  }
  reset() {
    return x.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this), this._updateIdentityStatus(!1), this;
  }
  add(e) {
    const t = new this.constructor();
    return this.addToRef(e, t), t;
  }
  addToRef(e, t) {
    const i = this._m, s = t._m, r = e.m;
    for (let n = 0; n < 16; n++)
      s[n] = i[n] + r[n];
    return t.markAsUpdated(), t;
  }
  addToSelf(e) {
    const t = this._m, i = e.m;
    for (let s = 0; s < 16; s++)
      t[s] += i[s];
    return this.markAsUpdated(), this;
  }
  invertToRef(e) {
    if (this._isIdentity === !0)
      return x.IdentityToRef(e), e;
    const t = this._m, i = t[0], s = t[1], r = t[2], n = t[3], a = t[4], o = t[5], h = t[6], l = t[7], u = t[8], d = t[9], f = t[10], _ = t[11], E = t[12], m = t[13], v = t[14], S = t[15], y = f * S - v * _, A = d * S - m * _, C = d * v - m * f, b = u * S - E * _, M = u * v - f * E, L = u * m - E * d, k = +(o * y - h * A + l * C), F = -(a * y - h * b + l * M), ue = +(a * A - o * b + l * L), ce = -(a * C - o * M + h * L), ie = i * k + s * F + r * ue + n * ce;
    if (ie === 0)
      return e.copyFrom(this), e;
    const ee = 1 / ie, Ce = h * S - v * l, Ie = o * S - m * l, Be = o * v - m * h, Ue = a * S - E * l, ke = a * v - E * h, ht = a * m - E * o, rt = h * _ - f * l, Mt = o * _ - d * l, Kt = o * f - d * h, zi = a * _ - u * l, Gi = a * f - u * h, Xi = a * d - u * o, _s = -(s * y - r * A + n * C), gs = +(i * y - r * b + n * M), ps = -(i * A - s * b + n * L), ms = +(i * C - s * M + r * L), Es = +(s * Ce - r * Ie + n * Be), vs = -(i * Ce - r * Ue + n * ke), Dt = +(i * Ie - s * Ue + n * ht), Ft = -(i * Be - s * ke + r * ht), wt = -(s * rt - r * Mt + n * Kt), Ot = +(i * rt - r * zi + n * Gi), Gr = -(i * Mt - s * zi + n * Xi), Xr = +(i * Kt - s * Gi + r * Xi);
    return x.FromValuesToRef(k * ee, _s * ee, Es * ee, wt * ee, F * ee, gs * ee, vs * ee, Ot * ee, ue * ee, ps * ee, Dt * ee, Gr * ee, ce * ee, ms * ee, Ft * ee, Xr * ee, e), e;
  }
  addAtIndex(e, t) {
    return this._m[e] += t, this.markAsUpdated(), this;
  }
  multiplyAtIndex(e, t) {
    return this._m[e] *= t, this.markAsUpdated(), this;
  }
  setTranslationFromFloats(e, t, i) {
    return this._m[12] = e, this._m[13] = t, this._m[14] = i, this.markAsUpdated(), this;
  }
  addTranslationFromFloats(e, t, i) {
    return this._m[12] += e, this._m[13] += t, this._m[14] += i, this.markAsUpdated(), this;
  }
  setTranslation(e) {
    return this.setTranslationFromFloats(e._x, e._y, e._z);
  }
  getTranslation() {
    return new p(this._m[12], this._m[13], this._m[14]);
  }
  getTranslationToRef(e) {
    return e.x = this._m[12], e.y = this._m[13], e.z = this._m[14], e;
  }
  removeRotationAndScaling() {
    const e = this.m;
    return x.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e[12], e[13], e[14], e[15], this), this._updateIdentityStatus(e[12] === 0 && e[13] === 0 && e[14] === 0 && e[15] === 1), this;
  }
  multiply(e) {
    const t = new this.constructor();
    return this.multiplyToRef(e, t), t;
  }
  copyFrom(e) {
    e.copyToArray(this._m);
    const t = e;
    return this.updateFlag = t.updateFlag, this._updateIdentityStatus(t._isIdentity, t._isIdentityDirty, t._isIdentity3x2, t._isIdentity3x2Dirty), this;
  }
  copyToArray(e, t = 0) {
    const i = this._m;
    return e[t] = i[0], e[t + 1] = i[1], e[t + 2] = i[2], e[t + 3] = i[3], e[t + 4] = i[4], e[t + 5] = i[5], e[t + 6] = i[6], e[t + 7] = i[7], e[t + 8] = i[8], e[t + 9] = i[9], e[t + 10] = i[10], e[t + 11] = i[11], e[t + 12] = i[12], e[t + 13] = i[13], e[t + 14] = i[14], e[t + 15] = i[15], this;
  }
  multiplyToRef(e, t) {
    return this._isIdentity ? (t.copyFrom(e), t) : e._isIdentity ? (t.copyFrom(this), t) : (this.multiplyToArray(e, t._m, 0), t.markAsUpdated(), t);
  }
  multiplyToArray(e, t, i) {
    const s = this._m, r = e.m, n = s[0], a = s[1], o = s[2], h = s[3], l = s[4], u = s[5], d = s[6], f = s[7], _ = s[8], E = s[9], m = s[10], v = s[11], S = s[12], y = s[13], A = s[14], C = s[15], b = r[0], M = r[1], L = r[2], k = r[3], F = r[4], ue = r[5], ce = r[6], ie = r[7], ee = r[8], Ce = r[9], Ie = r[10], Be = r[11], Ue = r[12], ke = r[13], ht = r[14], rt = r[15];
    return t[i] = n * b + a * F + o * ee + h * Ue, t[i + 1] = n * M + a * ue + o * Ce + h * ke, t[i + 2] = n * L + a * ce + o * Ie + h * ht, t[i + 3] = n * k + a * ie + o * Be + h * rt, t[i + 4] = l * b + u * F + d * ee + f * Ue, t[i + 5] = l * M + u * ue + d * Ce + f * ke, t[i + 6] = l * L + u * ce + d * Ie + f * ht, t[i + 7] = l * k + u * ie + d * Be + f * rt, t[i + 8] = _ * b + E * F + m * ee + v * Ue, t[i + 9] = _ * M + E * ue + m * Ce + v * ke, t[i + 10] = _ * L + E * ce + m * Ie + v * ht, t[i + 11] = _ * k + E * ie + m * Be + v * rt, t[i + 12] = S * b + y * F + A * ee + C * Ue, t[i + 13] = S * M + y * ue + A * Ce + C * ke, t[i + 14] = S * L + y * ce + A * Ie + C * ht, t[i + 15] = S * k + y * ie + A * Be + C * rt, this;
  }
  equals(e) {
    const t = e;
    if (!t)
      return !1;
    if ((this._isIdentity || t._isIdentity) && !this._isIdentityDirty && !t._isIdentityDirty)
      return this._isIdentity && t._isIdentity;
    const i = this.m, s = t.m;
    return i[0] === s[0] && i[1] === s[1] && i[2] === s[2] && i[3] === s[3] && i[4] === s[4] && i[5] === s[5] && i[6] === s[6] && i[7] === s[7] && i[8] === s[8] && i[9] === s[9] && i[10] === s[10] && i[11] === s[11] && i[12] === s[12] && i[13] === s[13] && i[14] === s[14] && i[15] === s[15];
  }
  clone() {
    const e = new this.constructor();
    return e.copyFrom(this), e;
  }
  getClassName() {
    return "Matrix";
  }
  getHashCode() {
    let e = it(this._m[0]);
    for (let t = 1; t < 16; t++)
      e = e * 397 ^ it(this._m[t]);
    return e;
  }
  decomposeToTransformNode(e) {
    return e.rotationQuaternion = e.rotationQuaternion || new Y(), this.decompose(e.scaling, e.rotationQuaternion, e.position);
  }
  decompose(e, t, i, s) {
    if (this._isIdentity)
      return i && i.setAll(0), e && e.setAll(1), t && t.copyFromFloats(0, 0, 0, 1), !0;
    const r = this._m;
    if (i && i.copyFromFloats(r[12], r[13], r[14]), e = e || H.Vector3[0], e.x = Math.sqrt(r[0] * r[0] + r[1] * r[1] + r[2] * r[2]), e.y = Math.sqrt(r[4] * r[4] + r[5] * r[5] + r[6] * r[6]), e.z = Math.sqrt(r[8] * r[8] + r[9] * r[9] + r[10] * r[10]), s) {
      const n = s.scaling.x < 0 ? -1 : 1, a = s.scaling.y < 0 ? -1 : 1, o = s.scaling.z < 0 ? -1 : 1;
      e.x *= n, e.y *= a, e.z *= o;
    } else
      this.determinant() <= 0 && (e.y *= -1);
    if (e._x === 0 || e._y === 0 || e._z === 0)
      return t && t.copyFromFloats(0, 0, 0, 1), !1;
    if (t) {
      const n = 1 / e._x, a = 1 / e._y, o = 1 / e._z;
      x.FromValuesToRef(r[0] * n, r[1] * n, r[2] * n, 0, r[4] * a, r[5] * a, r[6] * a, 0, r[8] * o, r[9] * o, r[10] * o, 0, 0, 0, 0, 1, H.Matrix[0]), Y.FromRotationMatrixToRef(H.Matrix[0], t);
    }
    return !0;
  }
  getRow(e) {
    if (e < 0 || e > 3)
      return null;
    const t = e * 4;
    return new Ae(this._m[t + 0], this._m[t + 1], this._m[t + 2], this._m[t + 3]);
  }
  getRowToRef(e, t) {
    if (e >= 0 && e < 3) {
      const i = e * 4;
      t.x = this._m[i + 0], t.y = this._m[i + 1], t.z = this._m[i + 2], t.w = this._m[i + 3];
    }
    return t;
  }
  setRow(e, t) {
    return this.setRowFromFloats(e, t.x, t.y, t.z, t.w);
  }
  transpose() {
    const e = new this.constructor();
    return x.TransposeToRef(this, e), e;
  }
  transposeToRef(e) {
    return x.TransposeToRef(this, e), e;
  }
  setRowFromFloats(e, t, i, s, r) {
    if (e < 0 || e > 3)
      return this;
    const n = e * 4;
    return this._m[n + 0] = t, this._m[n + 1] = i, this._m[n + 2] = s, this._m[n + 3] = r, this.markAsUpdated(), this;
  }
  scale(e) {
    const t = new this.constructor();
    return this.scaleToRef(e, t), t;
  }
  scaleToRef(e, t) {
    for (let i = 0; i < 16; i++)
      t._m[i] = this._m[i] * e;
    return t.markAsUpdated(), t;
  }
  scaleAndAddToRef(e, t) {
    for (let i = 0; i < 16; i++)
      t._m[i] += this._m[i] * e;
    return t.markAsUpdated(), t;
  }
  toNormalMatrix(e) {
    const t = H.Matrix[0];
    this.invertToRef(t), t.transposeToRef(e);
    const i = e._m;
    return x.FromValuesToRef(i[0], i[1], i[2], 0, i[4], i[5], i[6], 0, i[8], i[9], i[10], 0, 0, 0, 0, 1, e), e;
  }
  getRotationMatrix() {
    const e = new this.constructor();
    return this.getRotationMatrixToRef(e), e;
  }
  getRotationMatrixToRef(e) {
    const t = H.Vector3[0];
    if (!this.decompose(t))
      return x.IdentityToRef(e), e;
    const i = this._m, s = 1 / t._x, r = 1 / t._y, n = 1 / t._z;
    return x.FromValuesToRef(i[0] * s, i[1] * s, i[2] * s, 0, i[4] * r, i[5] * r, i[6] * r, 0, i[8] * n, i[9] * n, i[10] * n, 0, 0, 0, 0, 1, e), e;
  }
  toggleModelMatrixHandInPlace() {
    const e = this._m;
    return e[2] *= -1, e[6] *= -1, e[8] *= -1, e[9] *= -1, e[14] *= -1, this.markAsUpdated(), this;
  }
  toggleProjectionMatrixHandInPlace() {
    const e = this._m;
    return e[8] *= -1, e[9] *= -1, e[10] *= -1, e[11] *= -1, this.markAsUpdated(), this;
  }
  static FromArray(e, t = 0) {
    const i = new x();
    return x.FromArrayToRef(e, t, i), i;
  }
  static FromArrayToRef(e, t, i) {
    for (let s = 0; s < 16; s++)
      i._m[s] = e[s + t];
    return i.markAsUpdated(), i;
  }
  static FromFloat32ArrayToRefScaled(e, t, i, s) {
    for (let r = 0; r < 16; r++)
      s._m[r] = e[r + t] * i;
    return s.markAsUpdated(), s;
  }
  static get IdentityReadOnly() {
    return x._IdentityReadOnly;
  }
  static FromValuesToRef(e, t, i, s, r, n, a, o, h, l, u, d, f, _, E, m, v) {
    const S = v._m;
    S[0] = e, S[1] = t, S[2] = i, S[3] = s, S[4] = r, S[5] = n, S[6] = a, S[7] = o, S[8] = h, S[9] = l, S[10] = u, S[11] = d, S[12] = f, S[13] = _, S[14] = E, S[15] = m, v.markAsUpdated();
  }
  static FromValues(e, t, i, s, r, n, a, o, h, l, u, d, f, _, E, m) {
    const v = new x(), S = v._m;
    return S[0] = e, S[1] = t, S[2] = i, S[3] = s, S[4] = r, S[5] = n, S[6] = a, S[7] = o, S[8] = h, S[9] = l, S[10] = u, S[11] = d, S[12] = f, S[13] = _, S[14] = E, S[15] = m, v.markAsUpdated(), v;
  }
  static Compose(e, t, i) {
    const s = new x();
    return x.ComposeToRef(e, t, i, s), s;
  }
  static ComposeToRef(e, t, i, s) {
    const r = s._m, n = t._x, a = t._y, o = t._z, h = t._w, l = n + n, u = a + a, d = o + o, f = n * l, _ = n * u, E = n * d, m = a * u, v = a * d, S = o * d, y = h * l, A = h * u, C = h * d, b = e._x, M = e._y, L = e._z;
    return r[0] = (1 - (m + S)) * b, r[1] = (_ + C) * b, r[2] = (E - A) * b, r[3] = 0, r[4] = (_ - C) * M, r[5] = (1 - (f + S)) * M, r[6] = (v + y) * M, r[7] = 0, r[8] = (E + A) * L, r[9] = (v - y) * L, r[10] = (1 - (f + m)) * L, r[11] = 0, r[12] = i._x, r[13] = i._y, r[14] = i._z, r[15] = 1, s.markAsUpdated(), s;
  }
  static Identity() {
    const e = x.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    return e._updateIdentityStatus(!0), e;
  }
  static IdentityToRef(e) {
    return x.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, e), e._updateIdentityStatus(!0), e;
  }
  static Zero() {
    const e = x.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    return e._updateIdentityStatus(!1), e;
  }
  static RotationX(e) {
    const t = new x();
    return x.RotationXToRef(e, t), t;
  }
  static Invert(e) {
    const t = new e.constructor();
    return e.invertToRef(t), t;
  }
  static RotationXToRef(e, t) {
    const i = Math.sin(e), s = Math.cos(e);
    return x.FromValuesToRef(1, 0, 0, 0, 0, s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0), t;
  }
  static RotationY(e) {
    const t = new x();
    return x.RotationYToRef(e, t), t;
  }
  static RotationYToRef(e, t) {
    const i = Math.sin(e), s = Math.cos(e);
    return x.FromValuesToRef(s, 0, -i, 0, 0, 1, 0, 0, i, 0, s, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0), t;
  }
  static RotationZ(e) {
    const t = new x();
    return x.RotationZToRef(e, t), t;
  }
  static RotationZToRef(e, t) {
    const i = Math.sin(e), s = Math.cos(e);
    return x.FromValuesToRef(s, i, 0, 0, -i, s, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, t), t._updateIdentityStatus(s === 1 && i === 0), t;
  }
  static RotationAxis(e, t) {
    const i = new x();
    return x.RotationAxisToRef(e, t, i), i;
  }
  static RotationAxisToRef(e, t, i) {
    const s = Math.sin(-t), r = Math.cos(-t), n = 1 - r;
    e.normalize();
    const a = i._m;
    return a[0] = e._x * e._x * n + r, a[1] = e._x * e._y * n - e._z * s, a[2] = e._x * e._z * n + e._y * s, a[3] = 0, a[4] = e._y * e._x * n + e._z * s, a[5] = e._y * e._y * n + r, a[6] = e._y * e._z * n - e._x * s, a[7] = 0, a[8] = e._z * e._x * n - e._y * s, a[9] = e._z * e._y * n + e._x * s, a[10] = e._z * e._z * n + r, a[11] = 0, a[12] = 0, a[13] = 0, a[14] = 0, a[15] = 1, i.markAsUpdated(), i;
  }
  static RotationAlignToRef(e, t, i) {
    const s = p.Dot(t, e), r = i._m;
    if (s < -1 + Re)
      r[0] = -1, r[1] = 0, r[2] = 0, r[3] = 0, r[4] = 0, r[5] = -1, r[6] = 0, r[7] = 0, r[8] = 0, r[9] = 0, r[10] = 1, r[11] = 0;
    else {
      const n = p.Cross(t, e), a = 1 / (1 + s);
      r[0] = n._x * n._x * a + s, r[1] = n._y * n._x * a - n._z, r[2] = n._z * n._x * a + n._y, r[3] = 0, r[4] = n._x * n._y * a + n._z, r[5] = n._y * n._y * a + s, r[6] = n._z * n._y * a - n._x, r[7] = 0, r[8] = n._x * n._z * a - n._y, r[9] = n._y * n._z * a + n._x, r[10] = n._z * n._z * a + s, r[11] = 0;
    }
    return r[12] = 0, r[13] = 0, r[14] = 0, r[15] = 1, i.markAsUpdated(), i;
  }
  static RotationYawPitchRoll(e, t, i) {
    const s = new x();
    return x.RotationYawPitchRollToRef(e, t, i, s), s;
  }
  static RotationYawPitchRollToRef(e, t, i, s) {
    return Y.RotationYawPitchRollToRef(e, t, i, H.Quaternion[0]), H.Quaternion[0].toRotationMatrix(s), s;
  }
  static Scaling(e, t, i) {
    const s = new x();
    return x.ScalingToRef(e, t, i, s), s;
  }
  static ScalingToRef(e, t, i, s) {
    return x.FromValuesToRef(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1, s), s._updateIdentityStatus(e === 1 && t === 1 && i === 1), s;
  }
  static Translation(e, t, i) {
    const s = new x();
    return x.TranslationToRef(e, t, i, s), s;
  }
  static TranslationToRef(e, t, i, s) {
    return x.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, e, t, i, 1, s), s._updateIdentityStatus(e === 0 && t === 0 && i === 0), s;
  }
  static Lerp(e, t, i) {
    const s = new e.constructor();
    return x.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    const r = s._m, n = e.m, a = t.m;
    for (let o = 0; o < 16; o++)
      r[o] = n[o] * (1 - i) + a[o] * i;
    return s.markAsUpdated(), s;
  }
  static DecomposeLerp(e, t, i) {
    const s = new e.constructor();
    return x.DecomposeLerpToRef(e, t, i, s), s;
  }
  static DecomposeLerpToRef(e, t, i, s) {
    const r = H.Vector3[0], n = H.Quaternion[0], a = H.Vector3[1];
    e.decompose(r, n, a);
    const o = H.Vector3[2], h = H.Quaternion[1], l = H.Vector3[3];
    t.decompose(o, h, l);
    const u = H.Vector3[4];
    p.LerpToRef(r, o, i, u);
    const d = H.Quaternion[2];
    Y.SlerpToRef(n, h, i, d);
    const f = H.Vector3[5];
    return p.LerpToRef(a, l, i, f), x.ComposeToRef(u, d, f, s), s;
  }
  static LookAtLH(e, t, i) {
    const s = new x();
    return x.LookAtLHToRef(e, t, i, s), s;
  }
  static LookAtLHToRef(e, t, i, s) {
    const r = H.Vector3[0], n = H.Vector3[1], a = H.Vector3[2];
    t.subtractToRef(e, a), a.normalize(), p.CrossToRef(i, a, r);
    const o = r.lengthSquared();
    o === 0 ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)), p.CrossToRef(a, r, n), n.normalize();
    const h = -p.Dot(r, e), l = -p.Dot(n, e), u = -p.Dot(a, e);
    x.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, h, l, u, 1, s);
  }
  static LookAtRH(e, t, i) {
    const s = new x();
    return x.LookAtRHToRef(e, t, i, s), s;
  }
  static LookAtRHToRef(e, t, i, s) {
    const r = H.Vector3[0], n = H.Vector3[1], a = H.Vector3[2];
    e.subtractToRef(t, a), a.normalize(), p.CrossToRef(i, a, r);
    const o = r.lengthSquared();
    o === 0 ? r.x = 1 : r.normalizeFromLength(Math.sqrt(o)), p.CrossToRef(a, r, n), n.normalize();
    const h = -p.Dot(r, e), l = -p.Dot(n, e), u = -p.Dot(a, e);
    return x.FromValuesToRef(r._x, n._x, a._x, 0, r._y, n._y, a._y, 0, r._z, n._z, a._z, 0, h, l, u, 1, s), s;
  }
  static LookDirectionLH(e, t) {
    const i = new x();
    return x.LookDirectionLHToRef(e, t, i), i;
  }
  static LookDirectionLHToRef(e, t, i) {
    const s = H.Vector3[0];
    s.copyFrom(e), s.scaleInPlace(-1);
    const r = H.Vector3[1];
    return p.CrossToRef(t, s, r), x.FromValuesToRef(r._x, r._y, r._z, 0, t._x, t._y, t._z, 0, s._x, s._y, s._z, 0, 0, 0, 0, 1, i), i;
  }
  static LookDirectionRH(e, t) {
    const i = new x();
    return x.LookDirectionRHToRef(e, t, i), i;
  }
  static LookDirectionRHToRef(e, t, i) {
    const s = H.Vector3[2];
    return p.CrossToRef(t, e, s), x.FromValuesToRef(s._x, s._y, s._z, 0, t._x, t._y, t._z, 0, e._x, e._y, e._z, 0, 0, 0, 0, 1, i), i;
  }
  static OrthoLH(e, t, i, s, r) {
    const n = new x();
    return x.OrthoLHToRef(e, t, i, s, n, r), n;
  }
  static OrthoLHToRef(e, t, i, s, r, n) {
    const a = i, o = s, h = 2 / e, l = 2 / t, u = 2 / (o - a), d = -(o + a) / (o - a);
    return x.FromValuesToRef(h, 0, 0, 0, 0, l, 0, 0, 0, 0, u, 0, 0, 0, d, 1, r), n && r.multiplyToRef(Yt, r), r._updateIdentityStatus(h === 1 && l === 1 && u === 1 && d === 0), r;
  }
  static OrthoOffCenterLH(e, t, i, s, r, n, a) {
    const o = new x();
    return x.OrthoOffCenterLHToRef(e, t, i, s, r, n, o, a), o;
  }
  static OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o) {
    const h = r, l = n, u = 2 / (t - e), d = 2 / (s - i), f = 2 / (l - h), _ = -(l + h) / (l - h), E = (e + t) / (e - t), m = (s + i) / (i - s);
    return x.FromValuesToRef(u, 0, 0, 0, 0, d, 0, 0, 0, 0, f, 0, E, m, _, 1, a), o && a.multiplyToRef(Yt, a), a.markAsUpdated(), a;
  }
  static OrthoOffCenterRH(e, t, i, s, r, n, a) {
    const o = new x();
    return x.OrthoOffCenterRHToRef(e, t, i, s, r, n, o, a), o;
  }
  static OrthoOffCenterRHToRef(e, t, i, s, r, n, a, o) {
    return x.OrthoOffCenterLHToRef(e, t, i, s, r, n, a, o), a._m[10] *= -1, a;
  }
  static PerspectiveLH(e, t, i, s, r, n = 0) {
    const a = new x(), o = i, h = s, l = 2 * o / e, u = 2 * o / t, d = (h + o) / (h - o), f = -2 * h * o / (h - o), _ = Math.tan(n);
    return x.FromValuesToRef(l, 0, 0, 0, 0, u, 0, _, 0, 0, d, 1, 0, 0, f, 0, a), r && a.multiplyToRef(Yt, a), a._updateIdentityStatus(!1), a;
  }
  static PerspectiveFovLH(e, t, i, s, r, n = 0, a = !1) {
    const o = new x();
    return x.PerspectiveFovLHToRef(e, t, i, s, o, !0, r, n, a), o;
  }
  static PerspectiveFovLHToRef(e, t, i, s, r, n = !0, a, o = 0, h = !1) {
    const l = i, u = s, d = 1 / Math.tan(e * 0.5), f = n ? d / t : d, _ = n ? d : d * t, E = h && l === 0 ? -1 : u !== 0 ? (u + l) / (u - l) : 1, m = h && l === 0 ? 2 * u : u !== 0 ? -2 * u * l / (u - l) : -2 * l, v = Math.tan(o);
    return x.FromValuesToRef(f, 0, 0, 0, 0, _, 0, v, 0, 0, E, 1, 0, 0, m, 0, r), a && r.multiplyToRef(Yt, r), r._updateIdentityStatus(!1), r;
  }
  static PerspectiveFovReverseLHToRef(e, t, i, s, r, n = !0, a, o = 0) {
    const h = 1 / Math.tan(e * 0.5), l = n ? h / t : h, u = n ? h : h * t, d = Math.tan(o);
    return x.FromValuesToRef(l, 0, 0, 0, 0, u, 0, d, 0, 0, -i, 1, 0, 0, 1, 0, r), a && r.multiplyToRef(Yt, r), r._updateIdentityStatus(!1), r;
  }
  static PerspectiveFovRH(e, t, i, s, r, n = 0, a = !1) {
    const o = new x();
    return x.PerspectiveFovRHToRef(e, t, i, s, o, !0, r, n, a), o;
  }
  static PerspectiveFovRHToRef(e, t, i, s, r, n = !0, a, o = 0, h = !1) {
    const l = i, u = s, d = 1 / Math.tan(e * 0.5), f = n ? d / t : d, _ = n ? d : d * t, E = h && l === 0 ? 1 : u !== 0 ? -(u + l) / (u - l) : -1, m = h && l === 0 ? 2 * u : u !== 0 ? -2 * u * l / (u - l) : -2 * l, v = Math.tan(o);
    return x.FromValuesToRef(f, 0, 0, 0, 0, _, 0, v, 0, 0, E, -1, 0, 0, m, 0, r), a && r.multiplyToRef(Yt, r), r._updateIdentityStatus(!1), r;
  }
  static PerspectiveFovReverseRHToRef(e, t, i, s, r, n = !0, a, o = 0) {
    const h = 1 / Math.tan(e * 0.5), l = n ? h / t : h, u = n ? h : h * t, d = Math.tan(o);
    return x.FromValuesToRef(l, 0, 0, 0, 0, u, 0, d, 0, 0, -i, -1, 0, 0, -1, 0, r), a && r.multiplyToRef(Yt, r), r._updateIdentityStatus(!1), r;
  }
  static PerspectiveFovWebVRToRef(e, t, i, s, r = !1, n, a = 0) {
    const o = r ? -1 : 1, h = Math.tan(e.upDegrees * Math.PI / 180), l = Math.tan(e.downDegrees * Math.PI / 180), u = Math.tan(e.leftDegrees * Math.PI / 180), d = Math.tan(e.rightDegrees * Math.PI / 180), f = 2 / (u + d), _ = 2 / (h + l), E = Math.tan(a), m = s._m;
    return m[0] = f, m[1] = m[2] = m[3] = m[4] = 0, m[5] = _, m[6] = 0, m[7] = E, m[8] = (u - d) * f * 0.5, m[9] = -((h - l) * _ * 0.5), m[10] = -i / (t - i), m[11] = 1 * o, m[12] = m[13] = m[15] = 0, m[14] = -(2 * i * t) / (i - t), n && s.multiplyToRef(Yt, s), s.markAsUpdated(), s;
  }
  static GetFinalMatrix(e, t, i, s, r, n) {
    const a = e.width, o = e.height, h = e.x, l = e.y, u = x.FromValues(a / 2, 0, 0, 0, 0, -o / 2, 0, 0, 0, 0, n - r, 0, h + a / 2, o / 2 + l, r, 1), d = new t.constructor();
    return t.multiplyToRef(i, d), d.multiplyToRef(s, d), d.multiplyToRef(u, d);
  }
  static GetAsMatrix2x2(e) {
    const t = e.m, i = [t[0], t[1], t[4], t[5]];
    return Ne.MatrixUse64Bits ? i : new Float32Array(i);
  }
  static GetAsMatrix3x3(e) {
    const t = e.m, i = [t[0], t[1], t[2], t[4], t[5], t[6], t[8], t[9], t[10]];
    return Ne.MatrixUse64Bits ? i : new Float32Array(i);
  }
  static Transpose(e) {
    const t = new e.constructor();
    return x.TransposeToRef(e, t), t;
  }
  static TransposeToRef(e, t) {
    const i = t._m, s = e.m;
    return i[0] = s[0], i[1] = s[4], i[2] = s[8], i[3] = s[12], i[4] = s[1], i[5] = s[5], i[6] = s[9], i[7] = s[13], i[8] = s[2], i[9] = s[6], i[10] = s[10], i[11] = s[14], i[12] = s[3], i[13] = s[7], i[14] = s[11], i[15] = s[15], t.markAsUpdated(), t._updateIdentityStatus(e._isIdentity, e._isIdentityDirty), t;
  }
  static Reflection(e) {
    const t = new x();
    return x.ReflectionToRef(e, t), t;
  }
  static ReflectionToRef(e, t) {
    e.normalize();
    const i = e.normal.x, s = e.normal.y, r = e.normal.z, n = -2 * i, a = -2 * s, o = -2 * r;
    return x.FromValuesToRef(n * i + 1, a * i, o * i, 0, n * s, a * s + 1, o * s, 0, n * r, a * r, o * r + 1, 0, n * e.d, a * e.d, o * e.d, 1, t), t;
  }
  static FromXYZAxesToRef(e, t, i, s) {
    return x.FromValuesToRef(e._x, e._y, e._z, 0, t._x, t._y, t._z, 0, i._x, i._y, i._z, 0, 0, 0, 0, 1, s), s;
  }
  static FromQuaternionToRef(e, t) {
    const i = e._x * e._x, s = e._y * e._y, r = e._z * e._z, n = e._x * e._y, a = e._z * e._w, o = e._z * e._x, h = e._y * e._w, l = e._y * e._z, u = e._x * e._w;
    return t._m[0] = 1 - 2 * (s + r), t._m[1] = 2 * (n + a), t._m[2] = 2 * (o - h), t._m[3] = 0, t._m[4] = 2 * (n - a), t._m[5] = 1 - 2 * (r + i), t._m[6] = 2 * (l + u), t._m[7] = 0, t._m[8] = 2 * (o + h), t._m[9] = 2 * (l - u), t._m[10] = 1 - 2 * (s + i), t._m[11] = 0, t._m[12] = 0, t._m[13] = 0, t._m[14] = 0, t._m[15] = 1, t.markAsUpdated(), t;
  }
}
x._UpdateFlagSeed = 0;
x._IdentityReadOnly = x.Identity();
class H {
}
H.Vector3 = Ye.BuildTuple(11, p.Zero);
H.Matrix = Ye.BuildTuple(2, x.Identity);
H.Quaternion = Ye.BuildTuple(3, Y.Zero);
class D {
}
D.Vector2 = Ye.BuildTuple(3, Te.Zero);
D.Vector3 = Ye.BuildTuple(13, p.Zero);
D.Vector4 = Ye.BuildTuple(3, Ae.Zero);
D.Quaternion = Ye.BuildTuple(2, Y.Zero);
D.Matrix = Ye.BuildTuple(8, x.Identity);
st("BABYLON.Vector2", Te);
st("BABYLON.Vector3", p);
st("BABYLON.Vector4", Ae);
st("BABYLON.Matrix", x);
const Yt = x.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
class qr {
  constructor(e, t = !1, i, s) {
    this.initialize(e, t, i, s);
  }
  initialize(e, t = !1, i, s) {
    return this.mask = e, this.skipNextObservers = t, this.target = i, this.currentTarget = s, this;
  }
}
class jr {
  constructor(e, t, i = null) {
    this.callback = e, this.mask = t, this.scope = i, this._willBeUnregistered = !1, this.unregisterOnNextCall = !1;
  }
}
class w {
  constructor(e) {
    this._observers = new Array(), this._numObserversMarkedAsDeleted = 0, this._eventState = new qr(0), e && (this._onObserverAdded = e);
  }
  static FromPromise(e, t) {
    const i = new w();
    return e.then((s) => {
      i.notifyObservers(s);
    }).catch((s) => {
      if (t)
        t.notifyObservers(s);
      else
        throw s;
    }), i;
  }
  get observers() {
    return this._observers;
  }
  add(e, t = -1, i = !1, s = null, r = !1) {
    if (!e)
      return null;
    const n = new jr(e, t, s);
    return n.unregisterOnNextCall = r, i ? this._observers.unshift(n) : this._observers.push(n), this._onObserverAdded && this._onObserverAdded(n), n;
  }
  addOnce(e) {
    return this.add(e, void 0, void 0, void 0, !0);
  }
  remove(e) {
    return e && this._observers.indexOf(e) !== -1 ? (this._deferUnregister(e), !0) : !1;
  }
  removeCallback(e, t) {
    for (let i = 0; i < this._observers.length; i++) {
      const s = this._observers[i];
      if (!s._willBeUnregistered && s.callback === e && (!t || t === s.scope))
        return this._deferUnregister(s), !0;
    }
    return !1;
  }
  _deferUnregister(e) {
    this._numObserversMarkedAsDeleted++, e.unregisterOnNextCall = !1, e._willBeUnregistered = !0, setTimeout(() => {
      this._remove(e);
    }, 0);
  }
  _remove(e, t = !0) {
    if (!e)
      return !1;
    const i = this._observers.indexOf(e);
    return i !== -1 ? (t && this._numObserversMarkedAsDeleted--, this._observers.splice(i, 1), !0) : !1;
  }
  makeObserverTopPriority(e) {
    this._remove(e, !1), this._observers.unshift(e);
  }
  makeObserverBottomPriority(e) {
    this._remove(e, !1), this._observers.push(e);
  }
  notifyObservers(e, t = -1, i, s, r) {
    if (!this._observers.length)
      return !0;
    const n = this._eventState;
    n.mask = t, n.target = i, n.currentTarget = s, n.skipNextObservers = !1, n.lastReturnValue = e, n.userInfo = r;
    for (const a of this._observers)
      if (!a._willBeUnregistered && (a.mask & t && (a.unregisterOnNextCall && this._deferUnregister(a), a.scope ? n.lastReturnValue = a.callback.apply(a.scope, [e, n]) : n.lastReturnValue = a.callback(e, n)), n.skipNextObservers))
        return !1;
    return !0;
  }
  notifyObserver(e, t, i = -1) {
    if (e._willBeUnregistered)
      return;
    const s = this._eventState;
    s.mask = i, s.skipNextObservers = !1, e.unregisterOnNextCall && this._deferUnregister(e), e.callback(t, s);
  }
  hasObservers() {
    return this._observers.length - this._numObserversMarkedAsDeleted > 0;
  }
  clear() {
    this._observers = new Array(), this._onObserverAdded = null, this._numObserversMarkedAsDeleted = 0;
  }
  clone() {
    const e = new w();
    return e._observers = this._observers.slice(0), e;
  }
  hasSpecificMask(e = -1) {
    for (const t of this._observers)
      if (t.mask & e || t.mask === e)
        return !0;
    return !1;
  }
}
class Qr {
  constructor() {
    this.samplingMode = -1, this._useMipMaps = !0, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this._comparisonFunction = 0;
  }
  get wrapU() {
    return this._cachedWrapU;
  }
  set wrapU(e) {
    this._cachedWrapU = e;
  }
  get wrapV() {
    return this._cachedWrapV;
  }
  set wrapV(e) {
    this._cachedWrapV = e;
  }
  get wrapR() {
    return this._cachedWrapR;
  }
  set wrapR(e) {
    this._cachedWrapR = e;
  }
  get anisotropicFilteringLevel() {
    return this._cachedAnisotropicFilteringLevel;
  }
  set anisotropicFilteringLevel(e) {
    this._cachedAnisotropicFilteringLevel = e;
  }
  get comparisonFunction() {
    return this._comparisonFunction;
  }
  set comparisonFunction(e) {
    this._comparisonFunction = e;
  }
  get useMipMaps() {
    return this._useMipMaps;
  }
  set useMipMaps(e) {
    this._useMipMaps = e;
  }
  setParameters(e = 1, t = 1, i = 1, s = 1, r = 2, n = 0) {
    return this._cachedWrapU = e, this._cachedWrapV = t, this._cachedWrapR = i, this._cachedAnisotropicFilteringLevel = s, this.samplingMode = r, this._comparisonFunction = n, this;
  }
  compareSampler(e) {
    return this._cachedWrapU === e._cachedWrapU && this._cachedWrapV === e._cachedWrapV && this._cachedWrapR === e._cachedWrapR && this._cachedAnisotropicFilteringLevel === e._cachedAnisotropicFilteringLevel && this.samplingMode === e.samplingMode && this._comparisonFunction === e._comparisonFunction && this._useMipMaps === e._useMipMaps;
  }
}
var Oe;
(function(c) {
  c[c.Unknown = 0] = "Unknown", c[c.Url = 1] = "Url", c[c.Temp = 2] = "Temp", c[c.Raw = 3] = "Raw", c[c.Dynamic = 4] = "Dynamic", c[c.RenderTarget = 5] = "RenderTarget", c[c.MultiRenderTarget = 6] = "MultiRenderTarget", c[c.Cube = 7] = "Cube", c[c.CubeRaw = 8] = "CubeRaw", c[c.CubePrefiltered = 9] = "CubePrefiltered", c[c.Raw3D = 10] = "Raw3D", c[c.Raw2DArray = 11] = "Raw2DArray", c[c.DepthStencil = 12] = "DepthStencil", c[c.CubeRawRGBD = 13] = "CubeRawRGBD", c[c.Depth = 14] = "Depth";
})(Oe || (Oe = {}));
class Vt extends Qr {
  constructor(e, t, i = !1) {
    super(), this.isReady = !1, this.isCube = !1, this.is3D = !1, this.is2DArray = !1, this.isMultiview = !1, this.url = "", this.generateMipMaps = !1, this.samples = 0, this.type = -1, this.format = -1, this.onLoadedObservable = new w(), this.onErrorObservable = new w(), this.onRebuildCallback = null, this.width = 0, this.height = 0, this.depth = 0, this.baseWidth = 0, this.baseHeight = 0, this.baseDepth = 0, this.invertY = !1, this._invertVScale = !1, this._associatedChannel = -1, this._source = Oe.Unknown, this._buffer = null, this._bufferView = null, this._bufferViewArray = null, this._bufferViewArrayArray = null, this._size = 0, this._extension = "", this._files = null, this._workingCanvas = null, this._workingContext = null, this._cachedCoordinatesMode = null, this._isDisabled = !1, this._compression = null, this._sphericalPolynomial = null, this._sphericalPolynomialPromise = null, this._sphericalPolynomialComputed = !1, this._lodGenerationScale = 0, this._lodGenerationOffset = 0, this._useSRGBBuffer = !1, this._lodTextureHigh = null, this._lodTextureMid = null, this._lodTextureLow = null, this._isRGBD = !1, this._linearSpecularLOD = !1, this._irradianceTexture = null, this._hardwareTexture = null, this._maxLodLevel = null, this._references = 1, this._gammaSpace = null, this._engine = e, this._source = t, this._uniqueId = Vt._Counter++, i || (this._hardwareTexture = e._createHardwareTexture());
  }
  get useMipMaps() {
    return this.generateMipMaps;
  }
  set useMipMaps(e) {
    this.generateMipMaps = e;
  }
  get uniqueId() {
    return this._uniqueId;
  }
  _setUniqueId(e) {
    this._uniqueId = e;
  }
  getEngine() {
    return this._engine;
  }
  get source() {
    return this._source;
  }
  incrementReferences() {
    this._references++;
  }
  updateSize(e, t, i = 1) {
    this._engine.updateTextureDimensions(this, e, t, i), this.width = e, this.height = t, this.depth = i, this.baseWidth = e, this.baseHeight = t, this.baseDepth = i, this._size = e * t * i;
  }
  _rebuild() {
    var e;
    if (this.isReady = !1, this._cachedCoordinatesMode = null, this._cachedWrapU = null, this._cachedWrapV = null, this._cachedWrapR = null, this._cachedAnisotropicFilteringLevel = null, this.onRebuildCallback) {
      const i = this.onRebuildCallback(this), s = (r) => {
        r._swapAndDie(this, !1), this.isReady = i.isReady;
      };
      i.isAsync ? i.proxy.then(s) : s(i.proxy);
      return;
    }
    let t;
    switch (this.source) {
      case Oe.Temp:
        break;
      case Oe.Url:
        t = this._engine.createTexture(
          (e = this._originalUrl) !== null && e !== void 0 ? e : this.url,
          !this.generateMipMaps,
          this.invertY,
          null,
          this.samplingMode,
          (i) => {
            i._swapAndDie(this, !1), this.isReady = !0;
          },
          null,
          this._buffer,
          void 0,
          this.format,
          this._extension,
          void 0,
          void 0,
          void 0,
          this._useSRGBBuffer
        );
        return;
      case Oe.Raw:
        t = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer), t._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Oe.Raw3D:
        t = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), t._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Oe.Raw2DArray:
        t = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type), t._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Oe.Dynamic:
        t = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode), t._swapAndDie(this, !1), this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, !0);
        break;
      case Oe.Cube:
        t = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {
          t._swapAndDie(this, !1), this.isReady = !0;
        }, null, this.format, this._extension, !1, 0, 0, null, void 0, this._useSRGBBuffer);
        return;
      case Oe.CubeRaw:
        t = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression), t._swapAndDie(this, !1), this.isReady = !0;
        break;
      case Oe.CubeRawRGBD:
        return;
      case Oe.CubePrefiltered:
        t = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (i) => {
          i && i._swapAndDie(this, !1), this.isReady = !0;
        }, null, this.format, this._extension), t._sphericalPolynomial = this._sphericalPolynomial;
        return;
    }
  }
  _swapAndDie(e, t = !0) {
    var i;
    (i = this._hardwareTexture) === null || i === void 0 || i.setUsage(e._source, this.generateMipMaps, this.isCube, this.width, this.height), e._hardwareTexture = this._hardwareTexture, t && (e._isRGBD = this._isRGBD), this._lodTextureHigh && (e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureHigh = this._lodTextureHigh), this._lodTextureMid && (e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureMid = this._lodTextureMid), this._lodTextureLow && (e._lodTextureLow && e._lodTextureLow.dispose(), e._lodTextureLow = this._lodTextureLow), this._irradianceTexture && (e._irradianceTexture && e._irradianceTexture.dispose(), e._irradianceTexture = this._irradianceTexture);
    const s = this._engine.getLoadedTexturesCache();
    let r = s.indexOf(this);
    r !== -1 && s.splice(r, 1), r = s.indexOf(e), r === -1 && s.push(e);
  }
  dispose() {
    this._references--, this.onLoadedObservable.clear(), this.onErrorObservable.clear(), this._references === 0 && (this._engine._releaseTexture(this), this._hardwareTexture = null);
  }
}
Vt._Counter = 0;
function Ze() {
  return typeof window < "u";
}
function xr() {
  return typeof navigator < "u";
}
function Di() {
  return typeof document < "u";
}
function Bs(c) {
  let e = "", t = c.firstChild;
  for (; t; )
    t.nodeType === 3 && (e += t.textContent), t = t.nextSibling;
  return e;
}
const Fs = {
  IsWindowObjectExist: Ze,
  IsNavigatorAvailable: xr,
  IsDocumentAvailable: Di,
  GetDOMTextContent: Bs
};
function Q(c) {
  return `${c} needs to be imported before as it contains a side-effect required by your code.`;
}
class O {
  static _CheckLimit(e, t) {
    let i = O._LogLimitOutputs[e];
    return i ? i.current++ : (i = { limit: t, current: 1 }, O._LogLimitOutputs[e] = i), i.current <= i.limit;
  }
  static _GenerateLimitMessage(e, t = 1) {
    var i;
    const s = O._LogLimitOutputs[e];
    if (!s || !O.MessageLimitReached)
      return;
    const r = this._Levels[t];
    s.current === s.limit && O[r.name](O.MessageLimitReached.replace(/%LIMIT%/g, "" + s.limit).replace(/%TYPE%/g, (i = r.name) !== null && i !== void 0 ? i : ""));
  }
  static _AddLogEntry(e) {
    O._LogCache = e + O._LogCache, O.OnNewCacheEntry && O.OnNewCacheEntry(e);
  }
  static _FormatMessage(e) {
    const t = (s) => s < 10 ? "0" + s : "" + s, i = new Date();
    return "[" + t(i.getHours()) + ":" + t(i.getMinutes()) + ":" + t(i.getSeconds()) + "]: " + e;
  }
  static _LogDisabled(e, t) {
  }
  static _LogEnabled(e = 1, t, i) {
    if (i !== void 0 && !O._CheckLimit(t, i))
      return;
    const s = O._FormatMessage(t), r = this._Levels[e];
    r.logFunc && r.logFunc("BJS - " + s);
    const n = `<div style='color:${r.color}'>${s}</div><br>`;
    O._AddLogEntry(n), O._GenerateLimitMessage(t, e);
  }
  static get LogCache() {
    return O._LogCache;
  }
  static ClearLogCache() {
    O._LogCache = "", O._LogLimitOutputs = {}, O.errorsCount = 0;
  }
  static set LogLevels(e) {
    O.Log = O._LogDisabled, O.Warn = O._LogDisabled, O.Error = O._LogDisabled, [O.MessageLogLevel, O.WarningLogLevel, O.ErrorLogLevel].forEach((t) => {
      if ((e & t) === t) {
        const i = this._Levels[t];
        O[i.name] = O._LogEnabled.bind(O, t);
      }
    });
  }
}
O.NoneLogLevel = 0;
O.MessageLogLevel = 1;
O.WarningLogLevel = 2;
O.ErrorLogLevel = 4;
O.AllLogLevel = 7;
O.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
O._LogCache = "";
O._LogLimitOutputs = {};
O._Levels = [
  {},
  { color: "white", logFunc: console.log, name: "Log" },
  { color: "orange", logFunc: console.warn, name: "Warn" },
  {},
  { color: "red", logFunc: console.error, name: "Error" }
];
O.errorsCount = 0;
O.Log = O._LogEnabled.bind(O, O.MessageLogLevel);
O.Warn = O._LogEnabled.bind(O, O.WarningLogLevel);
O.Error = O._LogEnabled.bind(O, O.ErrorLogLevel);
const $r = "attribute", Jr = "varying";
class Ci {
  constructor() {
    this.children = [];
  }
  isValid(e) {
    return !0;
  }
  process(e, t) {
    var i, s, r, n, a, o;
    let h = "";
    if (this.line) {
      let l = this.line;
      const u = t.processor;
      if (u) {
        u.lineProcessor && (l = u.lineProcessor(l, t.isFragment, t.processingContext));
        const d = (s = (i = t.processor) === null || i === void 0 ? void 0 : i.attributeKeywordName) !== null && s !== void 0 ? s : $r, f = t.isFragment && ((r = t.processor) === null || r === void 0 ? void 0 : r.varyingFragmentKeywordName) ? (n = t.processor) === null || n === void 0 ? void 0 : n.varyingFragmentKeywordName : !t.isFragment && ((a = t.processor) === null || a === void 0 ? void 0 : a.varyingVertexKeywordName) ? (o = t.processor) === null || o === void 0 ? void 0 : o.varyingVertexKeywordName : Jr;
        !t.isFragment && u.attributeProcessor && this.line.startsWith(d) ? l = u.attributeProcessor(this.line, e, t.processingContext) : u.varyingProcessor && this.line.startsWith(f) ? l = u.varyingProcessor(this.line, t.isFragment, e, t.processingContext) : u.uniformProcessor && u.uniformRegexp && u.uniformRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (l = u.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : u.uniformBufferProcessor && u.uniformBufferRegexp && u.uniformBufferRegexp.test(this.line) ? t.lookForClosingBracketForUniformBuffer || (l = u.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0) : u.textureProcessor && u.textureRegexp && u.textureRegexp.test(this.line) ? l = u.textureProcessor(this.line, t.isFragment, e, t.processingContext) : (u.uniformProcessor || u.uniformBufferProcessor) && this.line.startsWith("uniform") && !t.lookForClosingBracketForUniformBuffer && (/uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/.test(this.line) ? u.uniformProcessor && (l = u.uniformProcessor(this.line, t.isFragment, e, t.processingContext)) : u.uniformBufferProcessor && (l = u.uniformBufferProcessor(this.line, t.isFragment, t.processingContext), t.lookForClosingBracketForUniformBuffer = !0)), t.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1 && (t.lookForClosingBracketForUniformBuffer = !1, u.endOfUniformBufferProcessor && (l = u.endOfUniformBufferProcessor(this.line, t.isFragment, t.processingContext)));
      }
      h += l + `\r
`;
    }
    return this.children.forEach((l) => {
      h += l.process(e, t);
    }), this.additionalDefineKey && (e[this.additionalDefineKey] = this.additionalDefineValue || "true"), h;
  }
}
class en {
  constructor() {
    this._lines = [];
  }
  get currentLine() {
    return this._lines[this.lineIndex];
  }
  get canRead() {
    return this.lineIndex < this._lines.length - 1;
  }
  set lines(e) {
    this._lines.length = 0;
    for (const t of e) {
      if (t[0] === "#") {
        this._lines.push(t);
        continue;
      }
      if (t.trim().startsWith("//")) {
        this._lines.push(t);
        continue;
      }
      const i = t.split(";");
      for (let s = 0; s < i.length; s++) {
        let r = i[s];
        r = r.trim(), r && this._lines.push(r + (s !== i.length - 1 ? ";" : ""));
      }
    }
  }
}
class bs extends Ci {
  process(e, t) {
    for (let i = 0; i < this.children.length; i++) {
      const s = this.children[i];
      if (s.isValid(e))
        return s.process(e, t);
    }
    return "";
  }
}
class tn extends Ci {
  isValid(e) {
    return this.testExpression.isTrue(e);
  }
}
class Je {
  isTrue(e) {
    return !0;
  }
  static postfixToInfix(e) {
    const t = [];
    for (const i of e)
      if (Je._OperatorPriority[i] === void 0)
        t.push(i);
      else {
        const s = t[t.length - 1], r = t[t.length - 2];
        t.length -= 2, t.push(`(${r}${i}${s})`);
      }
    return t[t.length - 1];
  }
  static infixToPostfix(e) {
    const t = [];
    let i = -1;
    const s = () => {
      h = h.trim(), h !== "" && (t.push(h), h = "");
    }, r = (l) => {
      i < Je._Stack.length - 1 && (Je._Stack[++i] = l);
    }, n = () => Je._Stack[i], a = () => i === -1 ? "!!INVALID EXPRESSION!!" : Je._Stack[i--];
    let o = 0, h = "";
    for (; o < e.length; ) {
      const l = e.charAt(o), u = o < e.length - 1 ? e.substr(o, 2) : "";
      if (l === "(")
        h = "", r(l);
      else if (l === ")") {
        for (s(); i !== -1 && n() !== "("; )
          t.push(a());
        a();
      } else if (Je._OperatorPriority[u] > 1) {
        for (s(); i !== -1 && Je._OperatorPriority[n()] >= Je._OperatorPriority[u]; )
          t.push(a());
        r(u), o++;
      } else
        h += l;
      o++;
    }
    for (s(); i !== -1; )
      n() === "(" ? a() : t.push(a());
    return t;
  }
}
Je._OperatorPriority = {
  ")": 0,
  "(": 1,
  "||": 2,
  "&&": 3
};
Je._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
class Hi extends Je {
  constructor(e, t = !1) {
    super(), this.define = e, this.not = t;
  }
  isTrue(e) {
    let t = e[this.define] !== void 0;
    return this.not && (t = !t), t;
  }
}
class sn extends Je {
  isTrue(e) {
    return this.leftOperand.isTrue(e) || this.rightOperand.isTrue(e);
  }
}
class rn extends Je {
  isTrue(e) {
    return this.leftOperand.isTrue(e) && this.rightOperand.isTrue(e);
  }
}
class nn extends Je {
  constructor(e, t, i) {
    super(), this.define = e, this.operand = t, this.testValue = i;
  }
  isTrue(e) {
    let t = e[this.define];
    t === void 0 && (t = this.define);
    let i = !1;
    const s = parseInt(t), r = parseInt(this.testValue);
    switch (this.operand) {
      case ">":
        i = s > r;
        break;
      case "<":
        i = s < r;
        break;
      case "<=":
        i = s <= r;
        break;
      case ">=":
        i = s >= r;
        break;
      case "==":
        i = s === r;
        break;
    }
    return i;
  }
}
var Ke;
(function(c) {
  c[c.GLSL = 0] = "GLSL", c[c.WGSL = 1] = "WGSL";
})(Ke || (Ke = {}));
const an = /defined\s*?\((.+?)\)/g, Ss = /defined\s*?\[(.+?)\]/g, Qs = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
class ni {
  static Initialize(e) {
    e.processor && e.processor.initializeShaders && e.processor.initializeShaders(e.processingContext);
  }
  static Process(e, t, i, s) {
    var r;
    !((r = t.processor) === null || r === void 0) && r.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, (n) => {
      t.processCodeAfterIncludes && (n = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", n));
      const a = this._ProcessShaderConversion(n, t, s);
      i(a, n);
    });
  }
  static PreProcess(e, t, i, s) {
    var r;
    !((r = t.processor) === null || r === void 0) && r.preProcessShaderCode && (e = t.processor.preProcessShaderCode(e, t.isFragment)), this._ProcessIncludes(e, t, (n) => {
      t.processCodeAfterIncludes && (n = t.processCodeAfterIncludes(t.isFragment ? "fragment" : "vertex", n));
      const a = this._ApplyPreProcessing(n, t, s);
      i(a, n);
    });
  }
  static Finalize(e, t, i) {
    return !i.processor || !i.processor.finalizeShaders ? { vertexCode: e, fragmentCode: t } : i.processor.finalizeShaders(e, t, i.processingContext);
  }
  static _ProcessPrecision(e, t) {
    var i;
    if (!((i = t.processor) === null || i === void 0) && i.noPrecision)
      return e;
    const s = t.shouldUseHighPrecisionShader;
    return e.indexOf("precision highp float") === -1 ? s ? e = `precision highp float;
` + e : e = `precision mediump float;
` + e : s || (e = e.replace("precision highp float", "precision mediump float")), e;
  }
  static _ExtractOperation(e) {
    const i = /defined\((.+)\)/.exec(e);
    if (i && i.length)
      return new Hi(i[1].trim(), e[0] === "!");
    const s = ["==", ">=", "<=", "<", ">"];
    let r = "", n = 0;
    for (r of s)
      if (n = e.indexOf(r), n > -1)
        break;
    if (n === -1)
      return new Hi(e);
    const a = e.substring(0, n).trim(), o = e.substring(n + r.length).trim();
    return new nn(a, r, o);
  }
  static _BuildSubExpression(e) {
    e = e.replace(an, "defined[$1]");
    const t = Je.infixToPostfix(e), i = [];
    for (const r of t)
      if (r !== "||" && r !== "&&")
        i.push(r);
      else if (i.length >= 2) {
        let n = i[i.length - 1], a = i[i.length - 2];
        i.length -= 2;
        const o = r == "&&" ? new rn() : new sn();
        typeof n == "string" && (n = n.replace(Ss, "defined($1)")), typeof a == "string" && (a = a.replace(Ss, "defined($1)")), o.leftOperand = typeof a == "string" ? this._ExtractOperation(a) : a, o.rightOperand = typeof n == "string" ? this._ExtractOperation(n) : n, i.push(o);
      }
    let s = i[i.length - 1];
    return typeof s == "string" && (s = s.replace(Ss, "defined($1)")), typeof s == "string" ? this._ExtractOperation(s) : s;
  }
  static _BuildExpression(e, t) {
    const i = new tn(), s = e.substring(0, t);
    let r = e.substring(t);
    return r = r.substring(0, (r.indexOf("//") + 1 || r.length + 1) - 1).trim(), s === "#ifdef" ? i.testExpression = new Hi(r) : s === "#ifndef" ? i.testExpression = new Hi(r, !0) : i.testExpression = this._BuildSubExpression(r), i;
  }
  static _MoveCursorWithinIf(e, t, i) {
    let s = e.currentLine;
    for (; this._MoveCursor(e, i); ) {
      s = e.currentLine;
      const r = s.substring(0, 5).toLowerCase();
      if (r === "#else") {
        const n = new Ci();
        t.children.push(n), this._MoveCursor(e, n);
        return;
      } else if (r === "#elif") {
        const n = this._BuildExpression(s, 5);
        t.children.push(n), i = n;
      }
    }
  }
  static _MoveCursor(e, t) {
    for (; e.canRead; ) {
      e.lineIndex++;
      const i = e.currentLine, r = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/.exec(i);
      if (r && r.length)
        switch (r[0]) {
          case "#ifdef": {
            const a = new bs();
            t.children.push(a);
            const o = this._BuildExpression(i, 6);
            a.children.push(o), this._MoveCursorWithinIf(e, a, o);
            break;
          }
          case "#else":
          case "#elif":
            return !0;
          case "#endif":
            return !1;
          case "#ifndef": {
            const a = new bs();
            t.children.push(a);
            const o = this._BuildExpression(i, 7);
            a.children.push(o), this._MoveCursorWithinIf(e, a, o);
            break;
          }
          case "#if": {
            const a = new bs(), o = this._BuildExpression(i, 3);
            t.children.push(a), a.children.push(o), this._MoveCursorWithinIf(e, a, o);
            break;
          }
        }
      else {
        const n = new Ci();
        if (n.line = i, t.children.push(n), i[0] === "#" && i[1] === "d") {
          const a = i.replace(";", "").split(" ");
          n.additionalDefineKey = a[1], a.length === 3 && (n.additionalDefineValue = a[2]);
        }
      }
    }
    return !1;
  }
  static _EvaluatePreProcessors(e, t, i) {
    const s = new Ci(), r = new en();
    return r.lineIndex = -1, r.lines = e.split(`
`), this._MoveCursor(r, s), s.process(t, i);
  }
  static _PreparePreProcessors(e, t) {
    var i;
    const s = e.defines, r = {};
    for (const n of s) {
      const o = n.replace("#define", "").replace(";", "").trim().split(" ");
      r[o[0]] = o.length > 1 ? o[1] : "";
    }
    return ((i = e.processor) === null || i === void 0 ? void 0 : i.shaderLanguage) === Ke.GLSL && (r.GL_ES = "true"), r.__VERSION__ = e.version, r[e.platformName] = "true", t._getGlobalDefines(r), r;
  }
  static _ProcessShaderConversion(e, t, i) {
    let s = this._ProcessPrecision(e, t);
    if (!t.processor || t.processor.shaderLanguage === Ke.GLSL && s.indexOf("#version 3") !== -1 && (s = s.replace("#version 300 es", ""), !t.processor.parseGLES3))
      return s;
    const r = t.defines, n = this._PreparePreProcessors(t, i);
    return t.processor.preProcessor && (s = t.processor.preProcessor(s, r, t.isFragment, t.processingContext)), s = this._EvaluatePreProcessors(s, n, t), t.processor.postProcessor && (s = t.processor.postProcessor(s, r, t.isFragment, t.processingContext, i)), i._features.needShaderCodeInlining && (s = i.inlineShaderCode(s)), s;
  }
  static _ApplyPreProcessing(e, t, i) {
    var s, r;
    let n = e;
    const a = t.defines, o = this._PreparePreProcessors(t, i);
    return !((s = t.processor) === null || s === void 0) && s.preProcessor && (n = t.processor.preProcessor(n, a, t.isFragment, t.processingContext)), n = this._EvaluatePreProcessors(n, o, t), !((r = t.processor) === null || r === void 0) && r.postProcessor && (n = t.processor.postProcessor(n, a, t.isFragment, t.processingContext, i)), i._features.needShaderCodeInlining && (n = i.inlineShaderCode(n)), n;
  }
  static _ProcessIncludes(e, t, i) {
    let s = Qs.exec(e), r = new String(e), n = !1;
    for (; s != null; ) {
      let a = s[1];
      if (a.indexOf("__decl__") !== -1 && (a = a.replace(/__decl__/, ""), t.supportsUniformBuffers && (a = a.replace(/Vertex/, "Ubo"), a = a.replace(/Fragment/, "Ubo")), a = a + "Declaration"), t.includesShadersStore[a]) {
        let o = t.includesShadersStore[a];
        if (s[2]) {
          const h = s[3].split(",");
          for (let l = 0; l < h.length; l += 2) {
            const u = new RegExp(h[l], "g"), d = h[l + 1];
            o = o.replace(u, d);
          }
        }
        if (s[4]) {
          const h = s[5];
          if (h.indexOf("..") !== -1) {
            const l = h.split(".."), u = parseInt(l[0]);
            let d = parseInt(l[1]), f = o.slice(0);
            o = "", isNaN(d) && (d = t.indexParameters[l[1]]);
            for (let _ = u; _ < d; _++)
              t.supportsUniformBuffers || (f = f.replace(/light\{X\}.(\w*)/g, (E, m) => m + "{X}")), o += f.replace(/\{X\}/g, _.toString()) + `
`;
          } else
            t.supportsUniformBuffers || (o = o.replace(/light\{X\}.(\w*)/g, (l, u) => u + "{X}")), o = o.replace(/\{X\}/g, h);
        }
        r = r.replace(s[0], o), n = n || o.indexOf("#include<") >= 0 || o.indexOf("#include <") >= 0;
      } else {
        const o = t.shadersRepository + "ShadersInclude/" + a + ".fx";
        ni._FileToolsLoadFile(o, (h) => {
          t.includesShadersStore[a] = h, this._ProcessIncludes(r, t, i);
        });
        return;
      }
      s = Qs.exec(e);
    }
    n ? this._ProcessIncludes(r.toString(), t, i) : i(r);
  }
  static _FileToolsLoadFile(e, t, i, s, r, n) {
    throw Q("FileTools");
  }
}
class U {
  static GetShadersRepository(e = Ke.GLSL) {
    return e === Ke.GLSL ? U.ShadersRepository : U.ShadersRepositoryWGSL;
  }
  static GetShadersStore(e = Ke.GLSL) {
    return e === Ke.GLSL ? U.ShadersStore : U.ShadersStoreWGSL;
  }
  static GetIncludesShadersStore(e = Ke.GLSL) {
    return e === Ke.GLSL ? U.IncludesShadersStore : U.IncludesShadersStoreWGSL;
  }
}
U.ShadersRepository = "src/Shaders/";
U.ShadersStore = {};
U.IncludesShadersStore = {};
U.ShadersRepositoryWGSL = "src/ShadersWGSL/";
U.ShadersStoreWGSL = {};
U.IncludesShadersStoreWGSL = {};
class De {
  constructor(e, t, i, s = null, r, n = null, a = null, o = null, h = null, l, u = "", d = Ke.GLSL) {
    var f, _, E;
    this.name = null, this.defines = "", this.onCompiled = null, this.onError = null, this.onBind = null, this.uniqueId = 0, this.onCompileObservable = new w(), this.onErrorObservable = new w(), this._onBindObservable = null, this._wasPreviouslyReady = !1, this._forceRebindOnNextCall = !1, this._wasPreviouslyUsingInstances = null, this._isDisposed = !1, this._bonesComputationForcedToCPU = !1, this._uniformBuffersNames = {}, this._multiTarget = !1, this._samplers = {}, this._isReady = !1, this._compilationError = "", this._allFallbacksProcessed = !1, this._uniforms = {}, this._key = "", this._fallbacks = null, this._vertexSourceCodeOverride = "", this._fragmentSourceCodeOverride = "", this._transformFeedbackVaryings = null, this._pipelineContext = null, this._vertexSourceCode = "", this._fragmentSourceCode = "", this._vertexSourceCodeBeforeMigration = "", this._fragmentSourceCodeBeforeMigration = "", this._rawVertexSourceCode = "", this._rawFragmentSourceCode = "", this.name = e, this._key = u;
    let m, v = null;
    if (t.attributes) {
      const k = t;
      if (this._engine = i, this._attributesNames = k.attributes, this._uniformsNames = k.uniformsNames.concat(k.samplers), this._samplerList = k.samplers.slice(), this.defines = k.defines, this.onError = k.onError, this.onCompiled = k.onCompiled, this._fallbacks = k.fallbacks, this._indexParameters = k.indexParameters, this._transformFeedbackVaryings = k.transformFeedbackVaryings || null, this._multiTarget = !!k.multiTarget, this._shaderLanguage = (f = k.shaderLanguage) !== null && f !== void 0 ? f : Ke.GLSL, k.uniformBuffersNames) {
        this._uniformBuffersNamesList = k.uniformBuffersNames.slice();
        for (let F = 0; F < k.uniformBuffersNames.length; F++)
          this._uniformBuffersNames[k.uniformBuffersNames[F]] = F;
      }
      v = (_ = k.processFinalCode) !== null && _ !== void 0 ? _ : null, m = (E = k.processCodeAfterIncludes) !== null && E !== void 0 ? E : void 0;
    } else
      this._engine = r, this.defines = n == null ? "" : n, this._uniformsNames = i.concat(s), this._samplerList = s ? s.slice() : [], this._attributesNames = t, this._uniformBuffersNamesList = [], this._shaderLanguage = d, this.onError = h, this.onCompiled = o, this._indexParameters = l, this._fallbacks = a;
    this._attributeLocationByName = {}, this.uniqueId = De._UniqueIdSeed++;
    let S, y;
    const A = Ze() ? this._engine.getHostDocument() : null;
    e.vertexSource ? S = "source:" + e.vertexSource : e.vertexElement ? (S = A ? A.getElementById(e.vertexElement) : null, S || (S = e.vertexElement)) : S = e.vertex || e, e.fragmentSource ? y = "source:" + e.fragmentSource : e.fragmentElement ? (y = A ? A.getElementById(e.fragmentElement) : null, y || (y = e.fragmentElement)) : y = e.fragment || e, this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
    let C = {
      defines: this.defines.split(`
`),
      indexParameters: this._indexParameters,
      isFragment: !1,
      shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
      processor: this._engine._getShaderProcessor(this._shaderLanguage),
      supportsUniformBuffers: this._engine.supportsUniformBuffers,
      shadersRepository: U.GetShadersRepository(this._shaderLanguage),
      includesShadersStore: U.GetIncludesShadersStore(this._shaderLanguage),
      version: (this._engine.version * 100).toString(),
      platformName: this._engine.shaderPlatformName,
      processingContext: this._processingContext,
      isNDCHalfZRange: this._engine.isNDCHalfZRange,
      useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
      processCodeAfterIncludes: m
    };
    const b = [void 0, void 0], M = () => {
      if (b[0] && b[1]) {
        C.isFragment = !0;
        const [k, F] = b;
        ni.Process(F, C, (ue, ce) => {
          this._fragmentSourceCodeBeforeMigration = ce, v && (ue = v("fragment", ue));
          const ie = ni.Finalize(k, ue, C);
          C = null, this._useFinalCode(ie.vertexCode, ie.fragmentCode, e);
        }, this._engine);
      }
    };
    this._loadShader(S, "Vertex", "", (k) => {
      ni.Initialize(C), ni.Process(k, C, (F, ue) => {
        this._rawVertexSourceCode = k, this._vertexSourceCodeBeforeMigration = ue, v && (F = v("vertex", F)), b[0] = F, M();
      }, this._engine);
    }), this._loadShader(y, "Fragment", "Pixel", (k) => {
      this._rawFragmentSourceCode = k, b[1] = k, M();
    });
    const L = function(k) {
      return function() {
        return this._pipelineContext && this._pipelineContext[k].apply(this._pipelineContext, arguments), this;
      };
    };
    ["Int?", "UInt?", "IntArray?", "UIntArray?", "Array?", "Color?", "Vector?", "Float?", "Matrices", "Matrix", "Matrix3x3", "Matrix2x2", "Quaternion", "DirectColor4"].forEach((k) => {
      const F = `set${k}`;
      F.endsWith("?") ? ["", 2, 3, 4].forEach((ue) => {
        this[F.slice(0, -1) + ue] = this[F.slice(0, -1) + ue] || L(F.slice(0, -1) + ue).bind(this);
      }) : this[F] = this[F] || L(F).bind(this);
    });
  }
  static get ShadersRepository() {
    return U.ShadersRepository;
  }
  static set ShadersRepository(e) {
    U.ShadersRepository = e;
  }
  get onBindObservable() {
    return this._onBindObservable || (this._onBindObservable = new w()), this._onBindObservable;
  }
  _useFinalCode(e, t, i) {
    if (i) {
      const s = i.vertexElement || i.vertex || i.spectorName || i, r = i.fragmentElement || i.fragment || i.spectorName || i;
      this._vertexSourceCode = (this._shaderLanguage === Ke.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + s + `
` + e, this._fragmentSourceCode = (this._shaderLanguage === Ke.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + r + `
` + t;
    } else
      this._vertexSourceCode = e, this._fragmentSourceCode = t;
    this._prepareEffect();
  }
  get key() {
    return this._key;
  }
  isReady() {
    try {
      return this._isReadyInternal();
    } catch {
      return !1;
    }
  }
  _isReadyInternal() {
    return this._isReady ? !0 : this._pipelineContext ? this._pipelineContext.isReady : !1;
  }
  getEngine() {
    return this._engine;
  }
  getPipelineContext() {
    return this._pipelineContext;
  }
  getAttributesNames() {
    return this._attributesNames;
  }
  getAttributeLocation(e) {
    return this._attributes[e];
  }
  getAttributeLocationByName(e) {
    return this._attributeLocationByName[e];
  }
  getAttributesCount() {
    return this._attributes.length;
  }
  getUniformIndex(e) {
    return this._uniformsNames.indexOf(e);
  }
  getUniform(e) {
    return this._uniforms[e];
  }
  getSamplers() {
    return this._samplerList;
  }
  getUniformNames() {
    return this._uniformsNames;
  }
  getUniformBuffersNames() {
    return this._uniformBuffersNamesList;
  }
  getIndexParameters() {
    return this._indexParameters;
  }
  getCompilationError() {
    return this._compilationError;
  }
  allFallbacksProcessed() {
    return this._allFallbacksProcessed;
  }
  executeWhenCompiled(e) {
    if (this.isReady()) {
      e(this);
      return;
    }
    this.onCompileObservable.add((t) => {
      e(t);
    }), (!this._pipelineContext || this._pipelineContext.isAsync) && setTimeout(() => {
      this._checkIsReady(null);
    }, 16);
  }
  _checkIsReady(e) {
    try {
      if (this._isReadyInternal())
        return;
    } catch (t) {
      this._processCompilationErrors(t, e);
      return;
    }
    this._isDisposed || setTimeout(() => {
      this._checkIsReady(e);
    }, 16);
  }
  _loadShader(e, t, i, s) {
    if (typeof HTMLElement < "u" && e instanceof HTMLElement) {
      const a = Bs(e);
      s(a);
      return;
    }
    if (e.substr(0, 7) === "source:") {
      s(e.substr(7));
      return;
    }
    if (e.substr(0, 7) === "base64:") {
      const a = window.atob(e.substr(7));
      s(a);
      return;
    }
    const r = U.GetShadersStore(this._shaderLanguage);
    if (r[e + t + "Shader"]) {
      s(r[e + t + "Shader"]);
      return;
    }
    if (i && r[e + i + "Shader"]) {
      s(r[e + i + "Shader"]);
      return;
    }
    let n;
    e[0] === "." || e[0] === "/" || e.indexOf("http") > -1 ? n = e : n = U.GetShadersRepository(this._shaderLanguage) + e, this._engine._loadFile(n + "." + t.toLowerCase() + ".fx", s);
  }
  get vertexSourceCode() {
    var e, t;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (t = (e = this._pipelineContext) === null || e === void 0 ? void 0 : e._getVertexShaderCode()) !== null && t !== void 0 ? t : this._vertexSourceCode;
  }
  get fragmentSourceCode() {
    var e, t;
    return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (t = (e = this._pipelineContext) === null || e === void 0 ? void 0 : e._getFragmentShaderCode()) !== null && t !== void 0 ? t : this._fragmentSourceCode;
  }
  get vertexSourceCodeBeforeMigration() {
    return this._vertexSourceCodeBeforeMigration;
  }
  get fragmentSourceCodeBeforeMigration() {
    return this._fragmentSourceCodeBeforeMigration;
  }
  get rawVertexSourceCode() {
    return this._rawVertexSourceCode;
  }
  get rawFragmentSourceCode() {
    return this._rawFragmentSourceCode;
  }
  _rebuildProgram(e, t, i, s) {
    this._isReady = !1, this._vertexSourceCodeOverride = e, this._fragmentSourceCodeOverride = t, this.onError = (r, n) => {
      s && s(n);
    }, this.onCompiled = () => {
      const r = this.getEngine().scenes;
      if (r)
        for (let n = 0; n < r.length; n++)
          r[n].markAllMaterialsAsDirty(63);
      this._pipelineContext._handlesSpectorRebuildCallback(i);
    }, this._fallbacks = null, this._prepareEffect();
  }
  _prepareEffect() {
    const e = this._attributesNames, t = this.defines, i = this._pipelineContext;
    this._isReady = !1;
    try {
      const s = this._engine;
      this._pipelineContext = s.createPipelineContext(this._processingContext), this._pipelineContext._name = this._key;
      const r = this._rebuildProgram.bind(this);
      this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? s._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, !0, this._rawVertexSourceCode, this._rawFragmentSourceCode, r, null, this._transformFeedbackVaryings, this._key) : s._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, !1, this._rawVertexSourceCode, this._rawFragmentSourceCode, r, t, this._transformFeedbackVaryings, this._key), s._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {
        if (this._attributes = [], this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, e, this._attributes), e)
          for (let n = 0; n < e.length; n++) {
            const a = e[n];
            this._attributeLocationByName[a] = this._attributes[n];
          }
        s.bindSamplers(this), this._compilationError = "", this._isReady = !0, this.onCompiled && this.onCompiled(this), this.onCompileObservable.notifyObservers(this), this.onCompileObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh(), i && this.getEngine()._deletePipelineContext(i);
      }), this._pipelineContext.isAsync && this._checkIsReady(i);
    } catch (s) {
      this._processCompilationErrors(s, i);
    }
  }
  _getShaderCodeAndErrorLine(e, t, i) {
    const s = i ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
    let r = null;
    if (t && e) {
      const n = t.match(s);
      if (n && n.length === 2) {
        const a = parseInt(n[1]), o = e.split(`
`, -1);
        o.length >= a && (r = `Offending line [${a}] in ${i ? "fragment" : "vertex"} code: ${o[a - 1]}`);
      }
    }
    return [e, r];
  }
  _processCompilationErrors(e, t = null) {
    var i, s, r;
    this._compilationError = e.message;
    const n = this._attributesNames, a = this._fallbacks;
    if (O.Error("Unable to compile effect:"), O.Error("Uniforms: " + this._uniformsNames.map(function(h) {
      return " " + h;
    })), O.Error("Attributes: " + n.map(function(h) {
      return " " + h;
    })), O.Error(`Defines:\r
` + this.defines), De.LogShaderCodeOnCompilationError) {
      let h = null, l = null, u = null;
      !((i = this._pipelineContext) === null || i === void 0) && i._getVertexShaderCode() && ([u, h] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, !1), u && (O.Error("Vertex code:"), O.Error(u))), !((s = this._pipelineContext) === null || s === void 0) && s._getFragmentShaderCode() && ([u, l] = this._getShaderCodeAndErrorLine((r = this._pipelineContext) === null || r === void 0 ? void 0 : r._getFragmentShaderCode(), this._compilationError, !0), u && (O.Error("Fragment code:"), O.Error(u))), h && O.Error(h), l && O.Error(l);
    }
    O.Error("Error: " + this._compilationError);
    const o = () => {
      this.onError && this.onError(this, this._compilationError), this.onErrorObservable.notifyObservers(this);
    };
    t && (this._pipelineContext = t, this._isReady = !0, o()), a ? (this._pipelineContext = null, a.hasMoreFallbacks ? (this._allFallbacksProcessed = !1, O.Error("Trying next fallback."), this.defines = a.reduce(this.defines, this), this._prepareEffect()) : (this._allFallbacksProcessed = !0, o(), this.onErrorObservable.clear(), this._fallbacks && this._fallbacks.unBindMesh())) : (this._allFallbacksProcessed = !0, t || o());
  }
  get isSupported() {
    return this._compilationError === "";
  }
  _bindTexture(e, t) {
    this._engine._bindTexture(this._samplers[e], t, e);
  }
  setTexture(e, t) {
    this._engine.setTexture(this._samplers[e], this._uniforms[e], t, e);
  }
  setDepthStencilTexture(e, t) {
    this._engine.setDepthStencilTexture(this._samplers[e], this._uniforms[e], t, e);
  }
  setTextureArray(e, t) {
    const i = e + "Ex";
    if (this._samplerList.indexOf(i + "0") === -1) {
      const s = this._samplerList.indexOf(e);
      for (let n = 1; n < t.length; n++) {
        const a = i + (n - 1).toString();
        this._samplerList.splice(s + n, 0, a);
      }
      let r = 0;
      for (const n of this._samplerList)
        this._samplers[n] = r, r += 1;
    }
    this._engine.setTextureArray(this._samplers[e], this._uniforms[e], t, e);
  }
  setTextureFromPostProcess(e, t) {
    this._engine.setTextureFromPostProcess(this._samplers[e], t, e);
  }
  setTextureFromPostProcessOutput(e, t) {
    this._engine.setTextureFromPostProcessOutput(this._samplers[e], t, e);
  }
  bindUniformBuffer(e, t) {
    const i = this._uniformBuffersNames[t];
    i === void 0 || De._BaseCache[i] === e && this._engine._features.useUBOBindingCache || (De._BaseCache[i] = e, this._engine.bindUniformBufferBase(e, i, t));
  }
  bindUniformBlock(e, t) {
    this._engine.bindUniformBlock(this._pipelineContext, e, t);
  }
  setFloatArray(e, t) {
    return this._pipelineContext.setArray(e, t), this;
  }
  setFloatArray2(e, t) {
    return this._pipelineContext.setArray2(e, t), this;
  }
  setFloatArray3(e, t) {
    return this._pipelineContext.setArray3(e, t), this;
  }
  setFloatArray4(e, t) {
    return this._pipelineContext.setArray4(e, t), this;
  }
  setBool(e, t) {
    return this._pipelineContext.setInt(e, t ? 1 : 0), this;
  }
  dispose() {
    var e;
    (e = this._pipelineContext) === null || e === void 0 || e.dispose(), this._engine._releaseEffect(this), this._isDisposed = !0;
  }
  static RegisterShader(e, t, i, s = Ke.GLSL) {
    t && (U.GetShadersStore(s)[`${e}PixelShader`] = t), i && (U.GetShadersStore(s)[`${e}VertexShader`] = i);
  }
  static ResetCache() {
    De._BaseCache = {};
  }
}
De.LogShaderCodeOnCompilationError = !0;
De._UniqueIdSeed = 0;
De._BaseCache = {};
De.ShadersStore = U.ShadersStore;
De.IncludesShadersStore = U.IncludesShadersStore;
class on {
  constructor(e = !0) {
    this._isDepthTestDirty = !1, this._isDepthMaskDirty = !1, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !1, this._isFrontFaceDirty = !1, e && this.reset();
  }
  get isDirty() {
    return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
  }
  get zOffset() {
    return this._zOffset;
  }
  set zOffset(e) {
    this._zOffset !== e && (this._zOffset = e, this._isZOffsetDirty = !0);
  }
  get zOffsetUnits() {
    return this._zOffsetUnits;
  }
  set zOffsetUnits(e) {
    this._zOffsetUnits !== e && (this._zOffsetUnits = e, this._isZOffsetDirty = !0);
  }
  get cullFace() {
    return this._cullFace;
  }
  set cullFace(e) {
    this._cullFace !== e && (this._cullFace = e, this._isCullFaceDirty = !0);
  }
  get cull() {
    return this._cull;
  }
  set cull(e) {
    this._cull !== e && (this._cull = e, this._isCullDirty = !0);
  }
  get depthFunc() {
    return this._depthFunc;
  }
  set depthFunc(e) {
    this._depthFunc !== e && (this._depthFunc = e, this._isDepthFuncDirty = !0);
  }
  get depthMask() {
    return this._depthMask;
  }
  set depthMask(e) {
    this._depthMask !== e && (this._depthMask = e, this._isDepthMaskDirty = !0);
  }
  get depthTest() {
    return this._depthTest;
  }
  set depthTest(e) {
    this._depthTest !== e && (this._depthTest = e, this._isDepthTestDirty = !0);
  }
  get frontFace() {
    return this._frontFace;
  }
  set frontFace(e) {
    this._frontFace !== e && (this._frontFace = e, this._isFrontFaceDirty = !0);
  }
  reset() {
    this._depthMask = !0, this._depthTest = !0, this._depthFunc = null, this._cullFace = null, this._cull = null, this._zOffset = 0, this._zOffsetUnits = 0, this._frontFace = null, this._isDepthTestDirty = !0, this._isDepthMaskDirty = !0, this._isDepthFuncDirty = !1, this._isCullFaceDirty = !1, this._isCullDirty = !1, this._isZOffsetDirty = !0, this._isFrontFaceDirty = !1;
  }
  apply(e) {
    !this.isDirty || (this._isCullDirty && (this.cull ? e.enable(e.CULL_FACE) : e.disable(e.CULL_FACE), this._isCullDirty = !1), this._isCullFaceDirty && (e.cullFace(this.cullFace), this._isCullFaceDirty = !1), this._isDepthMaskDirty && (e.depthMask(this.depthMask), this._isDepthMaskDirty = !1), this._isDepthTestDirty && (this.depthTest ? e.enable(e.DEPTH_TEST) : e.disable(e.DEPTH_TEST), this._isDepthTestDirty = !1), this._isDepthFuncDirty && (e.depthFunc(this.depthFunc), this._isDepthFuncDirty = !1), this._isZOffsetDirty && (this.zOffset || this.zOffsetUnits ? (e.enable(e.POLYGON_OFFSET_FILL), e.polygonOffset(this.zOffset, this.zOffsetUnits)) : e.disable(e.POLYGON_OFFSET_FILL), this._isZOffsetDirty = !1), this._isFrontFaceDirty && (e.frontFace(this.frontFace), this._isFrontFaceDirty = !1));
  }
}
class kt {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = !1, this.mask = 255, this.func = kt.ALWAYS, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = kt.KEEP, this.opDepthFail = kt.KEEP, this.opStencilDepthPass = kt.REPLACE;
  }
  get stencilFunc() {
    return this.func;
  }
  set stencilFunc(e) {
    this.func = e;
  }
  get stencilFuncRef() {
    return this.funcRef;
  }
  set stencilFuncRef(e) {
    this.funcRef = e;
  }
  get stencilFuncMask() {
    return this.funcMask;
  }
  set stencilFuncMask(e) {
    this.funcMask = e;
  }
  get stencilOpStencilFail() {
    return this.opStencilFail;
  }
  set stencilOpStencilFail(e) {
    this.opStencilFail = e;
  }
  get stencilOpDepthFail() {
    return this.opDepthFail;
  }
  set stencilOpDepthFail(e) {
    this.opDepthFail = e;
  }
  get stencilOpStencilDepthPass() {
    return this.opStencilDepthPass;
  }
  set stencilOpStencilDepthPass(e) {
    this.opStencilDepthPass = e;
  }
  get stencilMask() {
    return this.mask;
  }
  set stencilMask(e) {
    this.mask = e;
  }
  get stencilTest() {
    return this.enabled;
  }
  set stencilTest(e) {
    this.enabled = e;
  }
}
kt.ALWAYS = 519;
kt.KEEP = 7680;
kt.REPLACE = 7681;
class hn {
  constructor() {
    this._blendFunctionParameters = new Array(4), this._blendEquationParameters = new Array(2), this._blendConstants = new Array(4), this._isBlendConstantsDirty = !1, this._alphaBlend = !1, this._isAlphaBlendDirty = !1, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this.reset();
  }
  get isDirty() {
    return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
  }
  get alphaBlend() {
    return this._alphaBlend;
  }
  set alphaBlend(e) {
    this._alphaBlend !== e && (this._alphaBlend = e, this._isAlphaBlendDirty = !0);
  }
  setAlphaBlendConstants(e, t, i, s) {
    this._blendConstants[0] === e && this._blendConstants[1] === t && this._blendConstants[2] === i && this._blendConstants[3] === s || (this._blendConstants[0] = e, this._blendConstants[1] = t, this._blendConstants[2] = i, this._blendConstants[3] = s, this._isBlendConstantsDirty = !0);
  }
  setAlphaBlendFunctionParameters(e, t, i, s) {
    this._blendFunctionParameters[0] === e && this._blendFunctionParameters[1] === t && this._blendFunctionParameters[2] === i && this._blendFunctionParameters[3] === s || (this._blendFunctionParameters[0] = e, this._blendFunctionParameters[1] = t, this._blendFunctionParameters[2] = i, this._blendFunctionParameters[3] = s, this._isBlendFunctionParametersDirty = !0);
  }
  setAlphaEquationParameters(e, t) {
    this._blendEquationParameters[0] === e && this._blendEquationParameters[1] === t || (this._blendEquationParameters[0] = e, this._blendEquationParameters[1] = t, this._isBlendEquationParametersDirty = !0);
  }
  reset() {
    this._alphaBlend = !1, this._blendFunctionParameters[0] = null, this._blendFunctionParameters[1] = null, this._blendFunctionParameters[2] = null, this._blendFunctionParameters[3] = null, this._blendEquationParameters[0] = null, this._blendEquationParameters[1] = null, this._blendConstants[0] = null, this._blendConstants[1] = null, this._blendConstants[2] = null, this._blendConstants[3] = null, this._isAlphaBlendDirty = !0, this._isBlendFunctionParametersDirty = !1, this._isBlendEquationParametersDirty = !1, this._isBlendConstantsDirty = !1;
  }
  apply(e) {
    !this.isDirty || (this._isAlphaBlendDirty && (this._alphaBlend ? e.enable(e.BLEND) : e.disable(e.BLEND), this._isAlphaBlendDirty = !1), this._isBlendFunctionParametersDirty && (e.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]), this._isBlendFunctionParametersDirty = !1), this._isBlendEquationParametersDirty && (e.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]), this._isBlendEquationParametersDirty = !1), this._isBlendConstantsDirty && (e.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]), this._isBlendConstantsDirty = !1));
  }
}
class ln {
  constructor() {
    this.shaderLanguage = Ke.GLSL;
  }
  postProcessor(e, t, i, s, r) {
    if (!r.getCaps().drawBuffersExtension) {
      const n = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
      e = e.replace(n, "");
    }
    return e;
  }
}
class cn {
  constructor() {
    this.shaderLanguage = Ke.GLSL;
  }
  attributeProcessor(e) {
    return e.replace("attribute", "in");
  }
  varyingProcessor(e, t) {
    return e.replace("varying", t ? "in" : "out");
  }
  postProcessor(e, t, i) {
    const s = e.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1, r = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
    if (e = e.replace(r, ""), e = e.replace(/texture2D\s*\(/g, "texture("), i)
      e = e.replace(/texture2DLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCubeLodEXT\s*\(/g, "textureLod("), e = e.replace(/textureCube\s*\(/g, "texture("), e = e.replace(/gl_FragDepthEXT/g, "gl_FragDepth"), e = e.replace(/gl_FragColor/g, "glFragColor"), e = e.replace(/gl_FragData/g, "glFragData"), e = e.replace(/void\s+?main\s*\(/g, (s ? "" : `layout(location = 0) out vec4 glFragColor;
`) + "void main(");
    else if (t.indexOf("#define MULTIVIEW") !== -1)
      return `#extension GL_OVR_multiview2 : require
layout (num_views = 2) in;
` + e;
    return e;
  }
}
class ki {
  constructor() {
    this.references = 0, this.capacity = 0, this.is32Bits = !1, this.uniqueId = ki._Counter++;
  }
  get underlyingResource() {
    return null;
  }
}
ki._Counter = 0;
class Fi extends ki {
  constructor(e) {
    super(), this._buffer = e;
  }
  get underlyingResource() {
    return this._buffer;
  }
}
const un = [
  "Int",
  "Int2",
  "Int3",
  "Int4",
  "UInt",
  "UInt2",
  "UInt3",
  "UInt4",
  "Vector2",
  "Vector3",
  "Vector4",
  "Float2",
  "Float",
  "Float3",
  "Float4",
  "Quaternion",
  "Color3",
  "Color4",
  "DirectColor4"
];
class dn {
  constructor() {
    this._valueCache = {}, this.vertexCompilationError = null, this.fragmentCompilationError = null, this.programLinkError = null, this.programValidationError = null;
    const e = [], t = function() {
      e.length = 0, Array.prototype.push.apply(e, arguments), e[0] = this._uniforms[e[0]];
    }, i = (s) => {
      const r = un.includes(s.substring(3)) && "FloatN";
      if (r) {
        const n = this[`_cache${r}`];
        return function() {
          const a = this.engine[s];
          t.apply(this, arguments), n.apply(this, arguments) && (a.apply(this.engine, e) || (this._valueCache[arguments[0]] = null));
        };
      } else
        return function() {
          const n = this.engine[s];
          t.apply(this, arguments), arguments[1] !== void 0 && (this._valueCache[arguments[0]] = null, n.apply(this.engine, e));
        };
    };
    ["Int?", "UInt?", "IntArray?", "UIntArray?", "Array?", "Float?", "Matrices", "Matrix3x3", "Matrix2x2"].forEach((s) => {
      const r = `set${s}`;
      this[r] || (r.endsWith("?") ? ["", 2, 3, 4].forEach((n) => {
        this[r.slice(0, -1) + n] = this[r.slice(0, -1) + n] || i(r.slice(0, -1) + n).bind(this);
      }) : this[r] = this[r] || i(r).bind(this));
    });
  }
  get isAsync() {
    return this.isParallelCompiled;
  }
  get isReady() {
    return this.program ? this.isParallelCompiled ? this.engine._isRenderingStateCompiled(this) : !0 : !1;
  }
  _handlesSpectorRebuildCallback(e) {
    e && this.program && e(this.program);
  }
  _fillEffectInformation(e, t, i, s, r, n, a, o) {
    const h = this.engine;
    if (h.supportsUniformBuffers)
      for (const d in t)
        e.bindUniformBlock(d, t[d]);
    this.engine.getUniforms(this, i).forEach((d, f) => {
      s[i[f]] = d;
    }), this._uniforms = s;
    let u;
    for (u = 0; u < r.length; u++)
      e.getUniform(r[u]) == null && (r.splice(u, 1), u--);
    r.forEach((d, f) => {
      n[d] = f;
    });
    for (const d of h.getAttributes(this, a))
      o.push(d);
  }
  dispose() {
    this._uniforms = {};
  }
  _cacheMatrix(e, t) {
    const i = this._valueCache[e], s = t.updateFlag;
    return i !== void 0 && i === s ? !1 : (this._valueCache[e] = s, !0);
  }
  _cacheFloatN(e, t, i, s, r) {
    let n = this._valueCache[arguments[0]];
    if (!n || n.length !== arguments.length - 1)
      return n = Array.prototype.slice.call(arguments, 1), this._valueCache[arguments[0]] = n, !0;
    let a = !1;
    for (let o = 0; o < n.length; ++o)
      n[o] !== arguments[o + 1] && (n[o] = arguments[o + 1], a = !0);
    return a;
  }
  _cacheFloat2(e, t, i) {
    return this._cacheFloatN(e, t, i);
  }
  _cacheFloat3(e, t, i, s) {
    return this._cacheFloatN(e, t, i, s);
  }
  _cacheFloat4(e, t, i, s, r) {
    return this._cacheFloatN(e, t, i, s, r);
  }
  setMatrix(e, t) {
    this._cacheMatrix(e, t) && (this.engine.setMatrices(this._uniforms[e], t.toArray()) || (this._valueCache[e] = null));
  }
  setVector2(e, t) {
    this.setFloat2(e, t.x, t.y);
  }
  setVector3(e, t) {
    this.setFloat3(e, t.x, t.y, t.z);
  }
  setVector4(e, t) {
    this.setFloat4(e, t.x, t.y, t.z, t.w);
  }
  setQuaternion(e, t) {
    this.setFloat4(e, t.x, t.y, t.z, t.w);
  }
  setColor3(e, t) {
    this.setFloat3(e, t.r, t.g, t.b);
  }
  setColor4(e, t, i) {
    this.setFloat4(e, t.r, t.g, t.b, i);
  }
  setDirectColor4(e, t) {
    this.setFloat4(e, t.r, t.g, t.b, t.a);
  }
  _getVertexShaderCode() {
    return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
  }
  _getFragmentShaderCode() {
    return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
  }
}
class Mr {
  constructor(e = null, t) {
    if (this._MSAARenderBuffer = null, this._context = t, !e && (e = t.createTexture(), !e))
      throw new Error("Unable to create webGL texture");
    this.set(e);
  }
  get underlyingResource() {
    return this._webGLTexture;
  }
  setUsage() {
  }
  set(e) {
    this._webGLTexture = e;
  }
  reset() {
    this._webGLTexture = null, this._MSAARenderBuffer = null;
  }
  release() {
    this._MSAARenderBuffer && (this._context.deleteRenderbuffer(this._MSAARenderBuffer), this._MSAARenderBuffer = null), this._webGLTexture && this._context.deleteTexture(this._webGLTexture), this.reset();
  }
}
class Ri {
  constructor(e, t = !0) {
    this.effect = null, this.defines = null, this.drawContext = e.createDrawContext(), t && (this.materialContext = e.createMaterialContext());
  }
  static IsWrapper(e) {
    return e.getPipelineContext === void 0;
  }
  static GetEffect(e) {
    return e.getPipelineContext === void 0 ? e.effect : e;
  }
  setEffect(e, t, i = !0) {
    var s;
    this.effect = e, t !== void 0 && (this.defines = t), i && ((s = this.drawContext) === null || s === void 0 || s.reset());
  }
  dispose() {
    var e;
    (e = this.drawContext) === null || e === void 0 || e.dispose();
  }
}
class fn {
  constructor(e = !0) {
    this._isStencilTestDirty = !1, this._isStencilMaskDirty = !1, this._isStencilFuncDirty = !1, this._isStencilOpDirty = !1, this.useStencilGlobalOnly = !1, e && this.reset();
  }
  get isDirty() {
    return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
  }
  get func() {
    return this._func;
  }
  set func(e) {
    this._func !== e && (this._func = e, this._isStencilFuncDirty = !0);
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(e) {
    this._funcRef !== e && (this._funcRef = e, this._isStencilFuncDirty = !0);
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(e) {
    this._funcMask !== e && (this._funcMask = e, this._isStencilFuncDirty = !0);
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(e) {
    this._opStencilFail !== e && (this._opStencilFail = e, this._isStencilOpDirty = !0);
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(e) {
    this._opDepthFail !== e && (this._opDepthFail = e, this._isStencilOpDirty = !0);
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(e) {
    this._opStencilDepthPass !== e && (this._opStencilDepthPass = e, this._isStencilOpDirty = !0);
  }
  get mask() {
    return this._mask;
  }
  set mask(e) {
    this._mask !== e && (this._mask = e, this._isStencilMaskDirty = !0);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e && (this._enabled = e, this._isStencilTestDirty = !0);
  }
  reset() {
    var e;
    this.stencilMaterial = void 0, (e = this.stencilGlobal) === null || e === void 0 || e.reset(), this._isStencilTestDirty = !0, this._isStencilMaskDirty = !0, this._isStencilFuncDirty = !0, this._isStencilOpDirty = !0;
  }
  apply(e) {
    var t;
    if (!e)
      return;
    const i = !this.useStencilGlobalOnly && !!(!((t = this.stencilMaterial) === null || t === void 0) && t.enabled);
    this.enabled = i ? this.stencilMaterial.enabled : this.stencilGlobal.enabled, this.func = i ? this.stencilMaterial.func : this.stencilGlobal.func, this.funcRef = i ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef, this.funcMask = i ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask, this.opStencilFail = i ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail, this.opDepthFail = i ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail, this.opStencilDepthPass = i ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass, this.mask = i ? this.stencilMaterial.mask : this.stencilGlobal.mask, this.isDirty && (this._isStencilTestDirty && (this.enabled ? e.enable(e.STENCIL_TEST) : e.disable(e.STENCIL_TEST), this._isStencilTestDirty = !1), this._isStencilMaskDirty && (e.stencilMask(this.mask), this._isStencilMaskDirty = !1), this._isStencilFuncDirty && (e.stencilFunc(this.func, this.funcRef, this.funcMask), this._isStencilFuncDirty = !1), this._isStencilOpDirty && (e.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass), this._isStencilOpDirty = !1));
  }
}
class ai {
  static get Now() {
    return Fs.IsWindowObjectExist() && window.performance && window.performance.now ? window.performance.now() : Date.now();
  }
}
class _n {
}
class le {
  constructor(e, t, i, s) {
    this._name = "WebGL", this.forcePOTTextures = !1, this.isFullscreen = !1, this.cullBackFaces = null, this.renderEvenInBackground = !0, this.preventCacheWipeBetweenFrames = !1, this.validateShaderPrograms = !1, this._useReverseDepthBuffer = !1, this.isNDCHalfZRange = !1, this.hasOriginBottomLeft = !0, this.disableUniformBuffers = !1, this.onDisposeObservable = new w(), this._frameId = 0, this._uniformBuffers = new Array(), this._storageBuffers = new Array(), this._webGLVersion = 1, this._windowIsBackground = !1, this._highPrecisionShadersAllowed = !0, this._badOS = !1, this._badDesktopOS = !1, this._renderingQueueLaunched = !1, this._activeRenderLoops = new Array(), this.onContextLostObservable = new w(), this.onContextRestoredObservable = new w(), this._contextWasLost = !1, this._doNotHandleContextLost = !1, this.disableVertexArrayObjects = !1, this._colorWrite = !0, this._colorWriteChanged = !0, this._depthCullingState = new on(), this._stencilStateComposer = new fn(), this._stencilState = new kt(), this._alphaState = new hn(), this._alphaMode = 1, this._alphaEquation = 0, this._internalTexturesCache = new Array(), this._renderTargetWrapperCache = new Array(), this._activeChannel = 0, this._currentTextureChannel = -1, this._boundTexturesCache = {}, this._compiledEffects = {}, this._vertexAttribArraysEnabled = [], this._uintIndicesCurrentlySet = !1, this._currentBoundBuffer = new Array(), this._currentFramebuffer = null, this._dummyFramebuffer = null, this._currentBufferPointers = new Array(), this._currentInstanceLocations = new Array(), this._currentInstanceBuffers = new Array(), this._vaoRecordInProgress = !1, this._mustWipeVertexAttributes = !1, this._nextFreeTextureSlots = new Array(), this._maxSimultaneousTextures = 0, this._maxMSAASamplesOverride = null, this._activeRequests = new Array(), this.adaptToDeviceRatio = !1, this._lastDevicePixelRatio = 1, this._transformTextureUrl = null, this.hostInformation = {
      isMobile: !1
    }, this.premultipliedAlpha = !0, this.onBeforeTextureInitObservable = new w(), this._isWebGPU = !1, this._snapshotRenderingMode = 0, this._useExactSrgbConversions = !1, this._viewportCached = { x: 0, y: 0, z: 0, w: 0 }, this._unpackFlipYCached = null, this.enableUnpackFlipYCached = !0, this._boundUniforms = {}, this.startTime = ai.Now;
    let r = null;
    if (i = i || {}, this._creationOptions = i, this.adaptToDeviceRatio = s != null ? s : !1, this._stencilStateComposer.stencilGlobal = this._stencilState, Ne.SetMatrixPrecision(!!i.useHighPrecisionMatrix), !e)
      return;
    if (s = s || i.adaptToDeviceRatio || !1, e.getContext) {
      if (r = e, this._renderingCanvas = r, t !== void 0 && (i.antialias = t), i.deterministicLockstep === void 0 && (i.deterministicLockstep = !1), i.lockstepMaxSteps === void 0 && (i.lockstepMaxSteps = 4), i.timeStep === void 0 && (i.timeStep = 1 / 60), i.preserveDrawingBuffer === void 0 && (i.preserveDrawingBuffer = !1), i.audioEngine === void 0 && (i.audioEngine = !0), i.audioEngineOptions !== void 0 && i.audioEngineOptions.audioContext !== void 0 && (this._audioContext = i.audioEngineOptions.audioContext), i.audioEngineOptions !== void 0 && i.audioEngineOptions.audioDestination !== void 0 && (this._audioDestination = i.audioEngineOptions.audioDestination), i.stencil === void 0 && (i.stencil = !0), i.premultipliedAlpha === !1 && (this.premultipliedAlpha = !1), i.xrCompatible === void 0 && (i.xrCompatible = !0), i.useExactSrgbConversions !== void 0 && (this._useExactSrgbConversions = i.useExactSrgbConversions), this._doNotHandleContextLost = !!i.doNotHandleContextLost, navigator && navigator.userAgent) {
        this._checkForMobile = () => {
          const l = navigator.userAgent;
          this.hostInformation.isMobile = l.indexOf("Mobile") !== -1 || l.indexOf("Mac") !== -1 && Di() && "ontouchend" in document;
        }, this._checkForMobile(), Ze() && window.addEventListener("resize", this._checkForMobile);
        const h = navigator.userAgent;
        for (const l of le.ExceptionList) {
          const u = l.key, d = l.targets;
          if (new RegExp(u).test(h)) {
            if (l.capture && l.captureConstraint) {
              const _ = l.capture, E = l.captureConstraint, v = new RegExp(_).exec(h);
              if (v && v.length > 0 && parseInt(v[v.length - 1]) >= E)
                continue;
            }
            for (const _ of d)
              switch (_) {
                case "uniformBuffer":
                  this.disableUniformBuffers = !0;
                  break;
                case "vao":
                  this.disableVertexArrayObjects = !0;
                  break;
                case "antialias":
                  i.antialias = !1;
                  break;
                case "maxMSAASamples":
                  this._maxMSAASamplesOverride = 1;
                  break;
              }
          }
        }
      }
      if (this._doNotHandleContextLost || (this._onContextLost = (h) => {
        h.preventDefault(), this._contextWasLost = !0, O.Warn("WebGL context lost."), this.onContextLostObservable.notifyObservers(this);
      }, this._onContextRestored = () => {
        this._restoreEngineAfterContextLost(this._initGLContext.bind(this));
      }, r.addEventListener("webglcontextlost", this._onContextLost, !1), r.addEventListener("webglcontextrestored", this._onContextRestored, !1), i.powerPreference = "high-performance"), this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), this._badDesktopOS && (i.xrCompatible = !1), !i.disableWebGL2Support)
        try {
          this._gl = r.getContext("webgl2", i) || r.getContext("experimental-webgl2", i), this._gl && (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2", this._gl.deleteQuery || (this._webGLVersion = 1, this._shaderPlatformName = "WEBGL1"));
        } catch {
        }
      if (!this._gl) {
        if (!r)
          throw new Error("The provided canvas is null or undefined.");
        try {
          this._gl = r.getContext("webgl", i) || r.getContext("experimental-webgl", i);
        } catch {
          throw new Error("WebGL not supported");
        }
      }
      if (!this._gl)
        throw new Error("WebGL not supported");
    } else {
      this._gl = e, this._renderingCanvas = this._gl.canvas, this._gl.renderbufferStorageMultisample ? (this._webGLVersion = 2, this._shaderPlatformName = "WEBGL2") : this._shaderPlatformName = "WEBGL1";
      const h = this._gl.getContextAttributes();
      h && (i.stencil = h.stencil);
    }
    this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), i.useHighPrecisionFloats !== void 0 && (this._highPrecisionShadersAllowed = i.useHighPrecisionFloats);
    const n = Ze() && window.devicePixelRatio || 1, a = i.limitDeviceRatio || n;
    this._hardwareScalingLevel = s ? 1 / Math.min(a, n) : 1, this._lastDevicePixelRatio = n, this.resize(), this._isStencilEnable = !!i.stencil, this._initGLContext(), this._initFeatures();
    for (let h = 0; h < this._caps.maxVertexAttribs; h++)
      this._currentBufferPointers[h] = new _n();
    this._shaderProcessor = this.webGLVersion > 1 ? new cn() : new ln(), this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
    const o = `Babylon.js v${le.Version}`;
    console.log(o + ` - ${this.description}`), this._renderingCanvas && this._renderingCanvas.setAttribute && this._renderingCanvas.setAttribute("data-engine", o);
  }
  static get NpmPackage() {
    return "babylonjs@5.44.0";
  }
  static get Version() {
    return "5.44.0";
  }
  get description() {
    let e = this.name + this.webGLVersion;
    return this._caps.parallelShaderCompile && (e += " - Parallel shader compilation"), e;
  }
  get name() {
    return this._name;
  }
  set name(e) {
    this._name = e;
  }
  get version() {
    return this._webGLVersion;
  }
  static get ShadersRepository() {
    return De.ShadersRepository;
  }
  static set ShadersRepository(e) {
    De.ShadersRepository = e;
  }
  _getShaderProcessor(e) {
    return this._shaderProcessor;
  }
  get useReverseDepthBuffer() {
    return this._useReverseDepthBuffer;
  }
  set useReverseDepthBuffer(e) {
    e !== this._useReverseDepthBuffer && (this._useReverseDepthBuffer = e, e ? this._depthCullingState.depthFunc = 518 : this._depthCullingState.depthFunc = 515);
  }
  get frameId() {
    return this._frameId;
  }
  get supportsUniformBuffers() {
    return this.webGLVersion > 1 && !this.disableUniformBuffers;
  }
  getCreationOptions() {
    return this._creationOptions;
  }
  get _shouldUseHighPrecisionShader() {
    return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
  }
  get needPOTTextures() {
    return this._webGLVersion < 2 || this.forcePOTTextures;
  }
  get activeRenderLoops() {
    return this._activeRenderLoops;
  }
  get doNotHandleContextLost() {
    return this._doNotHandleContextLost;
  }
  set doNotHandleContextLost(e) {
    this._doNotHandleContextLost = e;
  }
  get _supportsHardwareTextureRescaling() {
    return !1;
  }
  set framebufferDimensionsObject(e) {
    this._framebufferDimensionsObject = e;
  }
  get currentViewport() {
    return this._cachedViewport;
  }
  get emptyTexture() {
    return this._emptyTexture || (this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, !1, !1, 1)), this._emptyTexture;
  }
  get emptyTexture3D() {
    return this._emptyTexture3D || (this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture3D;
  }
  get emptyTexture2DArray() {
    return this._emptyTexture2DArray || (this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, !1, !1, 1)), this._emptyTexture2DArray;
  }
  get emptyCubeTexture() {
    if (!this._emptyCubeTexture) {
      const e = new Uint8Array(4), t = [e, e, e, e, e, e];
      this._emptyCubeTexture = this.createRawCubeTexture(t, 1, 5, 0, !1, !1, 1);
    }
    return this._emptyCubeTexture;
  }
  get isWebGPU() {
    return this._isWebGPU;
  }
  get shaderPlatformName() {
    return this._shaderPlatformName;
  }
  get snapshotRendering() {
    return !1;
  }
  set snapshotRendering(e) {
  }
  get snapshotRenderingMode() {
    return this._snapshotRenderingMode;
  }
  set snapshotRenderingMode(e) {
    this._snapshotRenderingMode = e;
  }
  get useExactSrgbConversions() {
    return this._useExactSrgbConversions;
  }
  snapshotRenderingReset() {
    this.snapshotRendering = !1;
  }
  static _CreateCanvas(e, t) {
    if (typeof document > "u")
      return new OffscreenCanvas(e, t);
    const i = document.createElement("canvas");
    return i.width = e, i.height = t, i;
  }
  createCanvas(e, t) {
    return le._CreateCanvas(e, t);
  }
  createCanvasImage() {
    return document.createElement("img");
  }
  _restoreEngineAfterContextLost(e) {
    setTimeout(async () => {
      var t;
      this._dummyFramebuffer = null;
      const i = this._depthCullingState.depthTest, s = this._depthCullingState.depthFunc, r = this._depthCullingState.depthMask, n = this._stencilState.stencilTest;
      await e(), this.wipeCaches(!0), this._rebuildEffects(), (t = this._rebuildComputeEffects) === null || t === void 0 || t.call(this), this._rebuildBuffers(), this._rebuildInternalTextures(), this._rebuildRenderTargetWrappers(), this.wipeCaches(!0), this._depthCullingState.depthTest = i, this._depthCullingState.depthFunc = s, this._depthCullingState.depthMask = r, this._stencilState.stencilTest = n, O.Warn(this.name + " context successfully restored."), this.onContextRestoredObservable.notifyObservers(this), this._contextWasLost = !1;
    }, 0);
  }
  _sharedInit(e, t, i) {
    this._renderingCanvas = e;
  }
  _getShaderProcessingContext(e) {
    return null;
  }
  _rebuildInternalTextures() {
    const e = this._internalTexturesCache.slice();
    for (const t of e)
      t._rebuild();
  }
  _rebuildRenderTargetWrappers() {
    const e = this._renderTargetWrapperCache.slice();
    for (const t of e)
      t._rebuild();
  }
  _rebuildEffects() {
    for (const e in this._compiledEffects) {
      const t = this._compiledEffects[e];
      t._pipelineContext = null, t._wasPreviouslyReady = !1, t._prepareEffect();
    }
    De.ResetCache();
  }
  areAllEffectsReady() {
    for (const e in this._compiledEffects)
      if (!this._compiledEffects[e].isReady())
        return !1;
    return !0;
  }
  _rebuildBuffers() {
    for (const e of this._uniformBuffers)
      e._rebuild();
    for (const e of this._storageBuffers)
      e._rebuild();
  }
  _initGLContext() {
    var e;
    this._caps = {
      maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
      maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
      maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
      maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
      maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
      maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
      maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
      maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
      maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
      maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
      maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
      parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
      standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
      maxAnisotropy: 1,
      astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
      bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
      s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
      s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
      pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
      etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
      etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
      textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
      uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
      fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
      highPrecisionShaderSupported: !1,
      timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
      supportOcclusionQuery: this._webGLVersion > 1,
      canUseTimestampForTimerQuery: !1,
      drawBuffersExtension: !1,
      maxMSAASamples: 1,
      colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
      textureFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float")),
      textureHalfFloat: !!(this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float")),
      textureHalfFloatRender: !1,
      textureFloatLinearFiltering: !1,
      textureFloatRender: !1,
      textureHalfFloatLinearFiltering: !1,
      vertexArrayObject: !1,
      instancedArrays: !1,
      textureLOD: !!(this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod")),
      blendMinMax: !1,
      multiview: this._gl.getExtension("OVR_multiview2"),
      oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
      depthTextureExtension: !1,
      canUseGLInstanceID: this._webGLVersion > 1,
      canUseGLVertexID: this._webGLVersion > 1,
      supportComputeShaders: !1,
      supportSRGBBuffers: !1,
      supportTransformFeedbacks: this._webGLVersion > 1,
      textureMaxLevel: this._webGLVersion > 1,
      texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? 256 : 128
    }, this._glVersion = this._gl.getParameter(this._gl.VERSION);
    const t = this._gl.getExtension("WEBGL_debug_renderer_info");
    if (t != null && (this._glRenderer = this._gl.getParameter(t.UNMASKED_RENDERER_WEBGL), this._glVendor = this._gl.getParameter(t.UNMASKED_VENDOR_WEBGL)), this._glVendor || (this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor"), this._glRenderer || (this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer"), this._gl.HALF_FLOAT_OES !== 36193 && (this._gl.HALF_FLOAT_OES = 36193), this._gl.RGBA16F !== 34842 && (this._gl.RGBA16F = 34842), this._gl.RGBA32F !== 34836 && (this._gl.RGBA32F = 34836), this._gl.DEPTH24_STENCIL8 !== 35056 && (this._gl.DEPTH24_STENCIL8 = 35056), this._caps.timerQuery && (this._webGLVersion === 1 && (this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery)), this._caps.canUseTimestampForTimerQuery = ((e = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)) !== null && e !== void 0 ? e : 0) > 0), this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0, this._caps.textureFloatLinearFiltering = !!(this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear")), this._caps.textureFloatRender = !!(this._caps.textureFloat && this._canRenderToFloatFramebuffer()), this._caps.textureHalfFloatLinearFiltering = !!(this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear")), this._caps.astc && (this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR), this._caps.bptc && (this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT), this._caps.s3tc_srgb && (this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT, this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT), this._caps.etc2 && (this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2, this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC), this._webGLVersion > 1 && this._gl.HALF_FLOAT_OES !== 5131 && (this._gl.HALF_FLOAT_OES = 5131), this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer(), this._webGLVersion > 1)
      this._caps.drawBuffersExtension = !0, this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
    else {
      const i = this._gl.getExtension("WEBGL_draw_buffers");
      if (i !== null) {
        this._caps.drawBuffersExtension = !0, this._gl.drawBuffers = i.drawBuffersWEBGL.bind(i), this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
        for (let s = 0; s < 16; s++)
          this._gl["COLOR_ATTACHMENT" + s + "_WEBGL"] = i["COLOR_ATTACHMENT" + s + "_WEBGL"];
      }
    }
    if (this._webGLVersion > 1)
      this._caps.depthTextureExtension = !0;
    else {
      const i = this._gl.getExtension("WEBGL_depth_texture");
      i != null && (this._caps.depthTextureExtension = !0, this._gl.UNSIGNED_INT_24_8 = i.UNSIGNED_INT_24_8_WEBGL);
    }
    if (this.disableVertexArrayObjects)
      this._caps.vertexArrayObject = !1;
    else if (this._webGLVersion > 1)
      this._caps.vertexArrayObject = !0;
    else {
      const i = this._gl.getExtension("OES_vertex_array_object");
      i != null && (this._caps.vertexArrayObject = !0, this._gl.createVertexArray = i.createVertexArrayOES.bind(i), this._gl.bindVertexArray = i.bindVertexArrayOES.bind(i), this._gl.deleteVertexArray = i.deleteVertexArrayOES.bind(i));
    }
    if (this._webGLVersion > 1)
      this._caps.instancedArrays = !0;
    else {
      const i = this._gl.getExtension("ANGLE_instanced_arrays");
      i != null ? (this._caps.instancedArrays = !0, this._gl.drawArraysInstanced = i.drawArraysInstancedANGLE.bind(i), this._gl.drawElementsInstanced = i.drawElementsInstancedANGLE.bind(i), this._gl.vertexAttribDivisor = i.vertexAttribDivisorANGLE.bind(i)) : this._caps.instancedArrays = !1;
    }
    if (this._gl.getShaderPrecisionFormat) {
      const i = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT), s = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
      i && s && (this._caps.highPrecisionShaderSupported = i.precision !== 0 && s.precision !== 0);
    }
    if (this._webGLVersion > 1)
      this._caps.blendMinMax = !0;
    else {
      const i = this._gl.getExtension("EXT_blend_minmax");
      i != null && (this._caps.blendMinMax = !0, this._gl.MAX = i.MAX_EXT, this._gl.MIN = i.MIN_EXT);
    }
    if (!this._caps.supportSRGBBuffers) {
      if (this._webGLVersion > 1)
        this._caps.supportSRGBBuffers = !0;
      else {
        const i = this._gl.getExtension("EXT_sRGB");
        i != null && (this._caps.supportSRGBBuffers = !0, this._gl.SRGB = i.SRGB_EXT, this._gl.SRGB8 = i.SRGB_ALPHA_EXT, this._gl.SRGB8_ALPHA8 = i.SRGB_ALPHA_EXT);
      }
      this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
    }
    this._depthCullingState.depthTest = !0, this._depthCullingState.depthFunc = this._gl.LEQUAL, this._depthCullingState.depthMask = !0, this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
    for (let i = 0; i < this._maxSimultaneousTextures; i++)
      this._nextFreeTextureSlots.push(i);
  }
  _initFeatures() {
    this._features = {
      forceBitmapOverHTMLImageElement: !1,
      supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
      supportDepthStencilTexture: this._webGLVersion !== 1,
      supportShadowSamplers: this._webGLVersion !== 1,
      uniformBufferHardCheckMatrix: !1,
      allowTexturePrefiltering: this._webGLVersion !== 1,
      trackUbosInFrame: !1,
      checkUbosContentBeforeUpload: !1,
      supportCSM: this._webGLVersion !== 1,
      basisNeedsPOT: this._webGLVersion === 1,
      support3DTextures: this._webGLVersion !== 1,
      needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
      supportMSAA: this._webGLVersion !== 1,
      supportSSAO2: this._webGLVersion !== 1,
      supportExtendedTextureFormats: this._webGLVersion !== 1,
      supportSwitchCaseInShader: this._webGLVersion !== 1,
      supportSyncTextureRead: !0,
      needsInvertingBitmap: !0,
      useUBOBindingCache: !0,
      needShaderCodeInlining: !1,
      needToAlwaysBindUniformBuffers: !1,
      supportRenderPasses: !1,
      supportSpriteInstancing: !0,
      _collectUbosUpdatedInFrame: !1
    };
  }
  get webGLVersion() {
    return this._webGLVersion;
  }
  getClassName() {
    return "ThinEngine";
  }
  get isStencilEnable() {
    return this._isStencilEnable;
  }
  _prepareWorkingCanvas() {
    if (this._workingCanvas)
      return;
    this._workingCanvas = this.createCanvas(1, 1);
    const e = this._workingCanvas.getContext("2d");
    e && (this._workingContext = e);
  }
  resetTextureCache() {
    for (const e in this._boundTexturesCache)
      !Object.prototype.hasOwnProperty.call(this._boundTexturesCache, e) || (this._boundTexturesCache[e] = null);
    this._currentTextureChannel = -1;
  }
  getInfo() {
    return this.getGlInfo();
  }
  getGlInfo() {
    return {
      vendor: this._glVendor,
      renderer: this._glRenderer,
      version: this._glVersion
    };
  }
  setHardwareScalingLevel(e) {
    this._hardwareScalingLevel = e, this.resize();
  }
  getHardwareScalingLevel() {
    return this._hardwareScalingLevel;
  }
  getLoadedTexturesCache() {
    return this._internalTexturesCache;
  }
  getCaps() {
    return this._caps;
  }
  stopRenderLoop(e) {
    if (!e) {
      this._activeRenderLoops = [];
      return;
    }
    const t = this._activeRenderLoops.indexOf(e);
    t >= 0 && this._activeRenderLoops.splice(t, 1);
  }
  _renderLoop() {
    if (!this._contextWasLost) {
      let e = !0;
      if (!this.renderEvenInBackground && this._windowIsBackground && (e = !1), e) {
        this.beginFrame();
        for (let t = 0; t < this._activeRenderLoops.length; t++) {
          const i = this._activeRenderLoops[t];
          i();
        }
        this.endFrame();
      }
    }
    this._activeRenderLoops.length > 0 ? this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1;
  }
  getRenderingCanvas() {
    return this._renderingCanvas;
  }
  getAudioContext() {
    return this._audioContext;
  }
  getAudioDestination() {
    return this._audioDestination;
  }
  getHostWindow() {
    return Ze() ? this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView ? this._renderingCanvas.ownerDocument.defaultView : window : null;
  }
  getRenderWidth(e = !1) {
    return !e && this._currentRenderTarget ? this._currentRenderTarget.width : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
  }
  getRenderHeight(e = !1) {
    return !e && this._currentRenderTarget ? this._currentRenderTarget.height : this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
  }
  _queueNewFrame(e, t) {
    return le.QueueNewFrame(e, t);
  }
  runRenderLoop(e) {
    this._activeRenderLoops.indexOf(e) === -1 && (this._activeRenderLoops.push(e), this._renderingQueueLaunched || (this._renderingQueueLaunched = !0, this._boundRenderFunction = this._renderLoop.bind(this), this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow())));
  }
  clear(e, t, i, s = !1) {
    const r = this.stencilStateComposer.useStencilGlobalOnly;
    this.stencilStateComposer.useStencilGlobalOnly = !0, this.applyStates(), this.stencilStateComposer.useStencilGlobalOnly = r;
    let n = 0;
    t && e && (this._gl.clearColor(e.r, e.g, e.b, e.a !== void 0 ? e.a : 1), n |= this._gl.COLOR_BUFFER_BIT), i && (this.useReverseDepthBuffer ? (this._depthCullingState.depthFunc = this._gl.GEQUAL, this._gl.clearDepth(0)) : this._gl.clearDepth(1), n |= this._gl.DEPTH_BUFFER_BIT), s && (this._gl.clearStencil(0), n |= this._gl.STENCIL_BUFFER_BIT), this._gl.clear(n);
  }
  _viewport(e, t, i, s) {
    (e !== this._viewportCached.x || t !== this._viewportCached.y || i !== this._viewportCached.z || s !== this._viewportCached.w) && (this._viewportCached.x = e, this._viewportCached.y = t, this._viewportCached.z = i, this._viewportCached.w = s, this._gl.viewport(e, t, i, s));
  }
  setViewport(e, t, i) {
    const s = t || this.getRenderWidth(), r = i || this.getRenderHeight(), n = e.x || 0, a = e.y || 0;
    this._cachedViewport = e, this._viewport(n * s, a * r, s * e.width, r * e.height);
  }
  beginFrame() {
  }
  endFrame() {
    this._badOS && this.flushFramebuffer(), this._frameId++;
  }
  resize(e = !1) {
    let t, i;
    if (this.adaptToDeviceRatio) {
      const s = Ze() && window.devicePixelRatio || 1, r = this._lastDevicePixelRatio / s;
      this._lastDevicePixelRatio = s, this._hardwareScalingLevel *= r;
    }
    Ze() ? (t = this._renderingCanvas ? this._renderingCanvas.clientWidth || this._renderingCanvas.width : window.innerWidth, i = this._renderingCanvas ? this._renderingCanvas.clientHeight || this._renderingCanvas.height : window.innerHeight) : (t = this._renderingCanvas ? this._renderingCanvas.width : 100, i = this._renderingCanvas ? this._renderingCanvas.height : 100), this.setSize(t / this._hardwareScalingLevel, i / this._hardwareScalingLevel, e);
  }
  setSize(e, t, i = !1) {
    return !this._renderingCanvas || (e = e | 0, t = t | 0, !i && this._renderingCanvas.width === e && this._renderingCanvas.height === t) ? !1 : (this._renderingCanvas.width = e, this._renderingCanvas.height = t, !0);
  }
  bindFramebuffer(e, t = 0, i, s, r, n = 0, a = 0) {
    var o, h, l, u, d;
    const f = e;
    this._currentRenderTarget && this.unBindFramebuffer(this._currentRenderTarget), this._currentRenderTarget = e, this._bindUnboundFramebuffer(f._MSAAFramebuffer ? f._MSAAFramebuffer : f._framebuffer);
    const _ = this._gl;
    e.is2DArray ? _.framebufferTextureLayer(_.FRAMEBUFFER, _.COLOR_ATTACHMENT0, (o = e.texture._hardwareTexture) === null || o === void 0 ? void 0 : o.underlyingResource, n, a) : e.isCube && _.framebufferTexture2D(_.FRAMEBUFFER, _.COLOR_ATTACHMENT0, _.TEXTURE_CUBE_MAP_POSITIVE_X + t, (h = e.texture._hardwareTexture) === null || h === void 0 ? void 0 : h.underlyingResource, n);
    const E = e._depthStencilTexture;
    if (E) {
      const m = e._depthStencilTextureWithStencil ? _.DEPTH_STENCIL_ATTACHMENT : _.DEPTH_ATTACHMENT;
      e.is2DArray ? _.framebufferTextureLayer(_.FRAMEBUFFER, m, (l = E._hardwareTexture) === null || l === void 0 ? void 0 : l.underlyingResource, n, a) : e.isCube ? _.framebufferTexture2D(_.FRAMEBUFFER, m, _.TEXTURE_CUBE_MAP_POSITIVE_X + t, (u = E._hardwareTexture) === null || u === void 0 ? void 0 : u.underlyingResource, n) : _.framebufferTexture2D(_.FRAMEBUFFER, m, _.TEXTURE_2D, (d = E._hardwareTexture) === null || d === void 0 ? void 0 : d.underlyingResource, n);
    }
    this._cachedViewport && !r ? this.setViewport(this._cachedViewport, i, s) : (i || (i = e.width, n && (i = i / Math.pow(2, n))), s || (s = e.height, n && (s = s / Math.pow(2, n))), this._viewport(0, 0, i, s)), this.wipeCaches();
  }
  setState(e, t = 0, i, s = !1, r, n, a = 0) {
    var o, h;
    (this._depthCullingState.cull !== e || i) && (this._depthCullingState.cull = e);
    const l = !((h = (o = this.cullBackFaces) !== null && o !== void 0 ? o : r) !== null && h !== void 0) || h ? this._gl.BACK : this._gl.FRONT;
    (this._depthCullingState.cullFace !== l || i) && (this._depthCullingState.cullFace = l), this.setZOffset(t), this.setZOffsetUnits(a);
    const u = s ? this._gl.CW : this._gl.CCW;
    (this._depthCullingState.frontFace !== u || i) && (this._depthCullingState.frontFace = u), this._stencilStateComposer.stencilMaterial = n;
  }
  getDepthBuffer() {
    return this._depthCullingState.depthTest;
  }
  setDepthBuffer(e) {
    this._depthCullingState.depthTest = e;
  }
  setZOffset(e) {
    this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -e : e;
  }
  getZOffset() {
    const e = this._depthCullingState.zOffset;
    return this.useReverseDepthBuffer ? -e : e;
  }
  setZOffsetUnits(e) {
    this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -e : e;
  }
  getZOffsetUnits() {
    const e = this._depthCullingState.zOffsetUnits;
    return this.useReverseDepthBuffer ? -e : e;
  }
  _bindUnboundFramebuffer(e) {
    this._currentFramebuffer !== e && (this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, e), this._currentFramebuffer = e);
  }
  _currentFrameBufferIsDefaultFrameBuffer() {
    return this._currentFramebuffer === null;
  }
  generateMipmaps(e) {
    this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), this._gl.generateMipmap(this._gl.TEXTURE_2D), this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
  }
  unBindFramebuffer(e, t = !1, i) {
    var s;
    const r = e;
    this._currentRenderTarget = null;
    const n = this._gl;
    if (r._MSAAFramebuffer) {
      if (e.isMulti) {
        this.unBindMultiColorAttachmentFramebuffer(e, t, i);
        return;
      }
      n.bindFramebuffer(n.READ_FRAMEBUFFER, r._MSAAFramebuffer), n.bindFramebuffer(n.DRAW_FRAMEBUFFER, r._framebuffer), n.blitFramebuffer(0, 0, e.width, e.height, 0, 0, e.width, e.height, n.COLOR_BUFFER_BIT, n.NEAREST);
    }
    ((s = e.texture) === null || s === void 0 ? void 0 : s.generateMipMaps) && !t && !e.isCube && this.generateMipmaps(e.texture), i && (r._MSAAFramebuffer && this._bindUnboundFramebuffer(r._framebuffer), i()), this._bindUnboundFramebuffer(null);
  }
  flushFramebuffer() {
    this._gl.flush();
  }
  restoreDefaultFramebuffer() {
    this._currentRenderTarget ? this.unBindFramebuffer(this._currentRenderTarget) : this._bindUnboundFramebuffer(null), this._cachedViewport && this.setViewport(this._cachedViewport), this.wipeCaches();
  }
  _resetVertexBufferBinding() {
    this.bindArrayBuffer(null), this._cachedVertexBuffers = null;
  }
  createVertexBuffer(e) {
    return this._createVertexBuffer(e, this._gl.STATIC_DRAW);
  }
  _createVertexBuffer(e, t) {
    const i = this._gl.createBuffer();
    if (!i)
      throw new Error("Unable to create vertex buffer");
    const s = new Fi(i);
    return this.bindArrayBuffer(s), e instanceof Array ? this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(e), t) : this._gl.bufferData(this._gl.ARRAY_BUFFER, e, t), this._resetVertexBufferBinding(), s.references = 1, s;
  }
  createDynamicVertexBuffer(e) {
    return this._createVertexBuffer(e, this._gl.DYNAMIC_DRAW);
  }
  _resetIndexBufferBinding() {
    this.bindIndexBuffer(null), this._cachedIndexBuffer = null;
  }
  createIndexBuffer(e, t) {
    const i = this._gl.createBuffer(), s = new Fi(i);
    if (!i)
      throw new Error("Unable to create index buffer");
    this.bindIndexBuffer(s);
    const r = this._normalizeIndexData(e);
    return this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, r, t ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW), this._resetIndexBufferBinding(), s.references = 1, s.is32Bits = r.BYTES_PER_ELEMENT === 4, s;
  }
  _normalizeIndexData(e) {
    if (e.BYTES_PER_ELEMENT === 2)
      return e;
    if (this._caps.uintIndices) {
      if (e instanceof Uint32Array)
        return e;
      for (let i = 0; i < e.length; i++)
        if (e[i] >= 65535)
          return new Uint32Array(e);
      return new Uint16Array(e);
    }
    return new Uint16Array(e);
  }
  bindArrayBuffer(e) {
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ARRAY_BUFFER);
  }
  bindUniformBlock(e, t, i) {
    const s = e.program, r = this._gl.getUniformBlockIndex(s, t);
    this._gl.uniformBlockBinding(s, r, i);
  }
  bindIndexBuffer(e) {
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this._bindBuffer(e, this._gl.ELEMENT_ARRAY_BUFFER);
  }
  _bindBuffer(e, t) {
    (this._vaoRecordInProgress || this._currentBoundBuffer[t] !== e) && (this._gl.bindBuffer(t, e ? e.underlyingResource : null), this._currentBoundBuffer[t] = e);
  }
  updateArrayBuffer(e) {
    this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e);
  }
  _vertexAttribPointer(e, t, i, s, r, n, a) {
    const o = this._currentBufferPointers[t];
    if (!o)
      return;
    let h = !1;
    o.active ? (o.buffer !== e && (o.buffer = e, h = !0), o.size !== i && (o.size = i, h = !0), o.type !== s && (o.type = s, h = !0), o.normalized !== r && (o.normalized = r, h = !0), o.stride !== n && (o.stride = n, h = !0), o.offset !== a && (o.offset = a, h = !0)) : (h = !0, o.active = !0, o.index = t, o.size = i, o.type = s, o.normalized = r, o.stride = n, o.offset = a, o.buffer = e), (h || this._vaoRecordInProgress) && (this.bindArrayBuffer(e), s === this._gl.UNSIGNED_INT || s === this._gl.INT ? this._gl.vertexAttribIPointer(t, i, s, n, a) : this._gl.vertexAttribPointer(t, i, s, r, n, a));
  }
  _bindIndexBufferWithCache(e) {
    e != null && this._cachedIndexBuffer !== e && (this._cachedIndexBuffer = e, this.bindIndexBuffer(e), this._uintIndicesCurrentlySet = e.is32Bits);
  }
  _bindVertexBuffersAttributes(e, t, i) {
    const s = t.getAttributesNames();
    this._vaoRecordInProgress || this._unbindVertexArrayObject(), this.unbindAllAttributes();
    for (let r = 0; r < s.length; r++) {
      const n = t.getAttributeLocation(r);
      if (n >= 0) {
        const a = s[r];
        let o = null;
        if (i && (o = i[a]), o || (o = e[a]), !o)
          continue;
        this._gl.enableVertexAttribArray(n), this._vaoRecordInProgress || (this._vertexAttribArraysEnabled[n] = !0);
        const h = o.getBuffer();
        h && (this._vertexAttribPointer(h, n, o.getSize(), o.type, o.normalized, o.byteStride, o.byteOffset), o.getIsInstanced() && (this._gl.vertexAttribDivisor(n, o.getInstanceDivisor()), this._vaoRecordInProgress || (this._currentInstanceLocations.push(n), this._currentInstanceBuffers.push(h))));
      }
    }
  }
  recordVertexArrayObject(e, t, i, s) {
    const r = this._gl.createVertexArray();
    if (!r)
      throw new Error("Unable to create VAO");
    return this._vaoRecordInProgress = !0, this._gl.bindVertexArray(r), this._mustWipeVertexAttributes = !0, this._bindVertexBuffersAttributes(e, i, s), this.bindIndexBuffer(t), this._vaoRecordInProgress = !1, this._gl.bindVertexArray(null), r;
  }
  bindVertexArrayObject(e, t) {
    this._cachedVertexArrayObject !== e && (this._cachedVertexArrayObject = e, this._gl.bindVertexArray(e), this._cachedVertexBuffers = null, this._cachedIndexBuffer = null, this._uintIndicesCurrentlySet = t != null && t.is32Bits, this._mustWipeVertexAttributes = !0);
  }
  bindBuffersDirectly(e, t, i, s, r) {
    if (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== r) {
      this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = r;
      const n = r.getAttributesCount();
      this._unbindVertexArrayObject(), this.unbindAllAttributes();
      let a = 0;
      for (let o = 0; o < n; o++)
        if (o < i.length) {
          const h = r.getAttributeLocation(o);
          h >= 0 && (this._gl.enableVertexAttribArray(h), this._vertexAttribArraysEnabled[h] = !0, this._vertexAttribPointer(e, h, i[o], this._gl.FLOAT, !1, s, a)), a += i[o] * 4;
        }
    }
    this._bindIndexBufferWithCache(t);
  }
  _unbindVertexArrayObject() {
    !this._cachedVertexArrayObject || (this._cachedVertexArrayObject = null, this._gl.bindVertexArray(null));
  }
  bindBuffers(e, t, i, s) {
    (this._cachedVertexBuffers !== e || this._cachedEffectForVertexBuffers !== i) && (this._cachedVertexBuffers = e, this._cachedEffectForVertexBuffers = i, this._bindVertexBuffersAttributes(e, i, s)), this._bindIndexBufferWithCache(t);
  }
  unbindInstanceAttributes() {
    let e;
    for (let t = 0, i = this._currentInstanceLocations.length; t < i; t++) {
      const s = this._currentInstanceBuffers[t];
      e != s && s.references && (e = s, this.bindArrayBuffer(s));
      const r = this._currentInstanceLocations[t];
      this._gl.vertexAttribDivisor(r, 0);
    }
    this._currentInstanceBuffers.length = 0, this._currentInstanceLocations.length = 0;
  }
  releaseVertexArrayObject(e) {
    this._gl.deleteVertexArray(e);
  }
  _releaseBuffer(e) {
    return e.references--, e.references === 0 ? (this._deleteBuffer(e), !0) : !1;
  }
  _deleteBuffer(e) {
    this._gl.deleteBuffer(e.underlyingResource);
  }
  updateAndBindInstancesBuffer(e, t, i) {
    if (this.bindArrayBuffer(e), t && this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, t), i[0].index !== void 0)
      this.bindInstancesBuffer(e, i, !0);
    else
      for (let s = 0; s < 4; s++) {
        const r = i[s];
        this._vertexAttribArraysEnabled[r] || (this._gl.enableVertexAttribArray(r), this._vertexAttribArraysEnabled[r] = !0), this._vertexAttribPointer(e, r, 4, this._gl.FLOAT, !1, 64, s * 16), this._gl.vertexAttribDivisor(r, 1), this._currentInstanceLocations.push(r), this._currentInstanceBuffers.push(e);
      }
  }
  bindInstancesBuffer(e, t, i = !0) {
    this.bindArrayBuffer(e);
    let s = 0;
    if (i)
      for (let r = 0; r < t.length; r++)
        s += t[r].attributeSize * 4;
    for (let r = 0; r < t.length; r++) {
      const n = t[r];
      n.index === void 0 && (n.index = this._currentEffect.getAttributeLocationByName(n.attributeName)), !(n.index < 0) && (this._vertexAttribArraysEnabled[n.index] || (this._gl.enableVertexAttribArray(n.index), this._vertexAttribArraysEnabled[n.index] = !0), this._vertexAttribPointer(e, n.index, n.attributeSize, n.attributeType || this._gl.FLOAT, n.normalized || !1, s, n.offset), this._gl.vertexAttribDivisor(n.index, n.divisor === void 0 ? 1 : n.divisor), this._currentInstanceLocations.push(n.index), this._currentInstanceBuffers.push(e));
    }
  }
  disableInstanceAttributeByName(e) {
    if (!this._currentEffect)
      return;
    const t = this._currentEffect.getAttributeLocationByName(e);
    this.disableInstanceAttribute(t);
  }
  disableInstanceAttribute(e) {
    let t = !1, i;
    for (; (i = this._currentInstanceLocations.indexOf(e)) !== -1; )
      this._currentInstanceLocations.splice(i, 1), this._currentInstanceBuffers.splice(i, 1), t = !0, i = this._currentInstanceLocations.indexOf(e);
    t && (this._gl.vertexAttribDivisor(e, 0), this.disableAttributeByIndex(e));
  }
  disableAttributeByIndex(e) {
    this._gl.disableVertexAttribArray(e), this._vertexAttribArraysEnabled[e] = !1, this._currentBufferPointers[e].active = !1;
  }
  draw(e, t, i, s) {
    this.drawElementsType(e ? 0 : 1, t, i, s);
  }
  drawPointClouds(e, t, i) {
    this.drawArraysType(2, e, t, i);
  }
  drawUnIndexed(e, t, i, s) {
    this.drawArraysType(e ? 0 : 1, t, i, s);
  }
  drawElementsType(e, t, i, s) {
    this.applyStates(), this._reportDrawCall();
    const r = this._drawMode(e), n = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT, a = this._uintIndicesCurrentlySet ? 4 : 2;
    s ? this._gl.drawElementsInstanced(r, i, n, t * a, s) : this._gl.drawElements(r, i, n, t * a);
  }
  drawArraysType(e, t, i, s) {
    this.applyStates(), this._reportDrawCall();
    const r = this._drawMode(e);
    s ? this._gl.drawArraysInstanced(r, t, i, s) : this._gl.drawArrays(r, t, i);
  }
  _drawMode(e) {
    switch (e) {
      case 0:
        return this._gl.TRIANGLES;
      case 2:
        return this._gl.POINTS;
      case 1:
        return this._gl.LINES;
      case 3:
        return this._gl.POINTS;
      case 4:
        return this._gl.LINES;
      case 5:
        return this._gl.LINE_LOOP;
      case 6:
        return this._gl.LINE_STRIP;
      case 7:
        return this._gl.TRIANGLE_STRIP;
      case 8:
        return this._gl.TRIANGLE_FAN;
      default:
        return this._gl.TRIANGLES;
    }
  }
  _reportDrawCall() {
  }
  _releaseEffect(e) {
    this._compiledEffects[e._key] && delete this._compiledEffects[e._key];
    const t = e.getPipelineContext();
    t && this._deletePipelineContext(t);
  }
  _deletePipelineContext(e) {
    const t = e;
    t && t.program && (t.program.__SPECTOR_rebuildProgram = null, this._gl.deleteProgram(t.program));
  }
  _getGlobalDefines(e) {
    if (e) {
      this.isNDCHalfZRange ? e.IS_NDC_HALF_ZRANGE = "" : delete e.IS_NDC_HALF_ZRANGE, this.useReverseDepthBuffer ? e.USE_REVERSE_DEPTHBUFFER = "" : delete e.USE_REVERSE_DEPTHBUFFER, this.useExactSrgbConversions ? e.USE_EXACT_SRGB_CONVERSIONS = "" : delete e.USE_EXACT_SRGB_CONVERSIONS;
      return;
    } else {
      let t = "";
      return this.isNDCHalfZRange && (t += "#define IS_NDC_HALF_ZRANGE"), this.useReverseDepthBuffer && (t && (t += `
`), t += "#define USE_REVERSE_DEPTHBUFFER"), this.useExactSrgbConversions && (t && (t += `
`), t += "#define USE_EXACT_SRGB_CONVERSIONS"), t;
    }
  }
  createEffect(e, t, i, s, r, n, a, o, h, l = Ke.GLSL) {
    var u;
    const d = e.vertexElement || e.vertex || e.vertexToken || e.vertexSource || e, f = e.fragmentElement || e.fragment || e.fragmentToken || e.fragmentSource || e, _ = this._getGlobalDefines();
    let E = (u = r != null ? r : t.defines) !== null && u !== void 0 ? u : "";
    _ && (E += _);
    const m = d + "+" + f + "@" + E;
    if (this._compiledEffects[m]) {
      const S = this._compiledEffects[m];
      return a && S.isReady() && a(S), S;
    }
    const v = new De(e, t, i, s, this, r, n, a, o, h, m, l);
    return this._compiledEffects[m] = v, v;
  }
  static _ConcatenateShader(e, t, i = "") {
    return i + (t ? t + `
` : "") + e;
  }
  _compileShader(e, t, i, s) {
    return this._compileRawShader(le._ConcatenateShader(e, i, s), t);
  }
  _compileRawShader(e, t) {
    const i = this._gl, s = i.createShader(t === "vertex" ? i.VERTEX_SHADER : i.FRAGMENT_SHADER);
    if (!s) {
      let r = i.NO_ERROR, n = i.NO_ERROR;
      for (; (n = i.getError()) !== i.NO_ERROR; )
        r = n;
      throw new Error(`Something went wrong while creating a gl ${t} shader object. gl error=${r}, gl isContextLost=${i.isContextLost()}, _contextWasLost=${this._contextWasLost}`);
    }
    return i.shaderSource(s, e), i.compileShader(s), s;
  }
  _getShaderSource(e) {
    return this._gl.getShaderSource(e);
  }
  createRawShaderProgram(e, t, i, s, r = null) {
    s = s || this._gl;
    const n = this._compileRawShader(t, "vertex"), a = this._compileRawShader(i, "fragment");
    return this._createShaderProgram(e, n, a, s, r);
  }
  createShaderProgram(e, t, i, s, r, n = null) {
    r = r || this._gl;
    const a = this._webGLVersion > 1 ? `#version 300 es
#define WEBGL2 
` : "", o = this._compileShader(t, "vertex", s, a), h = this._compileShader(i, "fragment", s, a);
    return this._createShaderProgram(e, o, h, r, n);
  }
  inlineShaderCode(e) {
    return e;
  }
  createPipelineContext(e) {
    const t = new dn();
    return t.engine = this, this._caps.parallelShaderCompile && (t.isParallelCompiled = !0), t;
  }
  createMaterialContext() {
  }
  createDrawContext() {
  }
  _createShaderProgram(e, t, i, s, r = null) {
    const n = s.createProgram();
    if (e.program = n, !n)
      throw new Error("Unable to create program");
    return s.attachShader(n, t), s.attachShader(n, i), s.linkProgram(n), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), n;
  }
  _finalizePipelineContext(e) {
    const t = e.context, i = e.vertexShader, s = e.fragmentShader, r = e.program;
    if (!t.getProgramParameter(r, t.LINK_STATUS)) {
      if (!this._gl.getShaderParameter(i, this._gl.COMPILE_STATUS)) {
        const o = this._gl.getShaderInfoLog(i);
        if (o)
          throw e.vertexCompilationError = o, new Error("VERTEX SHADER " + o);
      }
      if (!this._gl.getShaderParameter(s, this._gl.COMPILE_STATUS)) {
        const o = this._gl.getShaderInfoLog(s);
        if (o)
          throw e.fragmentCompilationError = o, new Error("FRAGMENT SHADER " + o);
      }
      const a = t.getProgramInfoLog(r);
      if (a)
        throw e.programLinkError = a, new Error(a);
    }
    if (this.validateShaderPrograms && (t.validateProgram(r), !t.getProgramParameter(r, t.VALIDATE_STATUS))) {
      const o = t.getProgramInfoLog(r);
      if (o)
        throw e.programValidationError = o, new Error(o);
    }
    t.deleteShader(i), t.deleteShader(s), e.vertexShader = void 0, e.fragmentShader = void 0, e.onCompiled && (e.onCompiled(), e.onCompiled = void 0);
  }
  _preparePipelineContext(e, t, i, s, r, n, a, o, h, l) {
    const u = e;
    s ? u.program = this.createRawShaderProgram(u, t, i, void 0, h) : u.program = this.createShaderProgram(u, t, i, o, void 0, h), u.program.__SPECTOR_rebuildProgram = a;
  }
  _isRenderingStateCompiled(e) {
    const t = e;
    return this._gl.getProgramParameter(t.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR) ? (this._finalizePipelineContext(t), !0) : !1;
  }
  _executeWhenRenderingStateIsCompiled(e, t) {
    const i = e;
    if (!i.isParallelCompiled) {
      t();
      return;
    }
    const s = i.onCompiled;
    s ? i.onCompiled = () => {
      s(), t();
    } : i.onCompiled = t;
  }
  getUniforms(e, t) {
    const i = new Array(), s = e;
    for (let r = 0; r < t.length; r++)
      i.push(this._gl.getUniformLocation(s.program, t[r]));
    return i;
  }
  getAttributes(e, t) {
    const i = [], s = e;
    for (let r = 0; r < t.length; r++)
      try {
        i.push(this._gl.getAttribLocation(s.program, t[r]));
      } catch {
        i.push(-1);
      }
    return i;
  }
  enableEffect(e) {
    e = e !== null && Ri.IsWrapper(e) ? e.effect : e, !(!e || e === this._currentEffect) && (this._stencilStateComposer.stencilMaterial = void 0, e = e, this.bindSamplers(e), this._currentEffect = e, e.onBind && e.onBind(e), e._onBindObservable && e._onBindObservable.notifyObservers(e));
  }
  setInt(e, t) {
    return e ? (this._gl.uniform1i(e, t), !0) : !1;
  }
  setInt2(e, t, i) {
    return e ? (this._gl.uniform2i(e, t, i), !0) : !1;
  }
  setInt3(e, t, i, s) {
    return e ? (this._gl.uniform3i(e, t, i, s), !0) : !1;
  }
  setInt4(e, t, i, s, r) {
    return e ? (this._gl.uniform4i(e, t, i, s, r), !0) : !1;
  }
  setIntArray(e, t) {
    return e ? (this._gl.uniform1iv(e, t), !0) : !1;
  }
  setIntArray2(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2iv(e, t), !0);
  }
  setIntArray3(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3iv(e, t), !0);
  }
  setIntArray4(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4iv(e, t), !0);
  }
  setUInt(e, t) {
    return e ? (this._gl.uniform1ui(e, t), !0) : !1;
  }
  setUInt2(e, t, i) {
    return e ? (this._gl.uniform2ui(e, t, i), !0) : !1;
  }
  setUInt3(e, t, i, s) {
    return e ? (this._gl.uniform3ui(e, t, i, s), !0) : !1;
  }
  setUInt4(e, t, i, s, r) {
    return e ? (this._gl.uniform4ui(e, t, i, s, r), !0) : !1;
  }
  setUIntArray(e, t) {
    return e ? (this._gl.uniform1uiv(e, t), !0) : !1;
  }
  setUIntArray2(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2uiv(e, t), !0);
  }
  setUIntArray3(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3uiv(e, t), !0);
  }
  setUIntArray4(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4uiv(e, t), !0);
  }
  setArray(e, t) {
    return !e || t.length < 1 ? !1 : (this._gl.uniform1fv(e, t), !0);
  }
  setArray2(e, t) {
    return !e || t.length % 2 !== 0 ? !1 : (this._gl.uniform2fv(e, t), !0);
  }
  setArray3(e, t) {
    return !e || t.length % 3 !== 0 ? !1 : (this._gl.uniform3fv(e, t), !0);
  }
  setArray4(e, t) {
    return !e || t.length % 4 !== 0 ? !1 : (this._gl.uniform4fv(e, t), !0);
  }
  setMatrices(e, t) {
    return e ? (this._gl.uniformMatrix4fv(e, !1, t), !0) : !1;
  }
  setMatrix3x3(e, t) {
    return e ? (this._gl.uniformMatrix3fv(e, !1, t), !0) : !1;
  }
  setMatrix2x2(e, t) {
    return e ? (this._gl.uniformMatrix2fv(e, !1, t), !0) : !1;
  }
  setFloat(e, t) {
    return e ? (this._gl.uniform1f(e, t), !0) : !1;
  }
  setFloat2(e, t, i) {
    return e ? (this._gl.uniform2f(e, t, i), !0) : !1;
  }
  setFloat3(e, t, i, s) {
    return e ? (this._gl.uniform3f(e, t, i, s), !0) : !1;
  }
  setFloat4(e, t, i, s, r) {
    return e ? (this._gl.uniform4f(e, t, i, s, r), !0) : !1;
  }
  applyStates() {
    if (this._depthCullingState.apply(this._gl), this._stencilStateComposer.apply(this._gl), this._alphaState.apply(this._gl), this._colorWriteChanged) {
      this._colorWriteChanged = !1;
      const e = this._colorWrite;
      this._gl.colorMask(e, e, e, e);
    }
  }
  setColorWrite(e) {
    e !== this._colorWrite && (this._colorWriteChanged = !0, this._colorWrite = e);
  }
  getColorWrite() {
    return this._colorWrite;
  }
  get depthCullingState() {
    return this._depthCullingState;
  }
  get alphaState() {
    return this._alphaState;
  }
  get stencilState() {
    return this._stencilState;
  }
  get stencilStateComposer() {
    return this._stencilStateComposer;
  }
  clearInternalTexturesCache() {
    this._internalTexturesCache.length = 0;
  }
  wipeCaches(e) {
    this.preventCacheWipeBetweenFrames && !e || (this._currentEffect = null, this._viewportCached.x = 0, this._viewportCached.y = 0, this._viewportCached.z = 0, this._viewportCached.w = 0, this._unbindVertexArrayObject(), e && (this._currentProgram = null, this.resetTextureCache(), this._stencilStateComposer.reset(), this._depthCullingState.reset(), this._depthCullingState.depthFunc = this._gl.LEQUAL, this._alphaState.reset(), this._alphaMode = 1, this._alphaEquation = 0, this._colorWrite = !0, this._colorWriteChanged = !0, this._unpackFlipYCached = null, this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE), this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0), this._mustWipeVertexAttributes = !0, this.unbindAllAttributes()), this._resetVertexBufferBinding(), this._cachedIndexBuffer = null, this._cachedEffectForVertexBuffers = null, this.bindIndexBuffer(null));
  }
  _getSamplingParameters(e, t) {
    const i = this._gl;
    let s = i.NEAREST, r = i.NEAREST;
    switch (e) {
      case 11:
        s = i.LINEAR, t ? r = i.LINEAR_MIPMAP_NEAREST : r = i.LINEAR;
        break;
      case 3:
        s = i.LINEAR, t ? r = i.LINEAR_MIPMAP_LINEAR : r = i.LINEAR;
        break;
      case 8:
        s = i.NEAREST, t ? r = i.NEAREST_MIPMAP_LINEAR : r = i.NEAREST;
        break;
      case 4:
        s = i.NEAREST, t ? r = i.NEAREST_MIPMAP_NEAREST : r = i.NEAREST;
        break;
      case 5:
        s = i.NEAREST, t ? r = i.LINEAR_MIPMAP_NEAREST : r = i.LINEAR;
        break;
      case 6:
        s = i.NEAREST, t ? r = i.LINEAR_MIPMAP_LINEAR : r = i.LINEAR;
        break;
      case 7:
        s = i.NEAREST, r = i.LINEAR;
        break;
      case 1:
        s = i.NEAREST, r = i.NEAREST;
        break;
      case 9:
        s = i.LINEAR, t ? r = i.NEAREST_MIPMAP_NEAREST : r = i.NEAREST;
        break;
      case 10:
        s = i.LINEAR, t ? r = i.NEAREST_MIPMAP_LINEAR : r = i.NEAREST;
        break;
      case 2:
        s = i.LINEAR, r = i.LINEAR;
        break;
      case 12:
        s = i.LINEAR, r = i.NEAREST;
        break;
    }
    return {
      min: r,
      mag: s
    };
  }
  _createTexture() {
    const e = this._gl.createTexture();
    if (!e)
      throw new Error("Unable to create texture");
    return e;
  }
  _createHardwareTexture() {
    return new Mr(this._createTexture(), this._gl);
  }
  _createInternalTexture(e, t, i = !0, s = Oe.Unknown) {
    var r;
    let n = !1, a = 0, o = 3, h = 5, l = !1, u = 1;
    t !== void 0 && typeof t == "object" ? (n = !!t.generateMipMaps, a = t.type === void 0 ? 0 : t.type, o = t.samplingMode === void 0 ? 3 : t.samplingMode, h = t.format === void 0 ? 5 : t.format, l = t.useSRGBBuffer === void 0 ? !1 : t.useSRGBBuffer, u = (r = t.samples) !== null && r !== void 0 ? r : 1) : n = !!t, l && (l = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU)), (a === 1 && !this._caps.textureFloatLinearFiltering || a === 2 && !this._caps.textureHalfFloatLinearFiltering) && (o = 1), a === 1 && !this._caps.textureFloat && (a = 0, O.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE"));
    const d = this._gl, f = new Vt(this, s), _ = e.width || e, E = e.height || e, m = e.layers || 0, v = this._getSamplingParameters(o, n), S = m !== 0 ? d.TEXTURE_2D_ARRAY : d.TEXTURE_2D, y = this._getRGBABufferInternalSizedFormat(a, h, l), A = this._getInternalFormat(h), C = this._getWebGLTextureType(a);
    return this._bindTextureDirectly(S, f), m !== 0 ? (f.is2DArray = !0, d.texImage3D(S, 0, y, _, E, m, 0, A, C, null)) : d.texImage2D(S, 0, y, _, E, 0, A, C, null), d.texParameteri(S, d.TEXTURE_MAG_FILTER, v.mag), d.texParameteri(S, d.TEXTURE_MIN_FILTER, v.min), d.texParameteri(S, d.TEXTURE_WRAP_S, d.CLAMP_TO_EDGE), d.texParameteri(S, d.TEXTURE_WRAP_T, d.CLAMP_TO_EDGE), n && this._gl.generateMipmap(S), this._bindTextureDirectly(S, null), f._useSRGBBuffer = l, f.baseWidth = _, f.baseHeight = E, f.width = _, f.height = E, f.depth = m, f.isReady = !0, f.samples = u, f.generateMipMaps = n, f.samplingMode = o, f.type = a, f.format = h, this._internalTexturesCache.push(f), f;
  }
  _getUseSRGBBuffer(e, t) {
    return e && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || t);
  }
  _createTextureBase(e, t, i, s, r = 3, n = null, a = null, o, h, l = null, u = null, d = null, f = null, _, E, m) {
    e = e || "";
    const v = e.substr(0, 5) === "data:", S = e.substr(0, 5) === "blob:", y = v && e.indexOf(";base64,") !== -1, A = u || new Vt(this, Oe.Url), C = e;
    this._transformTextureUrl && !y && !u && !l && (e = this._transformTextureUrl(e)), C !== e && (A._originalUrl = C);
    const b = e.lastIndexOf(".");
    let M = f || (b > -1 ? e.substring(b).toLowerCase() : ""), L = null;
    M.indexOf("?") > -1 && (M = M.split("?")[0]);
    for (const ce of le._TextureLoaders)
      if (ce.canLoad(M, _)) {
        L = ce;
        break;
      }
    s && s.addPendingData(A), A.url = e, A.generateMipMaps = !t, A.samplingMode = r, A.invertY = i, A._useSRGBBuffer = this._getUseSRGBBuffer(!!m, t), this._doNotHandleContextLost || (A._buffer = l);
    let F = null;
    n && !u && (F = A.onLoadedObservable.add(n)), u || this._internalTexturesCache.push(A);
    const ue = (ce, ie) => {
      s && s.removePendingData(A), e === C ? (F && A.onLoadedObservable.remove(F), fe.UseFallbackTexture && this._createTextureBase(fe.FallbackTexture, t, A.invertY, s, r, null, a, o, h, l, A), ce = (ce || "Unknown error") + (fe.UseFallbackTexture ? " - Fallback texture was used" : ""), A.onErrorObservable.notifyObservers({ message: ce, exception: ie }), a && a(ce, ie)) : (O.Warn(`Failed to load ${e}, falling back to ${C}`), this._createTextureBase(C, t, A.invertY, s, r, n, a, o, h, l, A, d, f, _, E, m));
    };
    if (L) {
      const ce = (ie) => {
        L.loadData(ie, A, (ee, Ce, Ie, Be, Ue, ke) => {
          ke ? ue("TextureLoader failed to load data") : o(A, M, s, { width: ee, height: Ce }, A.invertY, !Ie, Be, () => (Ue(), !1), r);
        }, E);
      };
      l ? l instanceof ArrayBuffer ? ce(new Uint8Array(l)) : ArrayBuffer.isView(l) ? ce(l) : a && a("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null) : this._loadFile(e, (ie) => ce(new Uint8Array(ie)), void 0, s ? s.offlineProvider : void 0, !0, (ie, ee) => {
        ue("Unable to load " + (ie && ie.responseURL, ee));
      });
    } else {
      const ce = (ie) => {
        S && !this._doNotHandleContextLost && (A._buffer = ie), o(A, M, s, ie, A.invertY, t, !1, h, r);
      };
      !v || y ? l && (typeof l.decoding == "string" || l.close) ? ce(l) : le._FileToolsLoadImage(e, ce, ue, s ? s.offlineProvider : null, _, A.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : typeof l == "string" || l instanceof ArrayBuffer || ArrayBuffer.isView(l) || l instanceof Blob ? le._FileToolsLoadImage(l, ce, ue, s ? s.offlineProvider : null, _, A.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0) : l && ce(l);
    }
    return A;
  }
  createTexture(e, t, i, s, r = 3, n = null, a = null, o = null, h = null, l = null, u = null, d, f, _, E) {
    return this._createTextureBase(e, t, i, s, r, n, a, this._prepareWebGLTexture.bind(this), (m, v, S, y, A, C) => {
      const b = this._gl, M = S.width === m && S.height === v, L = l ? this._getInternalFormat(l, A._useSRGBBuffer) : y === ".jpg" && !A._useSRGBBuffer ? b.RGB : A._useSRGBBuffer ? b.SRGB8_ALPHA8 : b.RGBA;
      let k = l ? this._getInternalFormat(l) : y === ".jpg" && !A._useSRGBBuffer ? b.RGB : b.RGBA;
      if (A._useSRGBBuffer && this.webGLVersion === 1 && (k = L), M)
        return b.texImage2D(b.TEXTURE_2D, 0, L, k, b.UNSIGNED_BYTE, S), !1;
      const F = this._caps.maxTextureSize;
      if (S.width > F || S.height > F || !this._supportsHardwareTextureRescaling)
        return this._prepareWorkingCanvas(), !this._workingCanvas || !this._workingContext || (this._workingCanvas.width = m, this._workingCanvas.height = v, this._workingContext.drawImage(S, 0, 0, S.width, S.height, 0, 0, m, v), b.texImage2D(b.TEXTURE_2D, 0, L, k, b.UNSIGNED_BYTE, this._workingCanvas), A.width = m, A.height = v), !1;
      {
        const ue = new Vt(this, Oe.Temp);
        this._bindTextureDirectly(b.TEXTURE_2D, ue, !0), b.texImage2D(b.TEXTURE_2D, 0, L, k, b.UNSIGNED_BYTE, S), this._rescaleTexture(ue, A, s, L, () => {
          this._releaseTexture(ue), this._bindTextureDirectly(b.TEXTURE_2D, A, !0), C();
        });
      }
      return !0;
    }, o, h, l, u, d, f, E);
  }
  static _FileToolsLoadImage(e, t, i, s, r, n) {
    throw Q("FileTools");
  }
  _rescaleTexture(e, t, i, s, r) {
  }
  createRawTexture(e, t, i, s, r, n, a, o = null, h = 0, l = 0, u = !1) {
    throw Q("Engine.RawTexture");
  }
  createRawCubeTexture(e, t, i, s, r, n, a, o = null) {
    throw Q("Engine.RawTexture");
  }
  createRawTexture3D(e, t, i, s, r, n, a, o, h = null, l = 0) {
    throw Q("Engine.RawTexture");
  }
  createRawTexture2DArray(e, t, i, s, r, n, a, o, h = null, l = 0) {
    throw Q("Engine.RawTexture");
  }
  _unpackFlipY(e) {
    this._unpackFlipYCached !== e && (this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, e ? 1 : 0), this.enableUnpackFlipYCached && (this._unpackFlipYCached = e));
  }
  _getUnpackAlignement() {
    return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
  }
  _getTextureTarget(e) {
    return e.isCube ? this._gl.TEXTURE_CUBE_MAP : e.is3D ? this._gl.TEXTURE_3D : e.is2DArray || e.isMultiview ? this._gl.TEXTURE_2D_ARRAY : this._gl.TEXTURE_2D;
  }
  updateTextureSamplingMode(e, t, i = !1) {
    const s = this._getTextureTarget(t), r = this._getSamplingParameters(e, t.generateMipMaps || i);
    this._setTextureParameterInteger(s, this._gl.TEXTURE_MAG_FILTER, r.mag, t), this._setTextureParameterInteger(s, this._gl.TEXTURE_MIN_FILTER, r.min), i && (t.generateMipMaps = !0, this._gl.generateMipmap(s)), this._bindTextureDirectly(s, null), t.samplingMode = e;
  }
  updateTextureDimensions(e, t, i, s = 1) {
  }
  updateTextureWrappingMode(e, t, i = null, s = null) {
    const r = this._getTextureTarget(e);
    t !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t), e), e._cachedWrapU = t), i !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(i), e), e._cachedWrapV = i), (e.is2DArray || e.is3D) && s !== null && (this._setTextureParameterInteger(r, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(s), e), e._cachedWrapR = s), this._bindTextureDirectly(r, null);
  }
  _setupDepthStencilTexture(e, t, i, s, r, n = 1) {
    const a = t.width || t, o = t.height || t, h = t.layers || 0;
    e.baseWidth = a, e.baseHeight = o, e.width = a, e.height = o, e.is2DArray = h > 0, e.depth = h, e.isReady = !0, e.samples = n, e.generateMipMaps = !1, e.samplingMode = s ? 2 : 1, e.type = 0, e._comparisonFunction = r;
    const l = this._gl, u = this._getTextureTarget(e), d = this._getSamplingParameters(e.samplingMode, !1);
    l.texParameteri(u, l.TEXTURE_MAG_FILTER, d.mag), l.texParameteri(u, l.TEXTURE_MIN_FILTER, d.min), l.texParameteri(u, l.TEXTURE_WRAP_S, l.CLAMP_TO_EDGE), l.texParameteri(u, l.TEXTURE_WRAP_T, l.CLAMP_TO_EDGE), this.webGLVersion > 1 && (r === 0 ? (l.texParameteri(u, l.TEXTURE_COMPARE_FUNC, 515), l.texParameteri(u, l.TEXTURE_COMPARE_MODE, l.NONE)) : (l.texParameteri(u, l.TEXTURE_COMPARE_FUNC, r), l.texParameteri(u, l.TEXTURE_COMPARE_MODE, l.COMPARE_REF_TO_TEXTURE)));
  }
  _uploadCompressedDataToTextureDirectly(e, t, i, s, r, n = 0, a = 0) {
    const o = this._gl;
    let h = o.TEXTURE_2D;
    if (e.isCube && (h = o.TEXTURE_CUBE_MAP_POSITIVE_X + n), e._useSRGBBuffer)
      switch (t) {
        case 37492:
        case 36196:
          this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ETC2 : e._useSRGBBuffer = !1;
          break;
        case 37496:
          this._caps.etc2 ? t = o.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : e._useSRGBBuffer = !1;
          break;
        case 36492:
          t = o.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
          break;
        case 37808:
          t = o.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
          break;
        case 33776:
          this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
          break;
        case 33777:
          this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT : e._useSRGBBuffer = !1;
          break;
        case 33779:
          this._caps.s3tc_srgb ? t = o.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT : e._useSRGBBuffer = !1;
          break;
        default:
          e._useSRGBBuffer = !1;
          break;
      }
    this._gl.compressedTexImage2D(h, a, t, i, s, 0, r);
  }
  _uploadDataToTextureDirectly(e, t, i = 0, s = 0, r, n = !1) {
    const a = this._gl, o = this._getWebGLTextureType(e.type), h = this._getInternalFormat(e.format), l = r === void 0 ? this._getRGBABufferInternalSizedFormat(e.type, e.format, e._useSRGBBuffer) : this._getInternalFormat(r, e._useSRGBBuffer);
    this._unpackFlipY(e.invertY);
    let u = a.TEXTURE_2D;
    e.isCube && (u = a.TEXTURE_CUBE_MAP_POSITIVE_X + i);
    const d = Math.round(Math.log(e.width) * Math.LOG2E), f = Math.round(Math.log(e.height) * Math.LOG2E), _ = n ? e.width : Math.pow(2, Math.max(d - s, 0)), E = n ? e.height : Math.pow(2, Math.max(f - s, 0));
    a.texImage2D(u, s, l, _, E, 0, h, o, t);
  }
  updateTextureData(e, t, i, s, r, n, a = 0, o = 0, h = !1) {
    const l = this._gl, u = this._getWebGLTextureType(e.type), d = this._getInternalFormat(e.format);
    this._unpackFlipY(e.invertY);
    let f = l.TEXTURE_2D, _ = l.TEXTURE_2D;
    e.isCube && (_ = l.TEXTURE_CUBE_MAP_POSITIVE_X + a, f = l.TEXTURE_CUBE_MAP), this._bindTextureDirectly(f, e, !0), l.texSubImage2D(_, o, i, s, r, n, d, u, t), h && this._gl.generateMipmap(_), this._bindTextureDirectly(f, null);
  }
  _uploadArrayBufferViewToTexture(e, t, i = 0, s = 0) {
    const r = this._gl, n = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D;
    this._bindTextureDirectly(n, e, !0), this._uploadDataToTextureDirectly(e, t, i, s), this._bindTextureDirectly(n, null, !0);
  }
  _prepareWebGLTextureContinuation(e, t, i, s, r) {
    const n = this._gl;
    if (!n)
      return;
    const a = this._getSamplingParameters(r, !i);
    n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MAG_FILTER, a.mag), n.texParameteri(n.TEXTURE_2D, n.TEXTURE_MIN_FILTER, a.min), !i && !s && n.generateMipmap(n.TEXTURE_2D), this._bindTextureDirectly(n.TEXTURE_2D, null), t && t.removePendingData(e), e.onLoadedObservable.notifyObservers(e), e.onLoadedObservable.clear();
  }
  _prepareWebGLTexture(e, t, i, s, r, n, a, o, h = 3) {
    const l = this.getCaps().maxTextureSize, u = Math.min(l, this.needPOTTextures ? le.GetExponentOfTwo(s.width, l) : s.width), d = Math.min(l, this.needPOTTextures ? le.GetExponentOfTwo(s.height, l) : s.height), f = this._gl;
    if (!!f) {
      if (!e._hardwareTexture) {
        i && i.removePendingData(e);
        return;
      }
      this._bindTextureDirectly(f.TEXTURE_2D, e, !0), this._unpackFlipY(r === void 0 ? !0 : !!r), e.baseWidth = s.width, e.baseHeight = s.height, e.width = u, e.height = d, e.isReady = !0, !o(u, d, s, t, e, () => {
        this._prepareWebGLTextureContinuation(e, i, n, a, h);
      }) && this._prepareWebGLTextureContinuation(e, i, n, a, h);
    }
  }
  _setupFramebufferDepthAttachments(e, t, i, s, r = 1) {
    const n = this._gl;
    if (e && t)
      return this._createRenderBuffer(i, s, r, n.DEPTH_STENCIL, n.DEPTH24_STENCIL8, n.DEPTH_STENCIL_ATTACHMENT);
    if (t) {
      let a = n.DEPTH_COMPONENT16;
      return this._webGLVersion > 1 && (a = n.DEPTH_COMPONENT32F), this._createRenderBuffer(i, s, r, a, a, n.DEPTH_ATTACHMENT);
    }
    return e ? this._createRenderBuffer(i, s, r, n.STENCIL_INDEX8, n.STENCIL_INDEX8, n.STENCIL_ATTACHMENT) : null;
  }
  _createRenderBuffer(e, t, i, s, r, n, a = !0) {
    const h = this._gl.createRenderbuffer();
    return this._updateRenderBuffer(h, e, t, i, s, r, n, a);
  }
  _updateRenderBuffer(e, t, i, s, r, n, a, o = !0) {
    const h = this._gl;
    return h.bindRenderbuffer(h.RENDERBUFFER, e), s > 1 && h.renderbufferStorageMultisample ? h.renderbufferStorageMultisample(h.RENDERBUFFER, s, n, t, i) : h.renderbufferStorage(h.RENDERBUFFER, r, t, i), h.framebufferRenderbuffer(h.FRAMEBUFFER, a, h.RENDERBUFFER, e), o && h.bindRenderbuffer(h.RENDERBUFFER, null), e;
  }
  _releaseTexture(e) {
    var t;
    this._deleteTexture((t = e._hardwareTexture) === null || t === void 0 ? void 0 : t.underlyingResource), this.unbindAllTextures();
    const i = this._internalTexturesCache.indexOf(e);
    i !== -1 && this._internalTexturesCache.splice(i, 1), e._lodTextureHigh && e._lodTextureHigh.dispose(), e._lodTextureMid && e._lodTextureMid.dispose(), e._lodTextureLow && e._lodTextureLow.dispose(), e._irradianceTexture && e._irradianceTexture.dispose();
  }
  _releaseRenderTargetWrapper(e) {
    const t = this._renderTargetWrapperCache.indexOf(e);
    t !== -1 && this._renderTargetWrapperCache.splice(t, 1);
  }
  _deleteTexture(e) {
    e && this._gl.deleteTexture(e);
  }
  _setProgram(e) {
    this._currentProgram !== e && (this._gl.useProgram(e), this._currentProgram = e);
  }
  bindSamplers(e) {
    const t = e.getPipelineContext();
    this._setProgram(t.program);
    const i = e.getSamplers();
    for (let s = 0; s < i.length; s++) {
      const r = e.getUniform(i[s]);
      r && (this._boundUniforms[s] = r);
    }
    this._currentEffect = null;
  }
  _activateCurrentTexture() {
    this._currentTextureChannel !== this._activeChannel && (this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel), this._currentTextureChannel = this._activeChannel);
  }
  _bindTextureDirectly(e, t, i = !1, s = !1) {
    var r, n;
    let a = !1;
    const o = t && t._associatedChannel > -1;
    if (i && o && (this._activeChannel = t._associatedChannel), this._boundTexturesCache[this._activeChannel] !== t || s) {
      if (this._activateCurrentTexture(), t && t.isMultiview)
        throw console.error(e, t), "_bindTextureDirectly called with a multiview texture!";
      this._gl.bindTexture(e, (n = (r = t == null ? void 0 : t._hardwareTexture) === null || r === void 0 ? void 0 : r.underlyingResource) !== null && n !== void 0 ? n : null), this._boundTexturesCache[this._activeChannel] = t, t && (t._associatedChannel = this._activeChannel);
    } else
      i && (a = !0, this._activateCurrentTexture());
    return o && !i && this._bindSamplerUniformToChannel(t._associatedChannel, this._activeChannel), a;
  }
  _bindTexture(e, t, i) {
    if (e === void 0)
      return;
    t && (t._associatedChannel = e), this._activeChannel = e;
    const s = t ? this._getTextureTarget(t) : this._gl.TEXTURE_2D;
    this._bindTextureDirectly(s, t);
  }
  unbindAllTextures() {
    for (let e = 0; e < this._maxSimultaneousTextures; e++)
      this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null));
  }
  setTexture(e, t, i, s) {
    e !== void 0 && (t && (this._boundUniforms[e] = t), this._setTexture(e, i));
  }
  _bindSamplerUniformToChannel(e, t) {
    const i = this._boundUniforms[e];
    !i || i._currentState === t || (this._gl.uniform1i(i, t), i._currentState = t);
  }
  _getTextureWrapMode(e) {
    switch (e) {
      case 1:
        return this._gl.REPEAT;
      case 0:
        return this._gl.CLAMP_TO_EDGE;
      case 2:
        return this._gl.MIRRORED_REPEAT;
    }
    return this._gl.REPEAT;
  }
  _setTexture(e, t, i = !1, s = !1, r = "") {
    if (!t)
      return this._boundTexturesCache[e] != null && (this._activeChannel = e, this._bindTextureDirectly(this._gl.TEXTURE_2D, null), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null), this.webGLVersion > 1 && (this._bindTextureDirectly(this._gl.TEXTURE_3D, null), this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null))), !1;
    if (t.video)
      this._activeChannel = e, t.update();
    else if (t.delayLoadState === 4)
      return t.delayLoad(), !1;
    let n;
    s ? n = t.depthStencilTexture : t.isReady() ? n = t.getInternalTexture() : t.isCube ? n = this.emptyCubeTexture : t.is3D ? n = this.emptyTexture3D : t.is2DArray ? n = this.emptyTexture2DArray : n = this.emptyTexture, !i && n && (n._associatedChannel = e);
    let a = !0;
    this._boundTexturesCache[e] === n && (i || this._bindSamplerUniformToChannel(n._associatedChannel, e), a = !1), this._activeChannel = e;
    const o = this._getTextureTarget(n);
    if (a && this._bindTextureDirectly(o, n, i), n && !n.isMultiview) {
      if (n.isCube && n._cachedCoordinatesMode !== t.coordinatesMode) {
        n._cachedCoordinatesMode = t.coordinatesMode;
        const h = t.coordinatesMode !== 3 && t.coordinatesMode !== 5 ? 1 : 0;
        t.wrapU = h, t.wrapV = h;
      }
      n._cachedWrapU !== t.wrapU && (n._cachedWrapU = t.wrapU, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(t.wrapU), n)), n._cachedWrapV !== t.wrapV && (n._cachedWrapV = t.wrapV, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(t.wrapV), n)), n.is3D && n._cachedWrapR !== t.wrapR && (n._cachedWrapR = t.wrapR, this._setTextureParameterInteger(o, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(t.wrapR), n)), this._setAnisotropicLevel(o, n, t.anisotropicFilteringLevel);
    }
    return !0;
  }
  setTextureArray(e, t, i, s) {
    if (!(e === void 0 || !t)) {
      (!this._textureUnits || this._textureUnits.length !== i.length) && (this._textureUnits = new Int32Array(i.length));
      for (let r = 0; r < i.length; r++) {
        const n = i[r].getInternalTexture();
        n ? (this._textureUnits[r] = e + r, n._associatedChannel = e + r) : this._textureUnits[r] = -1;
      }
      this._gl.uniform1iv(t, this._textureUnits);
      for (let r = 0; r < i.length; r++)
        this._setTexture(this._textureUnits[r], i[r], !0);
    }
  }
  _setAnisotropicLevel(e, t, i) {
    const s = this._caps.textureAnisotropicFilterExtension;
    t.samplingMode !== 11 && t.samplingMode !== 3 && t.samplingMode !== 2 && (i = 1), s && t._cachedAnisotropicFilteringLevel !== i && (this._setTextureParameterFloat(e, s.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(i, this._caps.maxAnisotropy), t), t._cachedAnisotropicFilteringLevel = i);
  }
  _setTextureParameterFloat(e, t, i, s) {
    this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameterf(e, t, i);
  }
  _setTextureParameterInteger(e, t, i, s) {
    s && this._bindTextureDirectly(e, s, !0, !0), this._gl.texParameteri(e, t, i);
  }
  unbindAllAttributes() {
    if (this._mustWipeVertexAttributes) {
      this._mustWipeVertexAttributes = !1;
      for (let e = 0; e < this._caps.maxVertexAttribs; e++)
        this.disableAttributeByIndex(e);
      return;
    }
    for (let e = 0, t = this._vertexAttribArraysEnabled.length; e < t; e++)
      e >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[e] || this.disableAttributeByIndex(e);
  }
  releaseEffects() {
    for (const e in this._compiledEffects) {
      const t = this._compiledEffects[e].getPipelineContext();
      this._deletePipelineContext(t);
    }
    this._compiledEffects = {};
  }
  dispose() {
    var e;
    this.stopRenderLoop(), this.onBeforeTextureInitObservable && this.onBeforeTextureInitObservable.clear(), this._emptyTexture && (this._releaseTexture(this._emptyTexture), this._emptyTexture = null), this._emptyCubeTexture && (this._releaseTexture(this._emptyCubeTexture), this._emptyCubeTexture = null), this._dummyFramebuffer && this._gl.deleteFramebuffer(this._dummyFramebuffer), this.releaseEffects(), (e = this.releaseComputeEffects) === null || e === void 0 || e.call(this), this.unbindAllAttributes(), this._boundUniforms = {}, Ze() && this._renderingCanvas && (this._doNotHandleContextLost || (this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost), this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored)), window.removeEventListener("resize", this._checkForMobile)), this._workingCanvas = null, this._workingContext = null, this._currentBufferPointers.length = 0, this._renderingCanvas = null, this._currentProgram = null, this._boundRenderFunction = null, De.ResetCache();
    for (const t of this._activeRequests)
      t.abort();
    this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear();
  }
  attachContextLostEvent(e) {
    this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextlost", e, !1);
  }
  attachContextRestoredEvent(e) {
    this._renderingCanvas && this._renderingCanvas.addEventListener("webglcontextrestored", e, !1);
  }
  getError() {
    return this._gl.getError();
  }
  _canRenderToFloatFramebuffer() {
    return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(1);
  }
  _canRenderToHalfFloatFramebuffer() {
    return this._webGLVersion > 1 ? this._caps.colorBufferFloat : this._canRenderToFramebuffer(2);
  }
  _canRenderToFramebuffer(e) {
    const t = this._gl;
    for (; t.getError() !== t.NO_ERROR; )
      ;
    let i = !0;
    const s = t.createTexture();
    t.bindTexture(t.TEXTURE_2D, s), t.texImage2D(t.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(e), 1, 1, 0, t.RGBA, this._getWebGLTextureType(e), null), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, t.NEAREST);
    const r = t.createFramebuffer();
    t.bindFramebuffer(t.FRAMEBUFFER, r), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, s, 0);
    const n = t.checkFramebufferStatus(t.FRAMEBUFFER);
    if (i = i && n === t.FRAMEBUFFER_COMPLETE, i = i && t.getError() === t.NO_ERROR, i && (t.clear(t.COLOR_BUFFER_BIT), i = i && t.getError() === t.NO_ERROR), i) {
      t.bindFramebuffer(t.FRAMEBUFFER, null);
      const a = t.RGBA, o = t.UNSIGNED_BYTE, h = new Uint8Array(4);
      t.readPixels(0, 0, 1, 1, a, o, h), i = i && t.getError() === t.NO_ERROR;
    }
    for (t.deleteTexture(s), t.deleteFramebuffer(r), t.bindFramebuffer(t.FRAMEBUFFER, null); !i && t.getError() !== t.NO_ERROR; )
      ;
    return i;
  }
  _getWebGLTextureType(e) {
    if (this._webGLVersion === 1) {
      switch (e) {
        case 1:
          return this._gl.FLOAT;
        case 2:
          return this._gl.HALF_FLOAT_OES;
        case 0:
          return this._gl.UNSIGNED_BYTE;
        case 8:
          return this._gl.UNSIGNED_SHORT_4_4_4_4;
        case 9:
          return this._gl.UNSIGNED_SHORT_5_5_5_1;
        case 10:
          return this._gl.UNSIGNED_SHORT_5_6_5;
      }
      return this._gl.UNSIGNED_BYTE;
    }
    switch (e) {
      case 3:
        return this._gl.BYTE;
      case 0:
        return this._gl.UNSIGNED_BYTE;
      case 4:
        return this._gl.SHORT;
      case 5:
        return this._gl.UNSIGNED_SHORT;
      case 6:
        return this._gl.INT;
      case 7:
        return this._gl.UNSIGNED_INT;
      case 1:
        return this._gl.FLOAT;
      case 2:
        return this._gl.HALF_FLOAT;
      case 8:
        return this._gl.UNSIGNED_SHORT_4_4_4_4;
      case 9:
        return this._gl.UNSIGNED_SHORT_5_5_5_1;
      case 10:
        return this._gl.UNSIGNED_SHORT_5_6_5;
      case 11:
        return this._gl.UNSIGNED_INT_2_10_10_10_REV;
      case 12:
        return this._gl.UNSIGNED_INT_24_8;
      case 13:
        return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
      case 14:
        return this._gl.UNSIGNED_INT_5_9_9_9_REV;
      case 15:
        return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
    }
    return this._gl.UNSIGNED_BYTE;
  }
  _getInternalFormat(e, t = !1) {
    let i = t ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
    switch (e) {
      case 0:
        i = this._gl.ALPHA;
        break;
      case 1:
        i = this._gl.LUMINANCE;
        break;
      case 2:
        i = this._gl.LUMINANCE_ALPHA;
        break;
      case 6:
        i = this._gl.RED;
        break;
      case 7:
        i = this._gl.RG;
        break;
      case 4:
        i = t ? this._gl.SRGB : this._gl.RGB;
        break;
      case 5:
        i = t ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA;
        break;
    }
    if (this._webGLVersion > 1)
      switch (e) {
        case 8:
          i = this._gl.RED_INTEGER;
          break;
        case 9:
          i = this._gl.RG_INTEGER;
          break;
        case 10:
          i = this._gl.RGB_INTEGER;
          break;
        case 11:
          i = this._gl.RGBA_INTEGER;
          break;
      }
    return i;
  }
  _getRGBABufferInternalSizedFormat(e, t, i = !1) {
    if (this._webGLVersion === 1) {
      if (t !== void 0)
        switch (t) {
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          case 4:
            return i ? this._gl.SRGB : this._gl.RGB;
        }
      return this._gl.RGBA;
    }
    switch (e) {
      case 3:
        switch (t) {
          case 6:
            return this._gl.R8_SNORM;
          case 7:
            return this._gl.RG8_SNORM;
          case 4:
            return this._gl.RGB8_SNORM;
          case 8:
            return this._gl.R8I;
          case 9:
            return this._gl.RG8I;
          case 10:
            return this._gl.RGB8I;
          case 11:
            return this._gl.RGBA8I;
          default:
            return this._gl.RGBA8_SNORM;
        }
      case 0:
        switch (t) {
          case 6:
            return this._gl.R8;
          case 7:
            return this._gl.RG8;
          case 4:
            return i ? this._gl.SRGB8 : this._gl.RGB8;
          case 5:
            return i ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
          case 8:
            return this._gl.R8UI;
          case 9:
            return this._gl.RG8UI;
          case 10:
            return this._gl.RGB8UI;
          case 11:
            return this._gl.RGBA8UI;
          case 0:
            return this._gl.ALPHA;
          case 1:
            return this._gl.LUMINANCE;
          case 2:
            return this._gl.LUMINANCE_ALPHA;
          default:
            return this._gl.RGBA8;
        }
      case 4:
        switch (t) {
          case 8:
            return this._gl.R16I;
          case 9:
            return this._gl.RG16I;
          case 10:
            return this._gl.RGB16I;
          case 11:
            return this._gl.RGBA16I;
          default:
            return this._gl.RGBA16I;
        }
      case 5:
        switch (t) {
          case 8:
            return this._gl.R16UI;
          case 9:
            return this._gl.RG16UI;
          case 10:
            return this._gl.RGB16UI;
          case 11:
            return this._gl.RGBA16UI;
          default:
            return this._gl.RGBA16UI;
        }
      case 6:
        switch (t) {
          case 8:
            return this._gl.R32I;
          case 9:
            return this._gl.RG32I;
          case 10:
            return this._gl.RGB32I;
          case 11:
            return this._gl.RGBA32I;
          default:
            return this._gl.RGBA32I;
        }
      case 7:
        switch (t) {
          case 8:
            return this._gl.R32UI;
          case 9:
            return this._gl.RG32UI;
          case 10:
            return this._gl.RGB32UI;
          case 11:
            return this._gl.RGBA32UI;
          default:
            return this._gl.RGBA32UI;
        }
      case 1:
        switch (t) {
          case 6:
            return this._gl.R32F;
          case 7:
            return this._gl.RG32F;
          case 4:
            return this._gl.RGB32F;
          case 5:
            return this._gl.RGBA32F;
          default:
            return this._gl.RGBA32F;
        }
      case 2:
        switch (t) {
          case 6:
            return this._gl.R16F;
          case 7:
            return this._gl.RG16F;
          case 4:
            return this._gl.RGB16F;
          case 5:
            return this._gl.RGBA16F;
          default:
            return this._gl.RGBA16F;
        }
      case 10:
        return this._gl.RGB565;
      case 13:
        return this._gl.R11F_G11F_B10F;
      case 14:
        return this._gl.RGB9_E5;
      case 8:
        return this._gl.RGBA4;
      case 9:
        return this._gl.RGB5_A1;
      case 11:
        switch (t) {
          case 5:
            return this._gl.RGB10_A2;
          case 11:
            return this._gl.RGB10_A2UI;
          default:
            return this._gl.RGB10_A2;
        }
    }
    return i ? this._gl.SRGB8_ALPHA8 : this._gl.RGBA8;
  }
  _getRGBAMultiSampleBufferFormat(e) {
    return e === 1 ? this._gl.RGBA32F : e === 2 ? this._gl.RGBA16F : this._gl.RGBA8;
  }
  _loadFile(e, t, i, s, r, n) {
    const a = le._FileToolsLoadFile(e, t, i, s, r, n);
    return this._activeRequests.push(a), a.onCompleteObservable.add((o) => {
      this._activeRequests.splice(this._activeRequests.indexOf(o), 1);
    }), a;
  }
  static _FileToolsLoadFile(e, t, i, s, r, n) {
    throw Q("FileTools");
  }
  readPixels(e, t, i, s, r = !0, n = !0) {
    const a = r ? 4 : 3, o = r ? this._gl.RGBA : this._gl.RGB, h = new Uint8Array(s * i * a);
    return n && this.flushFramebuffer(), this._gl.readPixels(e, t, i, s, o, this._gl.UNSIGNED_BYTE, h), Promise.resolve(h);
  }
  static get IsSupportedAsync() {
    return Promise.resolve(this.isSupported());
  }
  static get IsSupported() {
    return this.isSupported();
  }
  static isSupported() {
    if (this._HasMajorPerformanceCaveat !== null)
      return !this._HasMajorPerformanceCaveat;
    if (this._IsSupported === null)
      try {
        const e = this._CreateCanvas(1, 1), t = e.getContext("webgl") || e.getContext("experimental-webgl");
        this._IsSupported = t != null && !!window.WebGLRenderingContext;
      } catch {
        this._IsSupported = !1;
      }
    return this._IsSupported;
  }
  static get HasMajorPerformanceCaveat() {
    if (this._HasMajorPerformanceCaveat === null)
      try {
        const e = this._CreateCanvas(1, 1), t = e.getContext("webgl", { failIfMajorPerformanceCaveat: !0 }) || e.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: !0 });
        this._HasMajorPerformanceCaveat = !t;
      } catch {
        this._HasMajorPerformanceCaveat = !1;
      }
    return this._HasMajorPerformanceCaveat;
  }
  static CeilingPOT(e) {
    return e--, e |= e >> 1, e |= e >> 2, e |= e >> 4, e |= e >> 8, e |= e >> 16, e++, e;
  }
  static FloorPOT(e) {
    return e = e | e >> 1, e = e | e >> 2, e = e | e >> 4, e = e | e >> 8, e = e | e >> 16, e - (e >> 1);
  }
  static NearestPOT(e) {
    const t = le.CeilingPOT(e), i = le.FloorPOT(e);
    return t - e > e - i ? i : t;
  }
  static GetExponentOfTwo(e, t, i = 2) {
    let s;
    switch (i) {
      case 1:
        s = le.FloorPOT(e);
        break;
      case 2:
        s = le.NearestPOT(e);
        break;
      case 3:
      default:
        s = le.CeilingPOT(e);
        break;
    }
    return Math.min(s, t);
  }
  static QueueNewFrame(e, t) {
    if (Ze()) {
      const { requestPostAnimationFrame: i, requestAnimationFrame: s } = t || window;
      if (typeof i == "function")
        return i(e);
      if (typeof s == "function")
        return s(e);
    } else if (typeof requestAnimationFrame == "function")
      return requestAnimationFrame(e);
    return setTimeout(e, 16);
  }
  getHostDocument() {
    return this._renderingCanvas && this._renderingCanvas.ownerDocument ? this._renderingCanvas.ownerDocument : Di() ? document : null;
  }
}
le.ExceptionList = [
  { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
  { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
  { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
  { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
  { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
];
le._TextureLoaders = [];
le.CollisionsEpsilon = 1e-3;
le._IsSupported = null;
le._HasMajorPerformanceCaveat = null;
class gn {
  constructor(e = 30) {
    this._enabled = !0, this._rollingFrameTime = new pn(e);
  }
  sampleFrame(e = ai.Now) {
    if (!!this._enabled) {
      if (this._lastFrameTimeMs != null) {
        const t = e - this._lastFrameTimeMs;
        this._rollingFrameTime.add(t);
      }
      this._lastFrameTimeMs = e;
    }
  }
  get averageFrameTime() {
    return this._rollingFrameTime.average;
  }
  get averageFrameTimeVariance() {
    return this._rollingFrameTime.variance;
  }
  get instantaneousFrameTime() {
    return this._rollingFrameTime.history(0);
  }
  get averageFPS() {
    return 1e3 / this._rollingFrameTime.average;
  }
  get instantaneousFPS() {
    const e = this._rollingFrameTime.history(0);
    return e === 0 ? 0 : 1e3 / e;
  }
  get isSaturated() {
    return this._rollingFrameTime.isSaturated();
  }
  enable() {
    this._enabled = !0;
  }
  disable() {
    this._enabled = !1, this._lastFrameTimeMs = null;
  }
  get isEnabled() {
    return this._enabled;
  }
  reset() {
    this._lastFrameTimeMs = null, this._rollingFrameTime.reset();
  }
}
class pn {
  constructor(e) {
    this._samples = new Array(e), this.reset();
  }
  add(e) {
    let t;
    if (this.isSaturated()) {
      const i = this._samples[this._pos];
      t = i - this.average, this.average -= t / (this._sampleCount - 1), this._m2 -= t * (i - this.average);
    } else
      this._sampleCount++;
    t = e - this.average, this.average += t / this._sampleCount, this._m2 += t * (e - this.average), this.variance = this._m2 / (this._sampleCount - 1), this._samples[this._pos] = e, this._pos++, this._pos %= this._samples.length;
  }
  history(e) {
    if (e >= this._sampleCount || e >= this._samples.length)
      return 0;
    const t = this._wrapPosition(this._pos - 1);
    return this._samples[this._wrapPosition(t - e)];
  }
  isSaturated() {
    return this._sampleCount >= this._samples.length;
  }
  reset() {
    this.average = 0, this.variance = 0, this._sampleCount = 0, this._pos = 0, this._m2 = 0;
  }
  _wrapPosition(e) {
    const t = this._samples.length;
    return (e % t + t) % t;
  }
}
class yt {
  constructor() {
    this._startMonitoringTime = 0, this._min = 0, this._max = 0, this._average = 0, this._lastSecAverage = 0, this._current = 0, this._totalValueCount = 0, this._totalAccumulated = 0, this._lastSecAccumulated = 0, this._lastSecTime = 0, this._lastSecValueCount = 0;
  }
  get min() {
    return this._min;
  }
  get max() {
    return this._max;
  }
  get average() {
    return this._average;
  }
  get lastSecAverage() {
    return this._lastSecAverage;
  }
  get current() {
    return this._current;
  }
  get total() {
    return this._totalAccumulated;
  }
  get count() {
    return this._totalValueCount;
  }
  fetchNewFrame() {
    this._totalValueCount++, this._current = 0, this._lastSecValueCount++;
  }
  addCount(e, t) {
    !yt.Enabled || (this._current += e, t && this._fetchResult());
  }
  beginMonitoring() {
    !yt.Enabled || (this._startMonitoringTime = ai.Now);
  }
  endMonitoring(e = !0) {
    if (!yt.Enabled)
      return;
    e && this.fetchNewFrame();
    const t = ai.Now;
    this._current = t - this._startMonitoringTime, e && this._fetchResult();
  }
  _fetchResult() {
    this._totalAccumulated += this._current, this._lastSecAccumulated += this._current, this._min = Math.min(this._min, this._current), this._max = Math.max(this._max, this._current), this._average = this._totalAccumulated / this._totalValueCount;
    const e = ai.Now;
    e - this._lastSecTime > 1e3 && (this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount, this._lastSecTime = e, this._lastSecAccumulated = 0, this._lastSecValueCount = 0);
  }
}
yt.Enabled = !0;
le.prototype.setAlphaConstants = function(c, e, t, i) {
  this._alphaState.setAlphaBlendConstants(c, e, t, i);
};
le.prototype.setAlphaMode = function(c, e = !1) {
  if (this._alphaMode !== c) {
    switch (c) {
      case 0:
        this._alphaState.alphaBlend = !1;
        break;
      case 7:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 8:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 2:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 6:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 1:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 3:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 4:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 5:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 9:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 10:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 11:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 12:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO), this._alphaState.alphaBlend = !0;
        break;
      case 13:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 14:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
      case 15:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO), this._alphaState.alphaBlend = !0;
        break;
      case 16:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE), this._alphaState.alphaBlend = !0;
        break;
      case 17:
        this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA), this._alphaState.alphaBlend = !0;
        break;
    }
    e || (this.depthCullingState.depthMask = c === 0), this._alphaMode = c;
  }
};
le.prototype.getAlphaMode = function() {
  return this._alphaMode;
};
le.prototype.setAlphaEquation = function(c) {
  if (this._alphaEquation !== c) {
    switch (c) {
      case 0:
        this._alphaState.setAlphaEquationParameters(32774, 32774);
        break;
      case 1:
        this._alphaState.setAlphaEquationParameters(32778, 32778);
        break;
      case 2:
        this._alphaState.setAlphaEquationParameters(32779, 32779);
        break;
      case 3:
        this._alphaState.setAlphaEquationParameters(32776, 32776);
        break;
      case 4:
        this._alphaState.setAlphaEquationParameters(32775, 32775);
        break;
      case 5:
        this._alphaState.setAlphaEquationParameters(32775, 32774);
        break;
    }
    this._alphaEquation = c;
  }
};
le.prototype.getAlphaEquation = function() {
  return this._alphaEquation;
};
function mn(c, e, t = !1, i) {
  switch (c) {
    case 3: {
      const r = e instanceof ArrayBuffer ? new Int8Array(e) : new Int8Array(e);
      return i && r.set(new Int8Array(i)), r;
    }
    case 0: {
      const r = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e);
      return i && r.set(new Uint8Array(i)), r;
    }
    case 4: {
      const r = e instanceof ArrayBuffer ? new Int16Array(e) : new Int16Array(t ? e / 2 : e);
      return i && r.set(new Int16Array(i)), r;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      const r = e instanceof ArrayBuffer ? new Uint16Array(e) : new Uint16Array(t ? e / 2 : e);
      return i && r.set(new Uint16Array(i)), r;
    }
    case 6: {
      const r = e instanceof ArrayBuffer ? new Int32Array(e) : new Int32Array(t ? e / 4 : e);
      return i && r.set(new Int32Array(i)), r;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      const r = e instanceof ArrayBuffer ? new Uint32Array(e) : new Uint32Array(t ? e / 4 : e);
      return i && r.set(new Uint32Array(i)), r;
    }
    case 1: {
      const r = e instanceof ArrayBuffer ? new Float32Array(e) : new Float32Array(t ? e / 4 : e);
      return i && r.set(new Float32Array(i)), r;
    }
  }
  const s = e instanceof ArrayBuffer ? new Uint8Array(e) : new Uint8Array(e);
  return i && s.set(new Uint8Array(i)), s;
}
le.prototype._readTexturePixelsSync = function(c, e, t, i = -1, s = 0, r = null, n = !0, a = !1, o = 0, h = 0) {
  var l, u;
  const d = this._gl;
  if (!d)
    throw new Error("Engine does not have gl rendering context.");
  if (!this._dummyFramebuffer) {
    const _ = d.createFramebuffer();
    if (!_)
      throw new Error("Unable to create dummy framebuffer");
    this._dummyFramebuffer = _;
  }
  d.bindFramebuffer(d.FRAMEBUFFER, this._dummyFramebuffer), i > -1 ? d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_CUBE_MAP_POSITIVE_X + i, (l = c._hardwareTexture) === null || l === void 0 ? void 0 : l.underlyingResource, s) : d.framebufferTexture2D(d.FRAMEBUFFER, d.COLOR_ATTACHMENT0, d.TEXTURE_2D, (u = c._hardwareTexture) === null || u === void 0 ? void 0 : u.underlyingResource, s);
  let f = c.type !== void 0 ? this._getWebGLTextureType(c.type) : d.UNSIGNED_BYTE;
  if (a)
    r || (r = mn(c.type, 4 * e * t));
  else
    switch (f) {
      case d.UNSIGNED_BYTE:
        r || (r = new Uint8Array(4 * e * t)), f = d.UNSIGNED_BYTE;
        break;
      default:
        r || (r = new Float32Array(4 * e * t)), f = d.FLOAT;
        break;
    }
  return n && this.flushFramebuffer(), d.readPixels(o, h, e, t, d.RGBA, f, r), d.bindFramebuffer(d.FRAMEBUFFER, this._currentFramebuffer), r;
};
le.prototype._readTexturePixels = function(c, e, t, i = -1, s = 0, r = null, n = !0, a = !1, o = 0, h = 0) {
  return Promise.resolve(this._readTexturePixelsSync(c, e, t, i, s, r, n, a, o, h));
};
le.prototype.updateDynamicIndexBuffer = function(c, e, t = 0) {
  this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null, this.bindIndexBuffer(c);
  let i;
  c.is32Bits ? i = e instanceof Uint32Array ? e : new Uint32Array(e) : i = e instanceof Uint16Array ? e : new Uint16Array(e), this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, i, this._gl.DYNAMIC_DRAW), this._resetIndexBufferBinding();
};
le.prototype.updateDynamicVertexBuffer = function(c, e, t, i) {
  this.bindArrayBuffer(c), t === void 0 && (t = 0);
  const s = e.byteLength || e.length;
  i === void 0 || i >= s && t === 0 ? e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, new Float32Array(e)) : this._gl.bufferSubData(this._gl.ARRAY_BUFFER, t, e) : e instanceof Array ? this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(e).subarray(t, t + i)) : (e instanceof ArrayBuffer ? e = new Uint8Array(e, t, i) : e = new Uint8Array(e.buffer, e.byteOffset + t, i), this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, e)), this._resetVertexBufferBinding();
};
class I extends le {
  constructor(e, t, i, s = !1) {
    if (super(e, t, i, s), this.enableOfflineSupport = !1, this.disableManifestCheck = !1, this.disableContextMenu = !0, this.scenes = new Array(), this._virtualScenes = new Array(), this.onNewSceneAddedObservable = new w(), this.postProcesses = new Array(), this.isPointerLock = !1, this.onResizeObservable = new w(), this.onCanvasBlurObservable = new w(), this.onCanvasFocusObservable = new w(), this.onCanvasPointerOutObservable = new w(), this.onBeginFrameObservable = new w(), this.customAnimationFrameRequester = null, this.onEndFrameObservable = new w(), this.onBeforeShaderCompilationObservable = new w(), this.onAfterShaderCompilationObservable = new w(), this._deterministicLockstep = !1, this._lockstepMaxSteps = 4, this._timeStep = 1 / 60, this._fps = 60, this._deltaTime = 0, this._drawCalls = new yt(), this.canvasTabIndex = 1, this.disablePerformanceMonitorInBackground = !1, this._performanceMonitor = new gn(), this._compatibilityMode = !0, this.currentRenderPassId = 0, this._renderPassNames = ["main"], I.Instances.push(this), !!e) {
      if (this._features.supportRenderPasses = !0, i = this._creationOptions, e.getContext) {
        const r = e;
        this._sharedInit(r, !!i.doNotHandleTouchAction, i.audioEngine), Di() && (this._onFullscreenChange = () => {
          this.isFullscreen = !!document.fullscreenElement, this.isFullscreen && this._pointerLockRequested && r && I._RequestPointerlock(r);
        }, document.addEventListener("fullscreenchange", this._onFullscreenChange, !1), document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, !1), this._onPointerLockChange = () => {
          this.isPointerLock = document.pointerLockElement === r;
        }, document.addEventListener("pointerlockchange", this._onPointerLockChange, !1), document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, !1), !I.audioEngine && i.audioEngine && I.AudioEngineFactory && (I.audioEngine = I.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination()))), this._connectVREvents(), this.enableOfflineSupport = I.OfflineProviderFactory !== void 0, this._deterministicLockstep = !!i.deterministicLockstep, this._lockstepMaxSteps = i.lockstepMaxSteps || 0, this._timeStep = i.timeStep || 1 / 60;
      }
      this._prepareVRComponent(), i.autoEnableWebVR && this.initWebVR();
    }
  }
  static get NpmPackage() {
    return le.NpmPackage;
  }
  static get Version() {
    return le.Version;
  }
  static get Instances() {
    return fe.Instances;
  }
  static get LastCreatedEngine() {
    return fe.LastCreatedEngine;
  }
  static get LastCreatedScene() {
    return fe.LastCreatedScene;
  }
  _createImageBitmapFromSource(e, t) {
    return new Promise((s, r) => {
      const n = new Image();
      n.onload = () => {
        n.decode().then(() => {
          this.createImageBitmap(n, t).then((a) => {
            s(a);
          });
        });
      }, n.onerror = () => {
        r(`Error loading image ${n.src}`);
      }, n.src = e;
    });
  }
  createImageBitmap(e, t) {
    return createImageBitmap(e, t);
  }
  resizeImageBitmap(e, t, i) {
    const r = this.createCanvas(t, i).getContext("2d");
    if (!r)
      throw new Error("Unable to get 2d context for resizeImageBitmap");
    return r.drawImage(e, 0, 0), r.getImageData(0, 0, t, i).data;
  }
  static MarkAllMaterialsAsDirty(e, t) {
    for (let i = 0; i < I.Instances.length; i++) {
      const s = I.Instances[i];
      for (let r = 0; r < s.scenes.length; r++)
        s.scenes[r].markAllMaterialsAsDirty(e, t);
    }
  }
  static DefaultLoadingScreenFactory(e) {
    throw Q("LoadingScreen");
  }
  get _supportsHardwareTextureRescaling() {
    return !!I._RescalePostProcessFactory;
  }
  get performanceMonitor() {
    return this._performanceMonitor;
  }
  get compatibilityMode() {
    return this._compatibilityMode;
  }
  set compatibilityMode(e) {
    this._compatibilityMode = !0;
  }
  getInputElement() {
    return this._renderingCanvas;
  }
  _initGLContext() {
    super._initGLContext(), this._rescalePostProcess = null;
  }
  _sharedInit(e, t, i) {
    super._sharedInit(e, t, i), this._onCanvasFocus = () => {
      this.onCanvasFocusObservable.notifyObservers(this);
    }, this._onCanvasBlur = () => {
      this.onCanvasBlurObservable.notifyObservers(this);
    }, this._onCanvasContextMenu = (r) => {
      this.disableContextMenu && r.preventDefault();
    }, e.addEventListener("focus", this._onCanvasFocus), e.addEventListener("blur", this._onCanvasBlur), e.addEventListener("contextmenu", this._onCanvasContextMenu), this._onBlur = () => {
      this.disablePerformanceMonitorInBackground && this._performanceMonitor.disable(), this._windowIsBackground = !0;
    }, this._onFocus = () => {
      this.disablePerformanceMonitorInBackground && this._performanceMonitor.enable(), this._windowIsBackground = !1;
    }, this._onCanvasPointerOut = (r) => {
      document.elementFromPoint(r.clientX, r.clientY) !== e && this.onCanvasPointerOutObservable.notifyObservers(r);
    };
    const s = this.getHostWindow();
    s && typeof s.addEventListener == "function" && (s.addEventListener("blur", this._onBlur), s.addEventListener("focus", this._onFocus)), e.addEventListener("pointerout", this._onCanvasPointerOut), t || this._disableTouchAction(), !I.audioEngine && i && I.AudioEngineFactory && (I.audioEngine = I.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination()));
  }
  getAspectRatio(e, t = !1) {
    const i = e.viewport;
    return this.getRenderWidth(t) * i.width / (this.getRenderHeight(t) * i.height);
  }
  getScreenAspectRatio() {
    return this.getRenderWidth(!0) / this.getRenderHeight(!0);
  }
  getRenderingCanvasClientRect() {
    return this._renderingCanvas ? this._renderingCanvas.getBoundingClientRect() : null;
  }
  getInputElementClientRect() {
    return this._renderingCanvas ? this.getInputElement().getBoundingClientRect() : null;
  }
  isDeterministicLockStep() {
    return this._deterministicLockstep;
  }
  getLockstepMaxSteps() {
    return this._lockstepMaxSteps;
  }
  getTimeStep() {
    return this._timeStep * 1e3;
  }
  generateMipMapsForCubemap(e, t = !0) {
    if (e.generateMipMaps) {
      const i = this._gl;
      this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, e, !0), i.generateMipmap(i.TEXTURE_CUBE_MAP), t && this._bindTextureDirectly(i.TEXTURE_CUBE_MAP, null);
    }
  }
  getDepthWrite() {
    return this._depthCullingState.depthMask;
  }
  setDepthWrite(e) {
    this._depthCullingState.depthMask = e;
  }
  getStencilBuffer() {
    return this._stencilState.stencilTest;
  }
  setStencilBuffer(e) {
    this._stencilState.stencilTest = e;
  }
  getStencilMask() {
    return this._stencilState.stencilMask;
  }
  setStencilMask(e) {
    this._stencilState.stencilMask = e;
  }
  getStencilFunction() {
    return this._stencilState.stencilFunc;
  }
  getStencilFunctionReference() {
    return this._stencilState.stencilFuncRef;
  }
  getStencilFunctionMask() {
    return this._stencilState.stencilFuncMask;
  }
  setStencilFunction(e) {
    this._stencilState.stencilFunc = e;
  }
  setStencilFunctionReference(e) {
    this._stencilState.stencilFuncRef = e;
  }
  setStencilFunctionMask(e) {
    this._stencilState.stencilFuncMask = e;
  }
  getStencilOperationFail() {
    return this._stencilState.stencilOpStencilFail;
  }
  getStencilOperationDepthFail() {
    return this._stencilState.stencilOpDepthFail;
  }
  getStencilOperationPass() {
    return this._stencilState.stencilOpStencilDepthPass;
  }
  setStencilOperationFail(e) {
    this._stencilState.stencilOpStencilFail = e;
  }
  setStencilOperationDepthFail(e) {
    this._stencilState.stencilOpDepthFail = e;
  }
  setStencilOperationPass(e) {
    this._stencilState.stencilOpStencilDepthPass = e;
  }
  setDitheringState(e) {
    e ? this._gl.enable(this._gl.DITHER) : this._gl.disable(this._gl.DITHER);
  }
  setRasterizerState(e) {
    e ? this._gl.disable(this._gl.RASTERIZER_DISCARD) : this._gl.enable(this._gl.RASTERIZER_DISCARD);
  }
  getDepthFunction() {
    return this._depthCullingState.depthFunc;
  }
  setDepthFunction(e) {
    this._depthCullingState.depthFunc = e;
  }
  setDepthFunctionToGreater() {
    this.setDepthFunction(516);
  }
  setDepthFunctionToGreaterOrEqual() {
    this.setDepthFunction(518);
  }
  setDepthFunctionToLess() {
    this.setDepthFunction(513);
  }
  setDepthFunctionToLessOrEqual() {
    this.setDepthFunction(515);
  }
  cacheStencilState() {
    this._cachedStencilBuffer = this.getStencilBuffer(), this._cachedStencilFunction = this.getStencilFunction(), this._cachedStencilMask = this.getStencilMask(), this._cachedStencilOperationPass = this.getStencilOperationPass(), this._cachedStencilOperationFail = this.getStencilOperationFail(), this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail(), this._cachedStencilReference = this.getStencilFunctionReference();
  }
  restoreStencilState() {
    this.setStencilFunction(this._cachedStencilFunction), this.setStencilMask(this._cachedStencilMask), this.setStencilBuffer(this._cachedStencilBuffer), this.setStencilOperationPass(this._cachedStencilOperationPass), this.setStencilOperationFail(this._cachedStencilOperationFail), this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail), this.setStencilFunctionReference(this._cachedStencilReference);
  }
  setDirectViewport(e, t, i, s) {
    const r = this._cachedViewport;
    return this._cachedViewport = null, this._viewport(e, t, i, s), r;
  }
  scissorClear(e, t, i, s, r) {
    this.enableScissor(e, t, i, s), this.clear(r, !0, !0, !0), this.disableScissor();
  }
  enableScissor(e, t, i, s) {
    const r = this._gl;
    r.enable(r.SCISSOR_TEST), r.scissor(e, t, i, s);
  }
  disableScissor() {
    const e = this._gl;
    e.disable(e.SCISSOR_TEST);
  }
  _reportDrawCall(e = 1) {
    this._drawCalls.addCount(e, !1);
  }
  initWebVR() {
    throw Q("WebVRCamera");
  }
  _prepareVRComponent() {
  }
  _connectVREvents(e, t) {
  }
  _submitVRFrame() {
  }
  disableVR() {
  }
  isVRPresenting() {
    return !1;
  }
  _requestVRFrame() {
  }
  _loadFileAsync(e, t, i) {
    return new Promise((s, r) => {
      this._loadFile(e, (n) => {
        s(n);
      }, void 0, t, i, (n, a) => {
        r(a);
      });
    });
  }
  getVertexShaderSource(e) {
    const t = this._gl.getAttachedShaders(e);
    return t ? this._gl.getShaderSource(t[0]) : null;
  }
  getFragmentShaderSource(e) {
    const t = this._gl.getAttachedShaders(e);
    return t ? this._gl.getShaderSource(t[1]) : null;
  }
  setDepthStencilTexture(e, t, i, s) {
    e !== void 0 && (t && (this._boundUniforms[e] = t), !i || !i.depthStencilTexture ? this._setTexture(e, null, void 0, void 0, s) : this._setTexture(e, i, !1, !0, s));
  }
  setTextureFromPostProcess(e, t, i) {
    var s;
    let r = null;
    t && (t._textures.data[t._currentRenderTextureInd] ? r = t._textures.data[t._currentRenderTextureInd] : t._forcedOutputTexture && (r = t._forcedOutputTexture)), this._bindTexture(e, (s = r == null ? void 0 : r.texture) !== null && s !== void 0 ? s : null, i);
  }
  setTextureFromPostProcessOutput(e, t, i) {
    var s, r;
    this._bindTexture(e, (r = (s = t == null ? void 0 : t._outputTexture) === null || s === void 0 ? void 0 : s.texture) !== null && r !== void 0 ? r : null, i);
  }
  _rebuildBuffers() {
    for (const e of this.scenes)
      e.resetCachedMaterial(), e._rebuildGeometries(), e._rebuildTextures();
    for (const e of this._virtualScenes)
      e.resetCachedMaterial(), e._rebuildGeometries(), e._rebuildTextures();
    super._rebuildBuffers();
  }
  _renderFrame() {
    for (let e = 0; e < this._activeRenderLoops.length; e++) {
      const t = this._activeRenderLoops[e];
      t();
    }
  }
  _renderLoop() {
    if (!this._contextWasLost) {
      let e = !0;
      !this.renderEvenInBackground && this._windowIsBackground && (e = !1), e && (this.beginFrame(), this._renderViews() || this._renderFrame(), this.endFrame());
    }
    this._activeRenderLoops.length > 0 ? this.customAnimationFrameRequester ? (this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester), this._frameHandler = this.customAnimationFrameRequester.requestID) : this.isVRPresenting() ? this._requestVRFrame() : this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow()) : this._renderingQueueLaunched = !1;
  }
  _renderViews() {
    return !1;
  }
  switchFullscreen(e) {
    this.isFullscreen ? this.exitFullscreen() : this.enterFullscreen(e);
  }
  enterFullscreen(e) {
    this.isFullscreen || (this._pointerLockRequested = e, this._renderingCanvas && I._RequestFullscreen(this._renderingCanvas));
  }
  exitFullscreen() {
    this.isFullscreen && I._ExitFullscreen();
  }
  enterPointerlock() {
    this._renderingCanvas && I._RequestPointerlock(this._renderingCanvas);
  }
  exitPointerlock() {
    I._ExitPointerlock();
  }
  beginFrame() {
    this._measureFps(), this.onBeginFrameObservable.notifyObservers(this), super.beginFrame();
  }
  endFrame() {
    super.endFrame(), this._submitVRFrame(), this.onEndFrameObservable.notifyObservers(this);
  }
  resize(e = !1) {
    this.isVRPresenting() || super.resize(e);
  }
  setSize(e, t, i = !1) {
    if (!this._renderingCanvas || !super.setSize(e, t, i))
      return !1;
    if (this.scenes) {
      for (let s = 0; s < this.scenes.length; s++) {
        const r = this.scenes[s];
        for (let n = 0; n < r.cameras.length; n++) {
          const a = r.cameras[n];
          a._currentRenderId = 0;
        }
      }
      this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this);
    }
    return !0;
  }
  _deletePipelineContext(e) {
    const t = e;
    t && t.program && t.transformFeedback && (this.deleteTransformFeedback(t.transformFeedback), t.transformFeedback = null), super._deletePipelineContext(e);
  }
  createShaderProgram(e, t, i, s, r, n = null) {
    r = r || this._gl, this.onBeforeShaderCompilationObservable.notifyObservers(this);
    const a = super.createShaderProgram(e, t, i, s, r, n);
    return this.onAfterShaderCompilationObservable.notifyObservers(this), a;
  }
  _createShaderProgram(e, t, i, s, r = null) {
    const n = s.createProgram();
    if (e.program = n, !n)
      throw new Error("Unable to create program");
    if (s.attachShader(n, t), s.attachShader(n, i), this.webGLVersion > 1 && r) {
      const a = this.createTransformFeedback();
      this.bindTransformFeedback(a), this.setTranformFeedbackVaryings(n, r), e.transformFeedback = a;
    }
    return s.linkProgram(n), this.webGLVersion > 1 && r && this.bindTransformFeedback(null), e.context = s, e.vertexShader = t, e.fragmentShader = i, e.isParallelCompiled || this._finalizePipelineContext(e), n;
  }
  _releaseTexture(e) {
    super._releaseTexture(e);
  }
  _releaseRenderTargetWrapper(e) {
    super._releaseRenderTargetWrapper(e), this.scenes.forEach((t) => {
      t.postProcesses.forEach((i) => {
        i._outputTexture === e && (i._outputTexture = null);
      }), t.cameras.forEach((i) => {
        i._postProcesses.forEach((s) => {
          s && s._outputTexture === e && (s._outputTexture = null);
        });
      });
    });
  }
  getRenderPassNames() {
    return this._renderPassNames;
  }
  getCurrentRenderPassName() {
    return this._renderPassNames[this.currentRenderPassId];
  }
  createRenderPassId(e) {
    const t = ++I._RenderPassIdCounter;
    return this._renderPassNames[t] = e != null ? e : "NONAME", t;
  }
  releaseRenderPassId(e) {
    this._renderPassNames[e] = void 0;
    for (let t = 0; t < this.scenes.length; ++t) {
      const i = this.scenes[t];
      for (let s = 0; s < i.meshes.length; ++s) {
        const r = i.meshes[s];
        if (r.subMeshes)
          for (let n = 0; n < r.subMeshes.length; ++n)
            r.subMeshes[n]._removeDrawWrapper(e);
      }
    }
  }
  _rescaleTexture(e, t, i, s, r) {
    this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE), this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
    const n = this.createRenderTargetTexture({
      width: t.width,
      height: t.height
    }, {
      generateMipMaps: !1,
      type: 0,
      samplingMode: 2,
      generateDepthBuffer: !1,
      generateStencilBuffer: !1
    });
    !this._rescalePostProcess && I._RescalePostProcessFactory && (this._rescalePostProcess = I._RescalePostProcessFactory(this)), this._rescalePostProcess && (this._rescalePostProcess.externalTextureSamplerBinding = !0, this._rescalePostProcess.getEffect().executeWhenCompiled(() => {
      this._rescalePostProcess.onApply = function(o) {
        o._bindTexture("textureSampler", e);
      };
      let a = i;
      a || (a = this.scenes[this.scenes.length - 1]), a.postProcessManager.directRender([this._rescalePostProcess], n, !0), this._bindTextureDirectly(this._gl.TEXTURE_2D, t, !0), this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, s, 0, 0, t.width, t.height, 0), this.unBindFramebuffer(n), n.dispose(), r && r();
    }));
  }
  getFps() {
    return this._fps;
  }
  getDeltaTime() {
    return this._deltaTime;
  }
  _measureFps() {
    this._performanceMonitor.sampleFrame(), this._fps = this._performanceMonitor.averageFPS, this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
  }
  wrapWebGLTexture(e) {
    const t = new Mr(e, this._gl), i = new Vt(this, Oe.Unknown, !0);
    return i._hardwareTexture = t, i.isReady = !0, i;
  }
  _uploadImageToTexture(e, t, i = 0, s = 0) {
    const r = this._gl, n = this._getWebGLTextureType(e.type), a = this._getInternalFormat(e.format), o = this._getRGBABufferInternalSizedFormat(e.type, a), h = e.isCube ? r.TEXTURE_CUBE_MAP : r.TEXTURE_2D;
    this._bindTextureDirectly(h, e, !0), this._unpackFlipY(e.invertY);
    let l = r.TEXTURE_2D;
    e.isCube && (l = r.TEXTURE_CUBE_MAP_POSITIVE_X + i), r.texImage2D(l, s, o, a, n, t), this._bindTextureDirectly(h, null, !0);
  }
  updateTextureComparisonFunction(e, t) {
    if (this.webGLVersion === 1) {
      O.Error("WebGL 1 does not support texture comparison.");
      return;
    }
    const i = this._gl;
    e.isCube ? (this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, e, !0), t === 0 ? (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_CUBE_MAP, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null)) : (this._bindTextureDirectly(this._gl.TEXTURE_2D, e, !0), t === 0 ? (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, 515), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.NONE)) : (i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_FUNC, t), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_COMPARE_MODE, i.COMPARE_REF_TO_TEXTURE)), this._bindTextureDirectly(this._gl.TEXTURE_2D, null)), e._comparisonFunction = t;
  }
  createInstancesBuffer(e) {
    const t = this._gl.createBuffer();
    if (!t)
      throw new Error("Unable to create instance buffer");
    const i = new Fi(t);
    return i.capacity = e, this.bindArrayBuffer(i), this._gl.bufferData(this._gl.ARRAY_BUFFER, e, this._gl.DYNAMIC_DRAW), i.references = 1, i;
  }
  deleteInstancesBuffer(e) {
    this._gl.deleteBuffer(e);
  }
  _clientWaitAsync(e, t = 0, i = 10) {
    const s = this._gl;
    return new Promise((r, n) => {
      const a = () => {
        const o = s.clientWaitSync(e, t, 0);
        if (o == s.WAIT_FAILED) {
          n();
          return;
        }
        if (o == s.TIMEOUT_EXPIRED) {
          setTimeout(a, i);
          return;
        }
        r();
      };
      a();
    });
  }
  _readPixelsAsync(e, t, i, s, r, n, a) {
    if (this._webGLVersion < 2)
      throw new Error("_readPixelsAsync only work on WebGL2+");
    const o = this._gl, h = o.createBuffer();
    o.bindBuffer(o.PIXEL_PACK_BUFFER, h), o.bufferData(o.PIXEL_PACK_BUFFER, a.byteLength, o.STREAM_READ), o.readPixels(e, t, i, s, r, n, 0), o.bindBuffer(o.PIXEL_PACK_BUFFER, null);
    const l = o.fenceSync(o.SYNC_GPU_COMMANDS_COMPLETE, 0);
    return l ? (o.flush(), this._clientWaitAsync(l, 0, 10).then(() => (o.deleteSync(l), o.bindBuffer(o.PIXEL_PACK_BUFFER, h), o.getBufferSubData(o.PIXEL_PACK_BUFFER, 0, a), o.bindBuffer(o.PIXEL_PACK_BUFFER, null), o.deleteBuffer(h), a))) : null;
  }
  dispose() {
    for (this.hideLoadingUI(), this.onNewSceneAddedObservable.clear(); this.postProcesses.length; )
      this.postProcesses[0].dispose();
    for (this._rescalePostProcess && this._rescalePostProcess.dispose(); this.scenes.length; )
      this.scenes[0].dispose();
    for (; this._virtualScenes.length; )
      this._virtualScenes[0].dispose();
    I.Instances.length === 1 && I.audioEngine && (I.audioEngine.dispose(), I.audioEngine = null), this.disableVR();
    const e = this.getHostWindow();
    e && typeof e.removeEventListener == "function" && (e.removeEventListener("blur", this._onBlur), e.removeEventListener("focus", this._onFocus)), this._renderingCanvas && (this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus), this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur), this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut), this._renderingCanvas.removeEventListener("contextmenu", this._onCanvasContextMenu)), Di() && (document.removeEventListener("fullscreenchange", this._onFullscreenChange), document.removeEventListener("mozfullscreenchange", this._onFullscreenChange), document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange), document.removeEventListener("msfullscreenchange", this._onFullscreenChange), document.removeEventListener("pointerlockchange", this._onPointerLockChange), document.removeEventListener("mspointerlockchange", this._onPointerLockChange), document.removeEventListener("mozpointerlockchange", this._onPointerLockChange), document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange)), super.dispose();
    const t = I.Instances.indexOf(this);
    t >= 0 && I.Instances.splice(t, 1), this.onResizeObservable.clear(), this.onCanvasBlurObservable.clear(), this.onCanvasFocusObservable.clear(), this.onCanvasPointerOutObservable.clear(), this.onBeginFrameObservable.clear(), this.onEndFrameObservable.clear();
  }
  _disableTouchAction() {
    !this._renderingCanvas || !this._renderingCanvas.setAttribute || (this._renderingCanvas.setAttribute("touch-action", "none"), this._renderingCanvas.style.touchAction = "none", this._renderingCanvas.style.webkitTapHighlightColor = "transparent");
  }
  displayLoadingUI() {
    if (!Ze())
      return;
    const e = this.loadingScreen;
    e && e.displayLoadingUI();
  }
  hideLoadingUI() {
    if (!Ze())
      return;
    const e = this._loadingScreen;
    e && e.hideLoadingUI();
  }
  get loadingScreen() {
    return !this._loadingScreen && this._renderingCanvas && (this._loadingScreen = I.DefaultLoadingScreenFactory(this._renderingCanvas)), this._loadingScreen;
  }
  set loadingScreen(e) {
    this._loadingScreen = e;
  }
  set loadingUIText(e) {
    this.loadingScreen.loadingUIText = e;
  }
  set loadingUIBackgroundColor(e) {
    this.loadingScreen.loadingUIBackgroundColor = e;
  }
  createVideoElement(e) {
    return document.createElement("video");
  }
  static _RequestPointerlock(e) {
    e.requestPointerLock && (e.requestPointerLock(), e.focus());
  }
  static _ExitPointerlock() {
    document.exitPointerLock && document.exitPointerLock();
  }
  static _RequestFullscreen(e) {
    const t = e.requestFullscreen || e.webkitRequestFullscreen;
    !t || t.call(e);
  }
  static _ExitFullscreen() {
    const e = document;
    document.exitFullscreen ? document.exitFullscreen() : e.webkitCancelFullScreen && e.webkitCancelFullScreen();
  }
  getFontOffset(e) {
    const t = document.createElement("span");
    t.innerHTML = "Hg", t.setAttribute("style", `font: ${e} !important`);
    const i = document.createElement("div");
    i.style.display = "inline-block", i.style.width = "1px", i.style.height = "0px", i.style.verticalAlign = "bottom";
    const s = document.createElement("div");
    s.style.whiteSpace = "nowrap", s.appendChild(t), s.appendChild(i), document.body.appendChild(s);
    let r = 0, n = 0;
    try {
      n = i.getBoundingClientRect().top - t.getBoundingClientRect().top, i.style.verticalAlign = "baseline", r = i.getBoundingClientRect().top - t.getBoundingClientRect().top;
    } finally {
      document.body.removeChild(s);
    }
    return { ascent: r, height: n, descent: n - r };
  }
}
I.ALPHA_DISABLE = 0;
I.ALPHA_ADD = 1;
I.ALPHA_COMBINE = 2;
I.ALPHA_SUBTRACT = 3;
I.ALPHA_MULTIPLY = 4;
I.ALPHA_MAXIMIZED = 5;
I.ALPHA_ONEONE = 6;
I.ALPHA_PREMULTIPLIED = 7;
I.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
I.ALPHA_INTERPOLATE = 9;
I.ALPHA_SCREENMODE = 10;
I.DELAYLOADSTATE_NONE = 0;
I.DELAYLOADSTATE_LOADED = 1;
I.DELAYLOADSTATE_LOADING = 2;
I.DELAYLOADSTATE_NOTLOADED = 4;
I.NEVER = 512;
I.ALWAYS = 519;
I.LESS = 513;
I.EQUAL = 514;
I.LEQUAL = 515;
I.GREATER = 516;
I.GEQUAL = 518;
I.NOTEQUAL = 517;
I.KEEP = 7680;
I.REPLACE = 7681;
I.INCR = 7682;
I.DECR = 7683;
I.INVERT = 5386;
I.INCR_WRAP = 34055;
I.DECR_WRAP = 34056;
I.TEXTURE_CLAMP_ADDRESSMODE = 0;
I.TEXTURE_WRAP_ADDRESSMODE = 1;
I.TEXTURE_MIRROR_ADDRESSMODE = 2;
I.TEXTUREFORMAT_ALPHA = 0;
I.TEXTUREFORMAT_LUMINANCE = 1;
I.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
I.TEXTUREFORMAT_RGB = 4;
I.TEXTUREFORMAT_RGBA = 5;
I.TEXTUREFORMAT_RED = 6;
I.TEXTUREFORMAT_R = 6;
I.TEXTUREFORMAT_RG = 7;
I.TEXTUREFORMAT_RED_INTEGER = 8;
I.TEXTUREFORMAT_R_INTEGER = 8;
I.TEXTUREFORMAT_RG_INTEGER = 9;
I.TEXTUREFORMAT_RGB_INTEGER = 10;
I.TEXTUREFORMAT_RGBA_INTEGER = 11;
I.TEXTURETYPE_UNSIGNED_BYTE = 0;
I.TEXTURETYPE_UNSIGNED_INT = 0;
I.TEXTURETYPE_FLOAT = 1;
I.TEXTURETYPE_HALF_FLOAT = 2;
I.TEXTURETYPE_BYTE = 3;
I.TEXTURETYPE_SHORT = 4;
I.TEXTURETYPE_UNSIGNED_SHORT = 5;
I.TEXTURETYPE_INT = 6;
I.TEXTURETYPE_UNSIGNED_INTEGER = 7;
I.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
I.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
I.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
I.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
I.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
I.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
I.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
I.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
I.TEXTURE_NEAREST_SAMPLINGMODE = 1;
I.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
I.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
I.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
I.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
I.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
I.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
I.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
I.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
I.TEXTURE_NEAREST_LINEAR = 7;
I.TEXTURE_NEAREST_NEAREST = 1;
I.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
I.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
I.TEXTURE_LINEAR_LINEAR = 2;
I.TEXTURE_LINEAR_NEAREST = 12;
I.TEXTURE_EXPLICIT_MODE = 0;
I.TEXTURE_SPHERICAL_MODE = 1;
I.TEXTURE_PLANAR_MODE = 2;
I.TEXTURE_CUBIC_MODE = 3;
I.TEXTURE_PROJECTION_MODE = 4;
I.TEXTURE_SKYBOX_MODE = 5;
I.TEXTURE_INVCUBIC_MODE = 6;
I.TEXTURE_EQUIRECTANGULAR_MODE = 7;
I.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
I.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
I.SCALEMODE_FLOOR = 1;
I.SCALEMODE_NEAREST = 2;
I.SCALEMODE_CEILING = 3;
I._RescalePostProcessFactory = null;
I._RenderPassIdCounter = 0;
le.prototype._debugPushGroup = function(c, e) {
};
le.prototype._debugPopGroup = function(c) {
};
le.prototype._debugInsertMarker = function(c, e) {
};
le.prototype._debugFlushPendingCommands = function() {
};
function En(c) {
  return new I(c, !0, {
    preserveDrawingBuffer: !0,
    stencil: !0
  });
}
class se {
  constructor(e = 0, t = 0, i = 0) {
    this.r = e, this.g = t, this.b = i;
  }
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
  }
  getClassName() {
    return "Color3";
  }
  getHashCode() {
    let e = this.r * 255 | 0;
    return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e;
  }
  toArray(e, t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, this;
  }
  fromArray(e, t = 0) {
    return se.FromArrayToRef(e, t, this), this;
  }
  toColor4(e = 1) {
    return new ge(this.r, this.g, this.b, e);
  }
  asArray() {
    return [this.r, this.g, this.b];
  }
  toLuminance() {
    return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
  }
  multiply(e) {
    return new se(this.r * e.r, this.g * e.g, this.b * e.b);
  }
  multiplyToRef(e, t) {
    return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, this;
  }
  equals(e) {
    return e && this.r === e.r && this.g === e.g && this.b === e.b;
  }
  equalsFloats(e, t, i) {
    return this.r === e && this.g === t && this.b === i;
  }
  scale(e) {
    return new se(this.r * e, this.g * e, this.b * e);
  }
  scaleInPlace(e) {
    return this.r *= e, this.g *= e, this.b *= e, this;
  }
  scaleToRef(e, t) {
    return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, this;
  }
  clampToRef(e = 0, t = 1, i) {
    return i.r = ne.Clamp(this.r, e, t), i.g = ne.Clamp(this.g, e, t), i.b = ne.Clamp(this.b, e, t), this;
  }
  add(e) {
    return new se(this.r + e.r, this.g + e.g, this.b + e.b);
  }
  addToRef(e, t) {
    return t.r = this.r + e.r, t.g = this.g + e.g, t.b = this.b + e.b, this;
  }
  subtract(e) {
    return new se(this.r - e.r, this.g - e.g, this.b - e.b);
  }
  subtractToRef(e, t) {
    return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, this;
  }
  clone() {
    return new se(this.r, this.g, this.b);
  }
  copyFrom(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this;
  }
  copyFromFloats(e, t, i) {
    return this.r = e, this.g = t, this.b = i, this;
  }
  set(e, t, i) {
    return this.copyFromFloats(e, t, i);
  }
  toHexString() {
    const e = Math.round(this.r * 255), t = Math.round(this.g * 255), i = Math.round(this.b * 255);
    return "#" + ne.ToHex(e) + ne.ToHex(t) + ne.ToHex(i);
  }
  toLinearSpace() {
    const e = new se();
    return this.toLinearSpaceToRef(e), e;
  }
  toHSV() {
    const e = new se();
    return this.toHSVToRef(e), e;
  }
  toHSVToRef(e) {
    const t = this.r, i = this.g, s = this.b, r = Math.max(t, i, s), n = Math.min(t, i, s);
    let a = 0, o = 0;
    const h = r, l = r - n;
    r !== 0 && (o = l / r), r != n && (r == t ? (a = (i - s) / l, i < s && (a += 6)) : r == i ? a = (s - t) / l + 2 : r == s && (a = (t - i) / l + 4), a *= 60), e.r = a, e.g = o, e.b = h;
  }
  toLinearSpaceToRef(e) {
    return e.r = Math.pow(this.r, bi), e.g = Math.pow(this.g, bi), e.b = Math.pow(this.b, bi), this;
  }
  toGammaSpace() {
    const e = new se();
    return this.toGammaSpaceToRef(e), e;
  }
  toGammaSpaceToRef(e) {
    return e.r = Math.pow(this.r, Ti), e.g = Math.pow(this.g, Ti), e.b = Math.pow(this.b, Ti), this;
  }
  static HSVtoRGBToRef(e, t, i, s) {
    const r = i * t, n = e / 60, a = r * (1 - Math.abs(n % 2 - 1));
    let o = 0, h = 0, l = 0;
    n >= 0 && n <= 1 ? (o = r, h = a) : n >= 1 && n <= 2 ? (o = a, h = r) : n >= 2 && n <= 3 ? (h = r, l = a) : n >= 3 && n <= 4 ? (h = a, l = r) : n >= 4 && n <= 5 ? (o = a, l = r) : n >= 5 && n <= 6 && (o = r, l = a);
    const u = i - r;
    s.set(o + u, h + u, l + u);
  }
  static FromHSV(e, t, i) {
    const s = new se(0, 0, 0);
    return se.HSVtoRGBToRef(e, t, i, s), s;
  }
  static FromHexString(e) {
    if (e.substring(0, 1) !== "#" || e.length !== 7)
      return new se(0, 0, 0);
    const t = parseInt(e.substring(1, 3), 16), i = parseInt(e.substring(3, 5), 16), s = parseInt(e.substring(5, 7), 16);
    return se.FromInts(t, i, s);
  }
  static FromArray(e, t = 0) {
    return new se(e[t], e[t + 1], e[t + 2]);
  }
  static FromArrayToRef(e, t = 0, i) {
    i.r = e[t], i.g = e[t + 1], i.b = e[t + 2];
  }
  static FromInts(e, t, i) {
    return new se(e / 255, t / 255, i / 255);
  }
  static Lerp(e, t, i) {
    const s = new se(0, 0, 0);
    return se.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, d = e.r * o + i.r * h + t.r * l + s.r * u, f = e.g * o + i.g * h + t.g * l + s.g * u, _ = e.b * o + i.b * h + t.b * l + s.b * u;
    return new se(d, f, _);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = se.Black();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.r = (a - r) * 6 * e.r + (3 * a - 4 * r + 1) * t.r + (-a + r) * 6 * i.r + (3 * a - 2 * r) * s.r, n.g = (a - r) * 6 * e.g + (3 * a - 4 * r + 1) * t.g + (-a + r) * 6 * i.g + (3 * a - 2 * r) * s.g, n.b = (a - r) * 6 * e.b + (3 * a - 4 * r + 1) * t.b + (-a + r) * 6 * i.b + (3 * a - 2 * r) * s.b;
  }
  static Red() {
    return new se(1, 0, 0);
  }
  static Green() {
    return new se(0, 1, 0);
  }
  static Blue() {
    return new se(0, 0, 1);
  }
  static Black() {
    return new se(0, 0, 0);
  }
  static get BlackReadOnly() {
    return se._BlackReadOnly;
  }
  static White() {
    return new se(1, 1, 1);
  }
  static Purple() {
    return new se(0.5, 0, 0.5);
  }
  static Magenta() {
    return new se(1, 0, 1);
  }
  static Yellow() {
    return new se(1, 1, 0);
  }
  static Gray() {
    return new se(0.5, 0.5, 0.5);
  }
  static Teal() {
    return new se(0, 1, 1);
  }
  static Random() {
    return new se(Math.random(), Math.random(), Math.random());
  }
}
se._BlackReadOnly = se.Black();
class ge {
  constructor(e = 0, t = 0, i = 0, s = 1) {
    this.r = e, this.g = t, this.b = i, this.a = s;
  }
  addInPlace(e) {
    return this.r += e.r, this.g += e.g, this.b += e.b, this.a += e.a, this;
  }
  asArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toArray(e, t = 0) {
    return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e[t + 3] = this.a, this;
  }
  fromArray(e, t = 0) {
    return ge.FromArrayToRef(e, t, this), this;
  }
  equals(e) {
    return e && this.r === e.r && this.g === e.g && this.b === e.b && this.a === e.a;
  }
  add(e) {
    return new ge(this.r + e.r, this.g + e.g, this.b + e.b, this.a + e.a);
  }
  subtract(e) {
    return new ge(this.r - e.r, this.g - e.g, this.b - e.b, this.a - e.a);
  }
  subtractToRef(e, t) {
    return t.r = this.r - e.r, t.g = this.g - e.g, t.b = this.b - e.b, t.a = this.a - e.a, this;
  }
  scale(e) {
    return new ge(this.r * e, this.g * e, this.b * e, this.a * e);
  }
  scaleInPlace(e) {
    return this.r *= e, this.g *= e, this.b *= e, this.a *= e, this;
  }
  scaleToRef(e, t) {
    return t.r = this.r * e, t.g = this.g * e, t.b = this.b * e, t.a = this.a * e, this;
  }
  scaleAndAddToRef(e, t) {
    return t.r += this.r * e, t.g += this.g * e, t.b += this.b * e, t.a += this.a * e, this;
  }
  clampToRef(e = 0, t = 1, i) {
    return i.r = ne.Clamp(this.r, e, t), i.g = ne.Clamp(this.g, e, t), i.b = ne.Clamp(this.b, e, t), i.a = ne.Clamp(this.a, e, t), this;
  }
  multiply(e) {
    return new ge(this.r * e.r, this.g * e.g, this.b * e.b, this.a * e.a);
  }
  multiplyToRef(e, t) {
    return t.r = this.r * e.r, t.g = this.g * e.g, t.b = this.b * e.b, t.a = this.a * e.a, t;
  }
  toString() {
    return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
  }
  getClassName() {
    return "Color4";
  }
  getHashCode() {
    let e = this.r * 255 | 0;
    return e = e * 397 ^ (this.g * 255 | 0), e = e * 397 ^ (this.b * 255 | 0), e = e * 397 ^ (this.a * 255 | 0), e;
  }
  clone() {
    return new ge(this.r, this.g, this.b, this.a);
  }
  copyFrom(e) {
    return this.r = e.r, this.g = e.g, this.b = e.b, this.a = e.a, this;
  }
  copyFromFloats(e, t, i, s) {
    return this.r = e, this.g = t, this.b = i, this.a = s, this;
  }
  set(e, t, i, s) {
    return this.copyFromFloats(e, t, i, s);
  }
  toHexString(e = !1) {
    const t = Math.round(this.r * 255), i = Math.round(this.g * 255), s = Math.round(this.b * 255);
    if (e)
      return "#" + ne.ToHex(t) + ne.ToHex(i) + ne.ToHex(s);
    const r = Math.round(this.a * 255);
    return "#" + ne.ToHex(t) + ne.ToHex(i) + ne.ToHex(s) + ne.ToHex(r);
  }
  toLinearSpace() {
    const e = new ge();
    return this.toLinearSpaceToRef(e), e;
  }
  toLinearSpaceToRef(e) {
    return e.r = Math.pow(this.r, bi), e.g = Math.pow(this.g, bi), e.b = Math.pow(this.b, bi), e.a = this.a, this;
  }
  toGammaSpace() {
    const e = new ge();
    return this.toGammaSpaceToRef(e), e;
  }
  toGammaSpaceToRef(e) {
    return e.r = Math.pow(this.r, Ti), e.g = Math.pow(this.g, Ti), e.b = Math.pow(this.b, Ti), e.a = this.a, this;
  }
  static FromHexString(e) {
    if (e.substring(0, 1) !== "#" || e.length !== 9 && e.length !== 7)
      return new ge(0, 0, 0, 0);
    const t = parseInt(e.substring(1, 3), 16), i = parseInt(e.substring(3, 5), 16), s = parseInt(e.substring(5, 7), 16), r = e.length === 9 ? parseInt(e.substring(7, 9), 16) : 255;
    return ge.FromInts(t, i, s, r);
  }
  static Lerp(e, t, i) {
    const s = new ge(0, 0, 0, 0);
    return ge.LerpToRef(e, t, i, s), s;
  }
  static LerpToRef(e, t, i, s) {
    s.r = e.r + (t.r - e.r) * i, s.g = e.g + (t.g - e.g) * i, s.b = e.b + (t.b - e.b) * i, s.a = e.a + (t.a - e.a) * i;
  }
  static Hermite(e, t, i, s, r) {
    const n = r * r, a = r * n, o = 2 * a - 3 * n + 1, h = -2 * a + 3 * n, l = a - 2 * n + r, u = a - n, d = e.r * o + i.r * h + t.r * l + s.r * u, f = e.g * o + i.g * h + t.g * l + s.g * u, _ = e.b * o + i.b * h + t.b * l + s.b * u, E = e.a * o + i.a * h + t.a * l + s.a * u;
    return new ge(d, f, _, E);
  }
  static Hermite1stDerivative(e, t, i, s, r) {
    const n = new ge();
    return this.Hermite1stDerivativeToRef(e, t, i, s, r, n), n;
  }
  static Hermite1stDerivativeToRef(e, t, i, s, r, n) {
    const a = r * r;
    n.r = (a - r) * 6 * e.r + (3 * a - 4 * r + 1) * t.r + (-a + r) * 6 * i.r + (3 * a - 2 * r) * s.r, n.g = (a - r) * 6 * e.g + (3 * a - 4 * r + 1) * t.g + (-a + r) * 6 * i.g + (3 * a - 2 * r) * s.g, n.b = (a - r) * 6 * e.b + (3 * a - 4 * r + 1) * t.b + (-a + r) * 6 * i.b + (3 * a - 2 * r) * s.b, n.a = (a - r) * 6 * e.a + (3 * a - 4 * r + 1) * t.a + (-a + r) * 6 * i.a + (3 * a - 2 * r) * s.a;
  }
  static FromColor3(e, t = 1) {
    return new ge(e.r, e.g, e.b, t);
  }
  static FromArray(e, t = 0) {
    return new ge(e[t], e[t + 1], e[t + 2], e[t + 3]);
  }
  static FromArrayToRef(e, t = 0, i) {
    i.r = e[t], i.g = e[t + 1], i.b = e[t + 2], i.a = e[t + 3];
  }
  static FromInts(e, t, i, s) {
    return new ge(e / 255, t / 255, i / 255, s / 255);
  }
  static CheckColors4(e, t) {
    if (e.length === t * 3) {
      const i = [];
      for (let s = 0; s < e.length; s += 3) {
        const r = s / 3 * 4;
        i[r] = e[s], i[r + 1] = e[s + 1], i[r + 2] = e[s + 2], i[r + 3] = 1;
      }
      return i;
    }
    return e;
  }
}
class vi {
}
vi.Color3 = Ye.BuildArray(3, se.Black);
vi.Color4 = Ye.BuildArray(3, () => new ge(0, 0, 0, 0));
st("BABYLON.Color3", se);
st("BABYLON.Color4", ge);
const $s = (c, e) => !c || c.getClassName && c.getClassName() === "Mesh" ? null : c.getClassName && c.getClassName() === "SubMesh" ? c.clone(e) : c.clone ? c.clone() : null;
function vn(c) {
  const e = [];
  do
    Object.getOwnPropertyNames(c).forEach(function(t) {
      e.indexOf(t) === -1 && e.push(t);
    });
  while (c = Object.getPrototypeOf(c));
  return e;
}
class Us {
  static DeepCopy(e, t, i, s) {
    const r = vn(e);
    for (const n of r) {
      if (n[0] === "_" && (!s || s.indexOf(n) === -1) || n.endsWith("Observable") || i && i.indexOf(n) !== -1)
        continue;
      const a = e[n], o = typeof a;
      if (o !== "function")
        try {
          if (o === "object")
            if (a instanceof Array) {
              if (t[n] = [], a.length > 0)
                if (typeof a[0] == "object")
                  for (let h = 0; h < a.length; h++) {
                    const l = $s(a[h], t);
                    t[n].indexOf(l) === -1 && t[n].push(l);
                  }
                else
                  t[n] = a.slice(0);
            } else
              t[n] = $s(a, t);
          else
            t[n] = a;
        } catch (h) {
          O.Warn(h.message);
        }
    }
  }
}
function Tn() {
  return typeof _native < "u" && _native.XMLHttpRequest ? new _native.XMLHttpRequest() : new XMLHttpRequest();
}
class dt {
  constructor() {
    this._xhr = Tn(), this._requestURL = "";
  }
  _injectCustomRequestHeaders() {
    if (!this._shouldSkipRequestModifications(this._requestURL))
      for (const e in dt.CustomRequestHeaders) {
        const t = dt.CustomRequestHeaders[e];
        t && this._xhr.setRequestHeader(e, t);
      }
  }
  _shouldSkipRequestModifications(e) {
    return dt.SkipRequestModificationForBabylonCDN && (e.includes("preview.babylonjs.com") || e.includes("cdn.babylonjs.com"));
  }
  get onprogress() {
    return this._xhr.onprogress;
  }
  set onprogress(e) {
    this._xhr.onprogress = e;
  }
  get readyState() {
    return this._xhr.readyState;
  }
  get status() {
    return this._xhr.status;
  }
  get statusText() {
    return this._xhr.statusText;
  }
  get response() {
    return this._xhr.response;
  }
  get responseURL() {
    return this._xhr.responseURL;
  }
  get responseText() {
    return this._xhr.responseText;
  }
  get responseType() {
    return this._xhr.responseType;
  }
  set responseType(e) {
    this._xhr.responseType = e;
  }
  get timeout() {
    return this._xhr.timeout;
  }
  set timeout(e) {
    this._xhr.timeout = e;
  }
  addEventListener(e, t, i) {
    this._xhr.addEventListener(e, t, i);
  }
  removeEventListener(e, t, i) {
    this._xhr.removeEventListener(e, t, i);
  }
  abort() {
    this._xhr.abort();
  }
  send(e) {
    dt.CustomRequestHeaders && this._injectCustomRequestHeaders(), this._xhr.send(e);
  }
  open(e, t) {
    for (const i of dt.CustomRequestModifiers) {
      if (this._shouldSkipRequestModifications(t))
        return;
      i(this._xhr, t);
    }
    return t = t.replace("file:http:", "http:"), t = t.replace("file:https:", "https:"), this._requestURL = t, this._xhr.open(e, t, !0);
  }
  setRequestHeader(e, t) {
    this._xhr.setRequestHeader(e, t);
  }
  getResponseHeader(e) {
    return this._xhr.getResponseHeader(e);
  }
}
dt.CustomRequestHeaders = {};
dt.CustomRequestModifiers = new Array();
dt.SkipRequestModificationForBabylonCDN = !0;
class Ii {
}
Ii.FilesToLoad = {};
class bn {
  static ExponentialBackoff(e = 3, t = 500) {
    return (i, s, r) => s.status !== 0 || r >= e || i.indexOf("file:") !== -1 ? -1 : Math.pow(2, r) * t;
  }
}
class Mi extends Error {
}
Mi._setPrototypeOf = Object.setPrototypeOf || ((c, e) => (c.__proto__ = e, c));
const oi = {
  MeshInvalidPositionsError: 0,
  UnsupportedTextureError: 1e3,
  GLTFLoaderUnexpectedMagicError: 2e3,
  SceneLoaderError: 3e3,
  LoadFileError: 4e3,
  RequestFileError: 4001,
  ReadFileError: 4002
};
class Wt extends Mi {
  constructor(e, t, i) {
    super(e), this.errorCode = t, this.innerError = i, this.name = "RuntimeError", Mi._setPrototypeOf(this, Wt.prototype);
  }
}
const Ar = (c) => {
  const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  let t = "", i, s, r, n, a, o, h, l = 0;
  const u = ArrayBuffer.isView(c) ? new Uint8Array(c.buffer, c.byteOffset, c.byteLength) : new Uint8Array(c);
  for (; l < u.length; )
    i = u[l++], s = l < u.length ? u[l++] : Number.NaN, r = l < u.length ? u[l++] : Number.NaN, n = i >> 2, a = (i & 3) << 4 | s >> 4, o = (s & 15) << 2 | r >> 6, h = r & 63, isNaN(s) ? o = h = 64 : isNaN(r) && (h = 64), t += e.charAt(n) + e.charAt(a) + e.charAt(o) + e.charAt(h);
  return t;
}, Rr = (c) => atob(c), Sn = (c) => {
  const e = Rr(c), t = e.length, i = new Uint8Array(new ArrayBuffer(t));
  for (let s = 0; s < t; s++)
    i[s] = e.charCodeAt(s);
  return i.buffer;
};
class ji {
  static SetImmediate(e) {
    Ze() && window.setImmediate ? window.setImmediate(e) : setTimeout(e, 1);
  }
}
const yr = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
class Qi extends Wt {
  constructor(e, t) {
    super(e, oi.LoadFileError), this.name = "LoadFileError", Mi._setPrototypeOf(this, Qi.prototype), t instanceof dt ? this.request = t : this.file = t;
  }
}
class $i extends Wt {
  constructor(e, t) {
    super(e, oi.RequestFileError), this.request = t, this.name = "RequestFileError", Mi._setPrototypeOf(this, $i.prototype);
  }
}
class ks extends Wt {
  constructor(e, t) {
    super(e, oi.ReadFileError), this.file = t, this.name = "ReadFileError", Mi._setPrototypeOf(this, ks.prototype);
  }
}
const He = {
  DefaultRetryStrategy: bn.ExponentialBackoff(),
  BaseUrl: "",
  CorsBehavior: "anonymous",
  PreprocessUrl: (c) => c
}, Cr = (c) => (c = c.replace(/#/gm, "%23"), c), Vs = (c, e) => {
  if (!(c && c.indexOf("data:") === 0) && He.CorsBehavior)
    if (typeof He.CorsBehavior == "string" || He.CorsBehavior instanceof String)
      e.crossOrigin = He.CorsBehavior;
    else {
      const t = He.CorsBehavior(c);
      t && (e.crossOrigin = t);
    }
}, Ws = (c, e, t, i, s = "", r) => {
  var n;
  let a, o = !1;
  c instanceof ArrayBuffer || ArrayBuffer.isView(c) ? typeof Blob < "u" && typeof URL < "u" ? (a = URL.createObjectURL(new Blob([c], { type: s })), o = !0) : a = `data:${s};base64,` + Ar(c) : c instanceof Blob ? (a = URL.createObjectURL(c), o = !0) : (a = Cr(c), a = He.PreprocessUrl(c));
  const h = fe.LastCreatedEngine, l = (b) => {
    if (t) {
      const M = a || c.toString();
      t(`Error while trying to load image: ${M.indexOf("http") === 0 || M.length <= 128 ? M : M.slice(0, 128) + "..."}`, b);
    }
  };
  if (typeof Image > "u" || ((n = h == null ? void 0 : h._features.forceBitmapOverHTMLImageElement) !== null && n !== void 0 ? n : !1))
    return Qt(a, (b) => {
      h.createImageBitmap(new Blob([b], { type: s }), { premultiplyAlpha: "none", ...r }).then((M) => {
        e(M), o && URL.revokeObjectURL(a);
      }).catch((M) => {
        t && t("Error while trying to load image: " + c, M);
      });
    }, void 0, i || void 0, !0, (b, M) => {
      l(M);
    }), null;
  const u = new Image();
  Vs(a, u);
  const d = [], f = () => {
    d.forEach((b) => {
      b.target.addEventListener(b.name, b.handler);
    });
  }, _ = () => {
    d.forEach((b) => {
      b.target.removeEventListener(b.name, b.handler);
    }), d.length = 0;
  }, E = () => {
    _(), e(u), o && u.src && URL.revokeObjectURL(u.src);
  }, m = (b) => {
    _(), l(b), o && u.src && URL.revokeObjectURL(u.src);
  }, v = (b) => {
    _();
    const M = new Error(`CSP violation of policy ${b.effectiveDirective} ${b.blockedURI}. Current policy is ${b.originalPolicy}`);
    fe.UseFallbackTexture = !1, l(M), o && u.src && URL.revokeObjectURL(u.src), u.src = "";
  };
  d.push({ target: u, name: "load", handler: E }), d.push({ target: u, name: "error", handler: m }), d.push({ target: document, name: "securitypolicyviolation", handler: v }), f();
  const S = a.substring(0, 5) === "blob:", y = a.substring(0, 5) === "data:", A = () => {
    S || y ? u.src = a : Qt(a, (b, M, L) => {
      const k = !s && L ? L : s, F = new Blob([b], { type: k }), ue = URL.createObjectURL(F);
      o = !0, u.src = ue;
    }, void 0, i || void 0, !0, (b, M) => {
      l(M);
    });
  }, C = () => {
    i && i.loadImage(a, u);
  };
  if (!S && !y && i && i.enableTexturesOffline)
    i.open(C, A);
  else {
    if (a.indexOf("file:") !== -1) {
      const b = decodeURIComponent(a.substring(5).toLowerCase());
      if (Ii.FilesToLoad[b] && typeof URL < "u") {
        try {
          let M;
          try {
            M = URL.createObjectURL(Ii.FilesToLoad[b]);
          } catch {
            M = URL.createObjectURL(Ii.FilesToLoad[b]);
          }
          u.src = M, o = !0;
        } catch {
          u.src = "";
        }
        return u;
      }
    }
    A();
  }
  return u;
}, wi = (c, e, t, i, s) => {
  const r = new FileReader(), n = {
    onCompleteObservable: new w(),
    abort: () => r.abort()
  };
  return r.onloadend = () => n.onCompleteObservable.notifyObservers(n), s && (r.onerror = () => {
    s(new ks(`Unable to read ${c.name}`, c));
  }), r.onload = (a) => {
    e(a.target.result);
  }, t && (r.onprogress = t), i ? r.readAsArrayBuffer(c) : r.readAsText(c), n;
}, Qt = (c, e, t, i, s, r, n) => {
  if (c.name)
    return wi(c, e, t, s, r ? (l) => {
      r(void 0, l);
    } : void 0);
  const a = c;
  if (a.indexOf("file:") !== -1) {
    let l = decodeURIComponent(a.substring(5).toLowerCase());
    l.indexOf("./") === 0 && (l = l.substring(2));
    const u = Ii.FilesToLoad[l];
    if (u)
      return wi(u, e, t, s, r ? (d) => r(void 0, new Qi(d.message, d.file)) : void 0);
  }
  const { match: o, type: h } = xn(a);
  if (o) {
    const l = {
      onCompleteObservable: new w(),
      abort: () => () => {
      }
    };
    try {
      const u = s ? Xs(a) : Pr(a);
      e(u, void 0, h);
    } catch (u) {
      r ? r(void 0, u) : O.Error(u.message || "Failed to parse the Data URL");
    }
    return ji.SetImmediate(() => {
      l.onCompleteObservable.notifyObservers(l);
    }), l;
  }
  return zs(a, (l, u) => {
    e(l, u == null ? void 0 : u.responseURL, u == null ? void 0 : u.getResponseHeader("content-type"));
  }, t, i, s, r ? (l) => {
    r(l.request, new Qi(l.message, l.request));
  } : void 0, n);
}, zs = (c, e, t, i, s, r, n) => {
  c = Cr(c), c = He.PreprocessUrl(c);
  const a = He.BaseUrl + c;
  let o = !1;
  const h = {
    onCompleteObservable: new w(),
    abort: () => o = !0
  }, l = () => {
    let u = new dt(), d = null, f;
    const _ = () => {
      !u || (t && u.removeEventListener("progress", t), f && u.removeEventListener("readystatechange", f), u.removeEventListener("loadend", E));
    };
    let E = () => {
      _(), h.onCompleteObservable.notifyObservers(h), h.onCompleteObservable.clear(), t = void 0, f = null, E = null, r = void 0, n = void 0, e = void 0;
    };
    h.abort = () => {
      o = !0, E && E(), u && u.readyState !== (XMLHttpRequest.DONE || 4) && u.abort(), d !== null && (clearTimeout(d), d = null), u = null;
    };
    const m = (S) => {
      const y = S.message || "Unknown error";
      r && u ? r(new $i(y, u)) : O.Error(y);
    }, v = (S) => {
      if (!!u) {
        if (u.open("GET", a), n)
          try {
            n(u);
          } catch (y) {
            m(y);
            return;
          }
        s && (u.responseType = "arraybuffer"), t && u.addEventListener("progress", t), E && u.addEventListener("loadend", E), f = () => {
          if (!(o || !u) && u.readyState === (XMLHttpRequest.DONE || 4)) {
            if (f && u.removeEventListener("readystatechange", f), u.status >= 200 && u.status < 300 || u.status === 0 && (!Ze() || Ir())) {
              try {
                e && e(s ? u.response : u.responseText, u);
              } catch (C) {
                m(C);
              }
              return;
            }
            const y = He.DefaultRetryStrategy;
            if (y) {
              const C = y(a, u, S);
              if (C !== -1) {
                _(), u = new dt(), d = setTimeout(() => v(S + 1), C);
                return;
              }
            }
            const A = new $i("Error status: " + u.status + " " + u.statusText + " - Unable to load " + a, u);
            r && r(A);
          }
        }, u.addEventListener("readystatechange", f), u.send();
      }
    };
    v(0);
  };
  if (i && i.enableSceneOffline) {
    const u = (f) => {
      f && f.status > 400 ? r && r(f) : l();
    }, d = () => {
      i && i.loadFile(He.BaseUrl + c, (f) => {
        !o && e && e(f), h.onCompleteObservable.notifyObservers(h);
      }, t ? (f) => {
        !o && t && t(f);
      } : void 0, u, s);
    };
    i.open(d, u);
  } else
    l();
  return h;
}, Ir = () => typeof location < "u" && location.protocol === "file:", Gs = (c) => yr.test(c), xn = (c) => {
  const e = yr.exec(c);
  if (e === null || e.length === 0)
    return { match: !1, type: "" };
  {
    const t = e[0].replace("data:", "").replace("base64,", "");
    return { match: !0, type: t };
  }
};
function Xs(c) {
  return Sn(c.split(",")[1]);
}
const Pr = (c) => Rr(c.split(",")[1]), Mn = () => {
  le._FileToolsLoadImage = Ws, le._FileToolsLoadFile = Qt, ni._FileToolsLoadFile = Qt;
};
Mn();
let yi;
const An = (c, e, t, i, s, r, n, a, o, h) => {
  yi = {
    DecodeBase64UrlToBinary: c,
    DecodeBase64UrlToString: e,
    DefaultRetryStrategy: t.DefaultRetryStrategy,
    BaseUrl: t.BaseUrl,
    CorsBehavior: t.CorsBehavior,
    PreprocessUrl: t.PreprocessUrl,
    IsBase64DataUrl: i,
    IsFileURL: s,
    LoadFile: r,
    LoadImage: n,
    ReadFile: a,
    RequestFile: o,
    SetCorsBehavior: h
  }, Object.defineProperty(yi, "DefaultRetryStrategy", {
    get: function() {
      return t.DefaultRetryStrategy;
    },
    set: function(l) {
      t.DefaultRetryStrategy = l;
    }
  }), Object.defineProperty(yi, "BaseUrl", {
    get: function() {
      return t.BaseUrl;
    },
    set: function(l) {
      t.BaseUrl = l;
    }
  }), Object.defineProperty(yi, "PreprocessUrl", {
    get: function() {
      return t.PreprocessUrl;
    },
    set: function(l) {
      t.PreprocessUrl = l;
    }
  }), Object.defineProperty(yi, "CorsBehavior", {
    get: function() {
      return t.CorsBehavior;
    },
    set: function(l) {
      t.CorsBehavior = l;
    }
  });
};
An(Xs, Pr, He, Gs, Ir, Qt, Ws, wi, zs, Vs);
class Pi {
  static Instantiate(e) {
    if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[e])
      return this.RegisteredExternalClasses[e];
    const t = ci(e);
    if (t)
      return t;
    O.Warn(e + " not found, you may have missed an import.");
    const i = e.split(".");
    let s = window || this;
    for (let r = 0, n = i.length; r < n; r++)
      s = s[i[r]];
    return typeof s != "function" ? null : s;
  }
}
Pi.RegisteredExternalClasses = {};
function Dr() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const e = Math.random() * 16 | 0;
    return (c === "x" ? e : e & 3 | 8).toString(16);
  });
}
class X {
  static get BaseUrl() {
    return He.BaseUrl;
  }
  static set BaseUrl(e) {
    He.BaseUrl = e;
  }
  static get DefaultRetryStrategy() {
    return He.DefaultRetryStrategy;
  }
  static set DefaultRetryStrategy(e) {
    He.DefaultRetryStrategy = e;
  }
  static get CorsBehavior() {
    return He.CorsBehavior;
  }
  static set CorsBehavior(e) {
    He.CorsBehavior = e;
  }
  static get UseFallbackTexture() {
    return fe.UseFallbackTexture;
  }
  static set UseFallbackTexture(e) {
    fe.UseFallbackTexture = e;
  }
  static get RegisteredExternalClasses() {
    return Pi.RegisteredExternalClasses;
  }
  static set RegisteredExternalClasses(e) {
    Pi.RegisteredExternalClasses = e;
  }
  static get fallbackTexture() {
    return fe.FallbackTexture;
  }
  static set fallbackTexture(e) {
    fe.FallbackTexture = e;
  }
  static FetchToRef(e, t, i, s, r, n) {
    const a = Math.abs(e) * i % i | 0, o = Math.abs(t) * s % s | 0, h = (a + o * i) * 4;
    n.r = r[h] / 255, n.g = r[h + 1] / 255, n.b = r[h + 2] / 255, n.a = r[h + 3] / 255;
  }
  static Mix(e, t, i) {
    return e * (1 - i) + t * i;
  }
  static Instantiate(e) {
    return Pi.Instantiate(e);
  }
  static SetImmediate(e) {
    ji.SetImmediate(e);
  }
  static IsExponentOfTwo(e) {
    let t = 1;
    do
      t *= 2;
    while (t < e);
    return t === e;
  }
  static FloatRound(e) {
    return Math.fround ? Math.fround(e) : (X._TmpFloatArray[0] = e, X._TmpFloatArray[0]);
  }
  static GetFilename(e) {
    const t = e.lastIndexOf("/");
    return t < 0 ? e : e.substring(t + 1);
  }
  static GetFolderPath(e, t = !1) {
    const i = e.lastIndexOf("/");
    return i < 0 ? t ? e : "" : e.substring(0, i + 1);
  }
  static ToDegrees(e) {
    return e * 180 / Math.PI;
  }
  static ToRadians(e) {
    return e * Math.PI / 180;
  }
  static SmoothAngleChange(e, t, i = 0.9) {
    const s = this.ToRadians(e), r = this.ToRadians(t);
    return this.ToDegrees(Math.atan2((1 - i) * Math.sin(r) + i * Math.sin(s), (1 - i) * Math.cos(r) + i * Math.cos(s)));
  }
  static MakeArray(e, t) {
    return t !== !0 && (e === void 0 || e == null) ? null : Array.isArray(e) ? e : [e];
  }
  static GetPointerPrefix(e) {
    let t = "pointer";
    return Ze() && !window.PointerEvent && (t = "mouse"), e._badDesktopOS && !e._badOS && !(document && "ontouchend" in document) && (t = "mouse"), t;
  }
  static SetCorsBehavior(e, t) {
    Vs(e, t);
  }
  static SetReferrerPolicyBehavior(e, t) {
    t.referrerPolicy = e;
  }
  static CleanUrl(e) {
    return e = e.replace(/#/gm, "%23"), e;
  }
  static get PreprocessUrl() {
    return He.PreprocessUrl;
  }
  static set PreprocessUrl(e) {
    He.PreprocessUrl = e;
  }
  static LoadImage(e, t, i, s, r, n) {
    return Ws(e, t, i, s, r, n);
  }
  static LoadFile(e, t, i, s, r, n) {
    return Qt(e, t, i, s, r, n);
  }
  static LoadFileAsync(e, t = !0) {
    return new Promise((i, s) => {
      Qt(e, (r) => {
        i(r);
      }, void 0, void 0, t, (r, n) => {
        s(n);
      });
    });
  }
  static LoadScript(e, t, i, s) {
    if (typeof importScripts == "function") {
      try {
        importScripts(e), t();
      } catch (a) {
        i == null || i(`Unable to load script '${e}' in worker`, a);
      }
      return;
    } else if (!Ze()) {
      i == null || i(`Cannot load script '${e}' outside of a window or a worker`);
      return;
    }
    const r = document.getElementsByTagName("head")[0], n = document.createElement("script");
    n.setAttribute("type", "text/javascript"), n.setAttribute("src", e), s && (n.id = s), n.onload = () => {
      t && t();
    }, n.onerror = (a) => {
      i && i(`Unable to load script '${e}'`, a);
    }, r.appendChild(n);
  }
  static LoadScriptAsync(e) {
    return new Promise((t, i) => {
      this.LoadScript(e, () => {
        t();
      }, (s, r) => {
        i(r || new Error(s));
      });
    });
  }
  static ReadFileAsDataURL(e, t, i) {
    const s = new FileReader(), r = {
      onCompleteObservable: new w(),
      abort: () => s.abort()
    };
    return s.onloadend = () => {
      r.onCompleteObservable.notifyObservers(r);
    }, s.onload = (n) => {
      t(n.target.result);
    }, s.onprogress = i, s.readAsDataURL(e), r;
  }
  static ReadFile(e, t, i, s, r) {
    return wi(e, t, i, s, r);
  }
  static FileAsURL(e) {
    const t = new Blob([e]);
    return window.URL.createObjectURL(t);
  }
  static Format(e, t = 2) {
    return e.toFixed(t);
  }
  static DeepCopy(e, t, i, s) {
    Us.DeepCopy(e, t, i, s);
  }
  static IsEmpty(e) {
    for (const t in e)
      if (Object.prototype.hasOwnProperty.call(e, t))
        return !1;
    return !0;
  }
  static RegisterTopRootEvents(e, t) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      e.addEventListener(s.name, s.handler, !1);
      try {
        window.parent && window.parent.addEventListener(s.name, s.handler, !1);
      } catch {
      }
    }
  }
  static UnregisterTopRootEvents(e, t) {
    for (let i = 0; i < t.length; i++) {
      const s = t[i];
      e.removeEventListener(s.name, s.handler);
      try {
        e.parent && e.parent.removeEventListener(s.name, s.handler);
      } catch {
      }
    }
  }
  static async DumpFramebuffer(e, t, i, s, r = "image/png", n) {
    throw Q("DumpTools");
  }
  static DumpData(e, t, i, s, r = "image/png", n, a = !1, o = !1, h) {
    throw Q("DumpTools");
  }
  static DumpDataAsync(e, t, i, s = "image/png", r, n = !1, a = !1, o) {
    throw Q("DumpTools");
  }
  static ToBlob(e, t, i = "image/png", s) {
    e.toBlob || (e.toBlob = function(r, n, a) {
      setTimeout(() => {
        const o = atob(this.toDataURL(n, a).split(",")[1]), h = o.length, l = new Uint8Array(h);
        for (let u = 0; u < h; u++)
          l[u] = o.charCodeAt(u);
        r(new Blob([l]));
      });
    }), e.toBlob(function(r) {
      t(r);
    }, i, s);
  }
  static DownloadBlob(e, t) {
    if ("download" in document.createElement("a")) {
      if (!t) {
        const i = new Date(), s = (i.getFullYear() + "-" + (i.getMonth() + 1)).slice(2) + "-" + i.getDate() + "_" + i.getHours() + "-" + ("0" + i.getMinutes()).slice(-2);
        t = "screenshot_" + s + ".png";
      }
      X.Download(e, t);
    } else if (e && typeof URL < "u") {
      const i = URL.createObjectURL(e), s = window.open("");
      if (!s)
        return;
      const r = s.document.createElement("img");
      r.onload = function() {
        URL.revokeObjectURL(i);
      }, r.src = i, s.document.body.appendChild(r);
    }
  }
  static EncodeScreenshotCanvasData(e, t, i = "image/png", s, r) {
    if (t) {
      const n = e.toDataURL(i, r);
      t(n);
    } else
      this.ToBlob(e, function(n) {
        n && X.DownloadBlob(n, s);
      }, i, r);
  }
  static Download(e, t) {
    if (typeof URL > "u")
      return;
    const i = window.URL.createObjectURL(e), s = document.createElement("a");
    document.body.appendChild(s), s.style.display = "none", s.href = i, s.download = t, s.addEventListener("click", () => {
      s.parentElement && s.parentElement.removeChild(s);
    }), s.click(), window.URL.revokeObjectURL(i);
  }
  static BackCompatCameraNoPreventDefault(e) {
    return typeof e[0] == "boolean" ? e[0] : typeof e[1] == "boolean" ? e[1] : !1;
  }
  static CreateScreenshot(e, t, i, s, r = "image/png") {
    throw Q("ScreenshotTools");
  }
  static CreateScreenshotAsync(e, t, i, s = "image/png") {
    throw Q("ScreenshotTools");
  }
  static CreateScreenshotUsingRenderTarget(e, t, i, s, r = "image/png", n = 1, a = !1, o) {
    throw Q("ScreenshotTools");
  }
  static CreateScreenshotUsingRenderTargetAsync(e, t, i, s = "image/png", r = 1, n = !1, a) {
    throw Q("ScreenshotTools");
  }
  static RandomId() {
    return Dr();
  }
  static IsBase64(e) {
    return Gs(e);
  }
  static DecodeBase64(e) {
    return Xs(e);
  }
  static get errorsCount() {
    return O.errorsCount;
  }
  static Log(e) {
    O.Log(e);
  }
  static Warn(e) {
    O.Warn(e);
  }
  static Error(e) {
    O.Error(e);
  }
  static get LogCache() {
    return O.LogCache;
  }
  static ClearLogCache() {
    O.ClearLogCache();
  }
  static set LogLevels(e) {
    O.LogLevels = e;
  }
  static set PerformanceLogLevel(e) {
    if ((e & X.PerformanceUserMarkLogLevel) === X.PerformanceUserMarkLogLevel) {
      X.StartPerformanceCounter = X._StartUserMark, X.EndPerformanceCounter = X._EndUserMark;
      return;
    }
    if ((e & X.PerformanceConsoleLogLevel) === X.PerformanceConsoleLogLevel) {
      X.StartPerformanceCounter = X._StartPerformanceConsole, X.EndPerformanceCounter = X._EndPerformanceConsole;
      return;
    }
    X.StartPerformanceCounter = X._StartPerformanceCounterDisabled, X.EndPerformanceCounter = X._EndPerformanceCounterDisabled;
  }
  static _StartPerformanceCounterDisabled(e, t) {
  }
  static _EndPerformanceCounterDisabled(e, t) {
  }
  static _StartUserMark(e, t = !0) {
    if (!X._Performance) {
      if (!Ze())
        return;
      X._Performance = window.performance;
    }
    !t || !X._Performance.mark || X._Performance.mark(e + "-Begin");
  }
  static _EndUserMark(e, t = !0) {
    !t || !X._Performance.mark || (X._Performance.mark(e + "-End"), X._Performance.measure(e, e + "-Begin", e + "-End"));
  }
  static _StartPerformanceConsole(e, t = !0) {
    !t || (X._StartUserMark(e, t), console.time && console.time(e));
  }
  static _EndPerformanceConsole(e, t = !0) {
    !t || (X._EndUserMark(e, t), console.timeEnd(e));
  }
  static get Now() {
    return ai.Now;
  }
  static GetClassName(e, t = !1) {
    let i = null;
    return !t && e.getClassName ? i = e.getClassName() : (e instanceof Object && (i = (t ? e : Object.getPrototypeOf(e)).constructor.__bjsclassName__), i || (i = typeof e)), i;
  }
  static First(e, t) {
    for (const i of e)
      if (t(i))
        return i;
    return null;
  }
  static getFullClassName(e, t = !1) {
    let i = null, s = null;
    if (!t && e.getClassName)
      i = e.getClassName();
    else {
      if (e instanceof Object) {
        const r = t ? e : Object.getPrototypeOf(e);
        i = r.constructor.__bjsclassName__, s = r.constructor.__bjsmoduleName__;
      }
      i || (i = typeof e);
    }
    return i ? (s != null ? s + "." : "") + i : null;
  }
  static DelayAsync(e) {
    return new Promise((t) => {
      setTimeout(() => {
        t();
      }, e);
    });
  }
  static IsSafari() {
    return xr() ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : !1;
  }
}
X.UseCustomRequestHeaders = !1;
X.CustomRequestHeaders = dt.CustomRequestHeaders;
X._TmpFloatArray = new Float32Array(1);
X.GetDOMTextContent = Bs;
X.GetAbsoluteUrl = typeof document == "object" ? (c) => {
  const e = document.createElement("a");
  return e.href = c, e.href;
} : typeof URL == "function" && typeof location == "object" ? (c) => new URL(c, location.origin).href : () => {
  throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
};
X.NoneLogLevel = O.NoneLogLevel;
X.MessageLogLevel = O.MessageLogLevel;
X.WarningLogLevel = O.WarningLogLevel;
X.ErrorLogLevel = O.ErrorLogLevel;
X.AllLogLevel = O.AllLogLevel;
X.IsWindowObjectExist = Ze;
X.PerformanceNoneLogLevel = 0;
X.PerformanceUserMarkLogLevel = 1;
X.PerformanceConsoleLogLevel = 2;
X.StartPerformanceCounter = X._StartPerformanceCounterDisabled;
X.EndPerformanceCounter = X._EndPerformanceCounterDisabled;
class Ji {
  constructor(e, t, i, s = 0) {
    this.iterations = e, this.index = s - 1, this._done = !1, this._fn = t, this._successCallback = i;
  }
  executeNext() {
    this._done || (this.index + 1 < this.iterations ? (++this.index, this._fn(this)) : this.breakLoop());
  }
  breakLoop() {
    this._done = !0, this._successCallback();
  }
  static Run(e, t, i, s = 0) {
    const r = new Ji(e, t, i, s);
    return r.executeNext(), r;
  }
  static SyncAsyncForLoop(e, t, i, s, r, n = 0) {
    return Ji.Run(Math.ceil(e / t), (a) => {
      r && r() ? a.breakLoop() : setTimeout(() => {
        for (let o = 0; o < t; ++o) {
          const h = a.index * t + o;
          if (h >= e)
            break;
          if (i(h), r && r()) {
            a.breakLoop();
            break;
          }
        }
        a.executeNext();
      }, n);
    }, s);
  }
}
fe.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
class Qe {
  constructor(e) {
    this.length = 0, this.data = new Array(e), this._id = Qe._GlobalId++;
  }
  push(e) {
    this.data[this.length++] = e, this.length > this.data.length && (this.data.length *= 2);
  }
  forEach(e) {
    for (let t = 0; t < this.length; t++)
      e(this.data[t]);
  }
  sort(e) {
    this.data.sort(e);
  }
  reset() {
    this.length = 0;
  }
  dispose() {
    this.reset(), this.data && (this.data.length = 0);
  }
  concat(e) {
    if (e.length !== 0) {
      this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2);
      for (let t = 0; t < e.length; t++)
        this.data[this.length++] = (e.data || e)[t];
    }
  }
  indexOf(e) {
    const t = this.data.indexOf(e);
    return t >= this.length ? -1 : t;
  }
  contains(e) {
    return this.indexOf(e) !== -1;
  }
}
Qe._GlobalId = 0;
class ii extends Qe {
  constructor() {
    super(...arguments), this._duplicateId = 0;
  }
  push(e) {
    super.push(e), e.__smartArrayFlags || (e.__smartArrayFlags = {}), e.__smartArrayFlags[this._id] = this._duplicateId;
  }
  pushNoDuplicate(e) {
    return e.__smartArrayFlags && e.__smartArrayFlags[this._id] === this._duplicateId ? !1 : (this.push(e), !0);
  }
  reset() {
    super.reset(), this._duplicateId++;
  }
  concatWithNoDuplicate(e) {
    if (e.length !== 0) {
      this.length + e.length > this.data.length && (this.data.length = (this.length + e.length) * 2);
      for (let t = 0; t < e.length; t++) {
        const i = (e.data || e)[t];
        this.pushNoDuplicate(i);
      }
    }
  }
}
class Js {
  constructor() {
    this._count = 0, this._data = {};
  }
  copyFrom(e) {
    this.clear(), e.forEach((t, i) => this.add(t, i));
  }
  get(e) {
    const t = this._data[e];
    if (t !== void 0)
      return t;
  }
  getOrAddWithFactory(e, t) {
    let i = this.get(e);
    return i !== void 0 || (i = t(e), i && this.add(e, i)), i;
  }
  getOrAdd(e, t) {
    const i = this.get(e);
    return i !== void 0 ? i : (this.add(e, t), t);
  }
  contains(e) {
    return this._data[e] !== void 0;
  }
  add(e, t) {
    return this._data[e] !== void 0 ? !1 : (this._data[e] = t, ++this._count, !0);
  }
  set(e, t) {
    return this._data[e] === void 0 ? !1 : (this._data[e] = t, !0);
  }
  getAndRemove(e) {
    const t = this.get(e);
    return t !== void 0 ? (delete this._data[e], --this._count, t) : null;
  }
  remove(e) {
    return this.contains(e) ? (delete this._data[e], --this._count, !0) : !1;
  }
  clear() {
    this._data = {}, this._count = 0;
  }
  get count() {
    return this._count;
  }
  forEach(e) {
    for (const t in this._data) {
      const i = this._data[t];
      e(t, i);
    }
  }
  first(e) {
    for (const t in this._data) {
      const i = this._data[t], s = e(t, i);
      if (s)
        return s;
    }
    return null;
  }
}
class ri {
  static Eval(e, t) {
    return e.match(/\([^()]*\)/g) ? e = e.replace(/\([^()]*\)/g, (i) => (i = i.slice(1, i.length - 1), ri._HandleParenthesisContent(i, t))) : e = ri._HandleParenthesisContent(e, t), e === "true" ? !0 : e === "false" ? !1 : ri.Eval(e, t);
  }
  static _HandleParenthesisContent(e, t) {
    t = t || ((r) => r === "true");
    let i;
    const s = e.split("||");
    for (const r in s)
      if (Object.prototype.hasOwnProperty.call(s, r)) {
        let n = ri._SimplifyNegation(s[r].trim());
        const a = n.split("&&");
        if (a.length > 1)
          for (let o = 0; o < a.length; ++o) {
            const h = ri._SimplifyNegation(a[o].trim());
            if (h !== "true" && h !== "false" ? h[0] === "!" ? i = !t(h.substring(1)) : i = t(h) : i = h === "true", !i) {
              n = "false";
              break;
            }
          }
        if (i || n === "true") {
          i = !0;
          break;
        }
        n !== "true" && n !== "false" ? n[0] === "!" ? i = !t(n.substring(1)) : i = t(n) : i = n === "true";
      }
    return i ? "true" : "false";
  }
  static _SimplifyNegation(e) {
    return e = e.replace(/^[\s!]+/, (t) => (t = t.replace(/[\s]/g, () => ""), t.length % 2 ? "!" : "")), e = e.trim(), e === "!true" ? e = "false" : e === "!false" && (e = "true"), e;
  }
}
class pe {
  static EnableFor(e) {
    e._tags = e._tags || {}, e.hasTags = () => pe.HasTags(e), e.addTags = (t) => pe.AddTagsTo(e, t), e.removeTags = (t) => pe.RemoveTagsFrom(e, t), e.matchesTagsQuery = (t) => pe.MatchesQuery(e, t);
  }
  static DisableFor(e) {
    delete e._tags, delete e.hasTags, delete e.addTags, delete e.removeTags, delete e.matchesTagsQuery;
  }
  static HasTags(e) {
    if (!e._tags)
      return !1;
    const t = e._tags;
    for (const i in t)
      if (Object.prototype.hasOwnProperty.call(t, i))
        return !0;
    return !1;
  }
  static GetTags(e, t = !0) {
    if (!e._tags)
      return null;
    if (t) {
      const i = [];
      for (const s in e._tags)
        Object.prototype.hasOwnProperty.call(e._tags, s) && e._tags[s] === !0 && i.push(s);
      return i.join(" ");
    } else
      return e._tags;
  }
  static AddTagsTo(e, t) {
    if (!t || typeof t != "string")
      return;
    t.split(" ").forEach(function(s) {
      pe._AddTagTo(e, s);
    });
  }
  static _AddTagTo(e, t) {
    t = t.trim(), !(t === "" || t === "true" || t === "false") && (t.match(/[\s]/) || t.match(/^([!]|([|]|[&]){2})/) || (pe.EnableFor(e), e._tags[t] = !0));
  }
  static RemoveTagsFrom(e, t) {
    if (!pe.HasTags(e))
      return;
    const i = t.split(" ");
    for (const s in i)
      pe._RemoveTagFrom(e, i[s]);
  }
  static _RemoveTagFrom(e, t) {
    delete e._tags[t];
  }
  static MatchesQuery(e, t) {
    return t === void 0 ? !0 : t === "" ? pe.HasTags(e) : ri.Eval(t, (i) => pe.HasTags(e) && e._tags[i]);
  }
}
class as {
  constructor() {
    this.rootNodes = new Array(), this.cameras = new Array(), this.lights = new Array(), this.meshes = new Array(), this.skeletons = new Array(), this.particleSystems = new Array(), this.animations = [], this.animationGroups = new Array(), this.multiMaterials = new Array(), this.materials = new Array(), this.morphTargetManagers = new Array(), this.geometries = new Array(), this.transformNodes = new Array(), this.actionManagers = new Array(), this.textures = new Array(), this._environmentTexture = null, this.postProcesses = new Array();
  }
  static AddParser(e, t) {
    this._BabylonFileParsers[e] = t;
  }
  static GetParser(e) {
    return this._BabylonFileParsers[e] ? this._BabylonFileParsers[e] : null;
  }
  static AddIndividualParser(e, t) {
    this._IndividualBabylonFileParsers[e] = t;
  }
  static GetIndividualParser(e) {
    return this._IndividualBabylonFileParsers[e] ? this._IndividualBabylonFileParsers[e] : null;
  }
  static Parse(e, t, i, s) {
    for (const r in this._BabylonFileParsers)
      Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, r) && this._BabylonFileParsers[r](e, t, i, s);
  }
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(e) {
    this._environmentTexture = e;
  }
  getNodes() {
    let e = new Array();
    return e = e.concat(this.meshes), e = e.concat(this.lights), e = e.concat(this.cameras), e = e.concat(this.transformNodes), this.skeletons.forEach((t) => e = e.concat(t.bones)), e;
  }
}
as._BabylonFileParsers = {};
as._IndividualBabylonFileParsers = {};
function T(c, e, t, i) {
  var s = arguments.length, r = s < 3 ? e : i === null ? i = Object.getOwnPropertyDescriptor(e, t) : i, n;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(c, e, t, i);
  else
    for (var a = c.length - 1; a >= 0; a--)
      (n = c[a]) && (r = (s < 3 ? n(r) : s > 3 ? n(e, t, r) : n(e, t)) || r);
  return s > 3 && r && Object.defineProperty(e, t, r), r;
}
const qi = {}, Ki = {}, er = function(c, e, t) {
  const i = c();
  pe && pe.AddTagsTo(i, e.tags);
  const s = ws(i);
  for (const r in s) {
    const n = s[r], a = e[r], o = n.type;
    if (a != null && (r !== "uniqueId" || ae.AllowLoadingUniqueId))
      switch (o) {
        case 0:
        case 6:
        case 11:
          i[r] = a;
          break;
        case 1:
          i[r] = t || a.isRenderTarget ? a : a.clone();
          break;
        case 2:
        case 3:
        case 4:
        case 5:
        case 7:
        case 10:
        case 12:
          i[r] = t ? a : a.clone();
          break;
      }
  }
  return i;
};
function Rn(c) {
  const e = c.getClassName();
  return qi[e] || (qi[e] = {}), qi[e];
}
function ws(c) {
  const e = c.getClassName();
  if (Ki[e])
    return Ki[e];
  Ki[e] = {};
  const t = Ki[e];
  let i = c, s = e;
  for (; s; ) {
    const r = qi[s];
    for (const o in r)
      t[o] = r[o];
    let n, a = !1;
    do {
      if (n = Object.getPrototypeOf(i), !n.getClassName) {
        a = !0;
        break;
      }
      if (n.getClassName() !== s)
        break;
      i = n;
    } while (n);
    if (a)
      break;
    s = n.getClassName(), i = n;
  }
  return t;
}
function It(c, e) {
  return (t, i) => {
    const s = Rn(t);
    s[i] || (s[i] = { type: c, sourceName: e });
  };
}
function yn(c, e = null) {
  return (t, i) => {
    const s = e || "_" + i;
    Object.defineProperty(t, i, {
      get: function() {
        return this[s];
      },
      set: function(r) {
        typeof this.equals == "function" && this.equals(r) || this[s] !== r && (this[s] = r, t[c].apply(this));
      },
      enumerable: !0,
      configurable: !0
    });
  };
}
function be(c, e = null) {
  return yn(c, e);
}
function R(c) {
  return It(0, c);
}
function vt(c) {
  return It(1, c);
}
function di(c) {
  return It(2, c);
}
function Vi(c) {
  return It(3, c);
}
function Cn(c) {
  return It(4, c);
}
function Gt(c) {
  return It(5, c);
}
function In(c) {
  return It(6, c);
}
function Pn(c) {
  return It(7, c);
}
function Fr(c) {
  return It(8, c);
}
function Dn(c) {
  return It(10, c);
}
class ae {
  static AppendSerializedAnimations(e, t) {
    if (e.animations) {
      t.animations = [];
      for (let i = 0; i < e.animations.length; i++) {
        const s = e.animations[i];
        t.animations.push(s.serialize());
      }
    }
  }
  static Serialize(e, t) {
    t || (t = {}), pe && (t.tags = pe.GetTags(e));
    const i = ws(e);
    for (const s in i) {
      const r = i[s], n = r.sourceName || s, a = r.type, o = e[s];
      if (o != null && (s !== "uniqueId" || ae.AllowLoadingUniqueId))
        switch (a) {
          case 0:
            t[n] = o;
            break;
          case 1:
            t[n] = o.serialize();
            break;
          case 2:
            t[n] = o.asArray();
            break;
          case 3:
            t[n] = o.serialize();
            break;
          case 4:
            t[n] = o.asArray();
            break;
          case 5:
            t[n] = o.asArray();
            break;
          case 6:
            t[n] = o.id;
            break;
          case 7:
            t[n] = o.serialize();
            break;
          case 8:
            t[n] = o.asArray();
            break;
          case 9:
            t[n] = o.serialize();
            break;
          case 10:
            t[n] = o.asArray();
            break;
          case 11:
            t[n] = o.id;
            break;
          case 12:
            t[n] = o.asArray();
            break;
        }
    }
    return t;
  }
  static Parse(e, t, i, s = null) {
    const r = e();
    s || (s = ""), pe && pe.AddTagsTo(r, t.tags);
    const n = ws(r);
    for (const a in n) {
      const o = n[a], h = t[o.sourceName || a], l = o.type;
      if (h != null && (a !== "uniqueId" || ae.AllowLoadingUniqueId)) {
        const u = r;
        switch (l) {
          case 0:
            u[a] = h;
            break;
          case 1:
            i && (u[a] = ae._TextureParser(h, i, s));
            break;
          case 2:
            u[a] = se.FromArray(h);
            break;
          case 3:
            u[a] = ae._FresnelParametersParser(h);
            break;
          case 4:
            u[a] = Te.FromArray(h);
            break;
          case 5:
            u[a] = p.FromArray(h);
            break;
          case 6:
            i && (u[a] = i.getLastMeshById(h));
            break;
          case 7:
            u[a] = ae._ColorCurvesParser(h);
            break;
          case 8:
            u[a] = ge.FromArray(h);
            break;
          case 9:
            u[a] = ae._ImageProcessingConfigurationParser(h);
            break;
          case 10:
            u[a] = Y.FromArray(h);
            break;
          case 11:
            i && (u[a] = i.getCameraById(h));
            break;
          case 12:
            u[a] = x.FromArray(h);
            break;
        }
      }
    }
    return r;
  }
  static Clone(e, t) {
    return er(e, t, !1);
  }
  static Instanciate(e, t) {
    return er(e, t, !0);
  }
}
ae.AllowLoadingUniqueId = !1;
ae._ImageProcessingConfigurationParser = (c) => {
  throw Q("ImageProcessingConfiguration");
};
ae._FresnelParametersParser = (c) => {
  throw Q("FresnelParameters");
};
ae._ColorCurvesParser = (c) => {
  throw Q("ColorCurves");
};
ae._TextureParser = (c, e, t) => {
  throw Q("Texture");
};
function $t(c, e, t, i) {
  const s = t.value;
  t.value = (...r) => {
    let n = s;
    if (typeof _native < "u" && _native[e]) {
      const a = _native[e];
      i ? n = (...o) => i(...o) ? a(...o) : s(...o) : n = a;
    }
    return c[e] = n, n(...r);
  };
}
$t.filter = function(c) {
  return (e, t, i) => $t(e, t, i, c);
};
class Hs {
  constructor(e) {
    if (this._keys = [], this._isDirty = !0, this._areLightsDirty = !0, this._areLightsDisposed = !1, this._areAttributesDirty = !0, this._areTexturesDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._arePrePassDirty = !0, this._areImageProcessingDirty = !0, this._normals = !1, this._uvs = !1, this._needNormals = !1, this._needUVs = !1, this._externalProperties = e, e)
      for (const t in e)
        Object.prototype.hasOwnProperty.call(e, t) && this._setDefaultValue(t);
  }
  get isDirty() {
    return this._isDirty;
  }
  markAsProcessed() {
    this._isDirty = !1, this._areAttributesDirty = !1, this._areTexturesDirty = !1, this._areFresnelDirty = !1, this._areLightsDirty = !1, this._areLightsDisposed = !1, this._areMiscDirty = !1, this._arePrePassDirty = !1, this._areImageProcessingDirty = !1;
  }
  markAsUnprocessed() {
    this._isDirty = !0;
  }
  markAllAsDirty() {
    this._areTexturesDirty = !0, this._areAttributesDirty = !0, this._areLightsDirty = !0, this._areFresnelDirty = !0, this._areMiscDirty = !0, this._areImageProcessingDirty = !0, this._isDirty = !0;
  }
  markAsImageProcessingDirty() {
    this._areImageProcessingDirty = !0, this._isDirty = !0;
  }
  markAsLightDirty(e = !1) {
    this._areLightsDirty = !0, this._areLightsDisposed = this._areLightsDisposed || e, this._isDirty = !0;
  }
  markAsAttributesDirty() {
    this._areAttributesDirty = !0, this._isDirty = !0;
  }
  markAsTexturesDirty() {
    this._areTexturesDirty = !0, this._isDirty = !0;
  }
  markAsFresnelDirty() {
    this._areFresnelDirty = !0, this._isDirty = !0;
  }
  markAsMiscDirty() {
    this._areMiscDirty = !0, this._isDirty = !0;
  }
  markAsPrePassDirty() {
    this._arePrePassDirty = !0, this._isDirty = !0;
  }
  rebuild() {
    this._keys.length = 0;
    for (const e of Object.keys(this))
      e[0] !== "_" && this._keys.push(e);
    if (this._externalProperties)
      for (const e in this._externalProperties)
        this._keys.indexOf(e) === -1 && this._keys.push(e);
  }
  isEqual(e) {
    if (this._keys.length !== e._keys.length)
      return !1;
    for (let t = 0; t < this._keys.length; t++) {
      const i = this._keys[t];
      if (this[i] !== e[i])
        return !1;
    }
    return !0;
  }
  cloneTo(e) {
    this._keys.length !== e._keys.length && (e._keys = this._keys.slice(0));
    for (let t = 0; t < this._keys.length; t++) {
      const i = this._keys[t];
      e[i] = this[i];
    }
  }
  reset() {
    this._keys.forEach((e) => this._setDefaultValue(e));
  }
  _setDefaultValue(e) {
    var t, i, s, r, n;
    const a = (s = (i = (t = this._externalProperties) === null || t === void 0 ? void 0 : t[e]) === null || i === void 0 ? void 0 : i.type) !== null && s !== void 0 ? s : typeof this[e], o = (n = (r = this._externalProperties) === null || r === void 0 ? void 0 : r[e]) === null || n === void 0 ? void 0 : n.default;
    switch (a) {
      case "number":
        this[e] = o != null ? o : 0;
        break;
      case "string":
        this[e] = o != null ? o : "";
        break;
      default:
        this[e] = o != null ? o : !1;
        break;
    }
  }
  toString() {
    let e = "";
    for (let t = 0; t < this._keys.length; t++) {
      const i = this._keys[t], s = this[i];
      switch (typeof s) {
        case "number":
        case "string":
          e += "#define " + i + " " + s + `
`;
          break;
        default:
          s && (e += "#define " + i + `
`);
          break;
      }
    }
    return e;
  }
}
class xe {
  constructor() {
    this._dirty = !0, this._tempColor = new ge(0, 0, 0, 0), this._globalCurve = new ge(0, 0, 0, 0), this._highlightsCurve = new ge(0, 0, 0, 0), this._midtonesCurve = new ge(0, 0, 0, 0), this._shadowsCurve = new ge(0, 0, 0, 0), this._positiveCurve = new ge(0, 0, 0, 0), this._negativeCurve = new ge(0, 0, 0, 0), this._globalHue = 30, this._globalDensity = 0, this._globalSaturation = 0, this._globalExposure = 0, this._highlightsHue = 30, this._highlightsDensity = 0, this._highlightsSaturation = 0, this._highlightsExposure = 0, this._midtonesHue = 30, this._midtonesDensity = 0, this._midtonesSaturation = 0, this._midtonesExposure = 0, this._shadowsHue = 30, this._shadowsDensity = 0, this._shadowsSaturation = 0, this._shadowsExposure = 0;
  }
  get globalHue() {
    return this._globalHue;
  }
  set globalHue(e) {
    this._globalHue = e, this._dirty = !0;
  }
  get globalDensity() {
    return this._globalDensity;
  }
  set globalDensity(e) {
    this._globalDensity = e, this._dirty = !0;
  }
  get globalSaturation() {
    return this._globalSaturation;
  }
  set globalSaturation(e) {
    this._globalSaturation = e, this._dirty = !0;
  }
  get globalExposure() {
    return this._globalExposure;
  }
  set globalExposure(e) {
    this._globalExposure = e, this._dirty = !0;
  }
  get highlightsHue() {
    return this._highlightsHue;
  }
  set highlightsHue(e) {
    this._highlightsHue = e, this._dirty = !0;
  }
  get highlightsDensity() {
    return this._highlightsDensity;
  }
  set highlightsDensity(e) {
    this._highlightsDensity = e, this._dirty = !0;
  }
  get highlightsSaturation() {
    return this._highlightsSaturation;
  }
  set highlightsSaturation(e) {
    this._highlightsSaturation = e, this._dirty = !0;
  }
  get highlightsExposure() {
    return this._highlightsExposure;
  }
  set highlightsExposure(e) {
    this._highlightsExposure = e, this._dirty = !0;
  }
  get midtonesHue() {
    return this._midtonesHue;
  }
  set midtonesHue(e) {
    this._midtonesHue = e, this._dirty = !0;
  }
  get midtonesDensity() {
    return this._midtonesDensity;
  }
  set midtonesDensity(e) {
    this._midtonesDensity = e, this._dirty = !0;
  }
  get midtonesSaturation() {
    return this._midtonesSaturation;
  }
  set midtonesSaturation(e) {
    this._midtonesSaturation = e, this._dirty = !0;
  }
  get midtonesExposure() {
    return this._midtonesExposure;
  }
  set midtonesExposure(e) {
    this._midtonesExposure = e, this._dirty = !0;
  }
  get shadowsHue() {
    return this._shadowsHue;
  }
  set shadowsHue(e) {
    this._shadowsHue = e, this._dirty = !0;
  }
  get shadowsDensity() {
    return this._shadowsDensity;
  }
  set shadowsDensity(e) {
    this._shadowsDensity = e, this._dirty = !0;
  }
  get shadowsSaturation() {
    return this._shadowsSaturation;
  }
  set shadowsSaturation(e) {
    this._shadowsSaturation = e, this._dirty = !0;
  }
  get shadowsExposure() {
    return this._shadowsExposure;
  }
  set shadowsExposure(e) {
    this._shadowsExposure = e, this._dirty = !0;
  }
  getClassName() {
    return "ColorCurves";
  }
  static Bind(e, t, i = "vCameraColorCurvePositive", s = "vCameraColorCurveNeutral", r = "vCameraColorCurveNegative") {
    e._dirty && (e._dirty = !1, e._getColorGradingDataToRef(e._globalHue, e._globalDensity, e._globalSaturation, e._globalExposure, e._globalCurve), e._getColorGradingDataToRef(e._highlightsHue, e._highlightsDensity, e._highlightsSaturation, e._highlightsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._highlightsCurve), e._getColorGradingDataToRef(e._midtonesHue, e._midtonesDensity, e._midtonesSaturation, e._midtonesExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._midtonesCurve), e._getColorGradingDataToRef(e._shadowsHue, e._shadowsDensity, e._shadowsSaturation, e._shadowsExposure, e._tempColor), e._tempColor.multiplyToRef(e._globalCurve, e._shadowsCurve), e._highlightsCurve.subtractToRef(e._midtonesCurve, e._positiveCurve), e._midtonesCurve.subtractToRef(e._shadowsCurve, e._negativeCurve)), t && (t.setFloat4(i, e._positiveCurve.r, e._positiveCurve.g, e._positiveCurve.b, e._positiveCurve.a), t.setFloat4(s, e._midtonesCurve.r, e._midtonesCurve.g, e._midtonesCurve.b, e._midtonesCurve.a), t.setFloat4(r, e._negativeCurve.r, e._negativeCurve.g, e._negativeCurve.b, e._negativeCurve.a));
  }
  static PrepareUniforms(e) {
    e.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
  }
  _getColorGradingDataToRef(e, t, i, s, r) {
    e != null && (e = xe._Clamp(e, 0, 360), t = xe._Clamp(t, -100, 100), i = xe._Clamp(i, -100, 100), s = xe._Clamp(s, -100, 100), t = xe._ApplyColorGradingSliderNonlinear(t), t *= 0.5, s = xe._ApplyColorGradingSliderNonlinear(s), t < 0 && (t *= -1, e = (e + 180) % 360), xe._FromHSBToRef(e, t, 50 + 0.25 * s, r), r.scaleToRef(2, r), r.a = 1 + 0.01 * i);
  }
  static _ApplyColorGradingSliderNonlinear(e) {
    e /= 100;
    let t = Math.abs(e);
    return t = Math.pow(t, 2), e < 0 && (t *= -1), t *= 100, t;
  }
  static _FromHSBToRef(e, t, i, s) {
    let r = xe._Clamp(e, 0, 360);
    const n = xe._Clamp(t / 100, 0, 1), a = xe._Clamp(i / 100, 0, 1);
    if (n === 0)
      s.r = a, s.g = a, s.b = a;
    else {
      r /= 60;
      const o = Math.floor(r), h = r - o, l = a * (1 - n), u = a * (1 - n * h), d = a * (1 - n * (1 - h));
      switch (o) {
        case 0:
          s.r = a, s.g = d, s.b = l;
          break;
        case 1:
          s.r = u, s.g = a, s.b = l;
          break;
        case 2:
          s.r = l, s.g = a, s.b = d;
          break;
        case 3:
          s.r = l, s.g = u, s.b = a;
          break;
        case 4:
          s.r = d, s.g = l, s.b = a;
          break;
        default:
          s.r = a, s.g = l, s.b = u;
          break;
      }
    }
    s.a = 1;
  }
  static _Clamp(e, t, i) {
    return Math.min(Math.max(e, t), i);
  }
  clone() {
    return ae.Clone(() => new xe(), this);
  }
  serialize() {
    return ae.Serialize(this);
  }
  static Parse(e) {
    return ae.Parse(() => new xe(), e, null, null);
  }
}
T([
  R()
], xe.prototype, "_globalHue", void 0);
T([
  R()
], xe.prototype, "_globalDensity", void 0);
T([
  R()
], xe.prototype, "_globalSaturation", void 0);
T([
  R()
], xe.prototype, "_globalExposure", void 0);
T([
  R()
], xe.prototype, "_highlightsHue", void 0);
T([
  R()
], xe.prototype, "_highlightsDensity", void 0);
T([
  R()
], xe.prototype, "_highlightsSaturation", void 0);
T([
  R()
], xe.prototype, "_highlightsExposure", void 0);
T([
  R()
], xe.prototype, "_midtonesHue", void 0);
T([
  R()
], xe.prototype, "_midtonesDensity", void 0);
T([
  R()
], xe.prototype, "_midtonesSaturation", void 0);
T([
  R()
], xe.prototype, "_midtonesExposure", void 0);
ae._ColorCurvesParser = xe.Parse;
class me {
  constructor() {
    this.colorCurves = new xe(), this._colorCurvesEnabled = !1, this._colorGradingEnabled = !1, this._colorGradingWithGreenDepth = !0, this._colorGradingBGR = !0, this._exposure = 1, this._toneMappingEnabled = !1, this._toneMappingType = me.TONEMAPPING_STANDARD, this._contrast = 1, this.vignetteStretch = 0, this.vignetteCenterX = 0, this.vignetteCenterY = 0, this.vignetteWeight = 1.5, this.vignetteColor = new ge(0, 0, 0, 0), this.vignetteCameraFov = 0.5, this._vignetteBlendMode = me.VIGNETTEMODE_MULTIPLY, this._vignetteEnabled = !1, this._ditheringEnabled = !1, this._ditheringIntensity = 1 / 255, this._skipFinalColorClamp = !1, this._applyByPostProcess = !1, this._isEnabled = !0, this.onUpdateParameters = new w();
  }
  get colorCurvesEnabled() {
    return this._colorCurvesEnabled;
  }
  set colorCurvesEnabled(e) {
    this._colorCurvesEnabled !== e && (this._colorCurvesEnabled = e, this._updateParameters());
  }
  get colorGradingTexture() {
    return this._colorGradingTexture;
  }
  set colorGradingTexture(e) {
    this._colorGradingTexture !== e && (this._colorGradingTexture = e, this._updateParameters());
  }
  get colorGradingEnabled() {
    return this._colorGradingEnabled;
  }
  set colorGradingEnabled(e) {
    this._colorGradingEnabled !== e && (this._colorGradingEnabled = e, this._updateParameters());
  }
  get colorGradingWithGreenDepth() {
    return this._colorGradingWithGreenDepth;
  }
  set colorGradingWithGreenDepth(e) {
    this._colorGradingWithGreenDepth !== e && (this._colorGradingWithGreenDepth = e, this._updateParameters());
  }
  get colorGradingBGR() {
    return this._colorGradingBGR;
  }
  set colorGradingBGR(e) {
    this._colorGradingBGR !== e && (this._colorGradingBGR = e, this._updateParameters());
  }
  get exposure() {
    return this._exposure;
  }
  set exposure(e) {
    this._exposure !== e && (this._exposure = e, this._updateParameters());
  }
  get toneMappingEnabled() {
    return this._toneMappingEnabled;
  }
  set toneMappingEnabled(e) {
    this._toneMappingEnabled !== e && (this._toneMappingEnabled = e, this._updateParameters());
  }
  get toneMappingType() {
    return this._toneMappingType;
  }
  set toneMappingType(e) {
    this._toneMappingType !== e && (this._toneMappingType = e, this._updateParameters());
  }
  get contrast() {
    return this._contrast;
  }
  set contrast(e) {
    this._contrast !== e && (this._contrast = e, this._updateParameters());
  }
  get vignetteCentreY() {
    return this.vignetteCenterY;
  }
  set vignetteCentreY(e) {
    this.vignetteCenterY = e;
  }
  get vignetteCentreX() {
    return this.vignetteCenterX;
  }
  set vignetteCentreX(e) {
    this.vignetteCenterX = e;
  }
  get vignetteBlendMode() {
    return this._vignetteBlendMode;
  }
  set vignetteBlendMode(e) {
    this._vignetteBlendMode !== e && (this._vignetteBlendMode = e, this._updateParameters());
  }
  get vignetteEnabled() {
    return this._vignetteEnabled;
  }
  set vignetteEnabled(e) {
    this._vignetteEnabled !== e && (this._vignetteEnabled = e, this._updateParameters());
  }
  get ditheringEnabled() {
    return this._ditheringEnabled;
  }
  set ditheringEnabled(e) {
    this._ditheringEnabled !== e && (this._ditheringEnabled = e, this._updateParameters());
  }
  get ditheringIntensity() {
    return this._ditheringIntensity;
  }
  set ditheringIntensity(e) {
    this._ditheringIntensity !== e && (this._ditheringIntensity = e, this._updateParameters());
  }
  get skipFinalColorClamp() {
    return this._skipFinalColorClamp;
  }
  set skipFinalColorClamp(e) {
    this._skipFinalColorClamp !== e && (this._skipFinalColorClamp = e, this._updateParameters());
  }
  get applyByPostProcess() {
    return this._applyByPostProcess;
  }
  set applyByPostProcess(e) {
    this._applyByPostProcess !== e && (this._applyByPostProcess = e, this._updateParameters());
  }
  get isEnabled() {
    return this._isEnabled;
  }
  set isEnabled(e) {
    this._isEnabled !== e && (this._isEnabled = e, this._updateParameters());
  }
  _updateParameters() {
    this.onUpdateParameters.notifyObservers(this);
  }
  getClassName() {
    return "ImageProcessingConfiguration";
  }
  static PrepareUniforms(e, t) {
    t.EXPOSURE && e.push("exposureLinear"), t.CONTRAST && e.push("contrast"), t.COLORGRADING && e.push("colorTransformSettings"), (t.VIGNETTE || t.DITHER) && e.push("vInverseScreenSize"), t.VIGNETTE && (e.push("vignetteSettings1"), e.push("vignetteSettings2")), t.COLORCURVES && xe.PrepareUniforms(e), t.DITHER && e.push("ditherIntensity");
  }
  static PrepareSamplers(e, t) {
    t.COLORGRADING && e.push("txColorTransform");
  }
  prepareDefines(e, t = !1) {
    if (t !== this.applyByPostProcess || !this._isEnabled) {
      e.VIGNETTE = !1, e.TONEMAPPING = !1, e.TONEMAPPING_ACES = !1, e.CONTRAST = !1, e.EXPOSURE = !1, e.COLORCURVES = !1, e.COLORGRADING = !1, e.COLORGRADING3D = !1, e.DITHER = !1, e.IMAGEPROCESSING = !1, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
      return;
    }
    switch (e.VIGNETTE = this.vignetteEnabled, e.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === me._VIGNETTEMODE_MULTIPLY, e.VIGNETTEBLENDMODEOPAQUE = !e.VIGNETTEBLENDMODEMULTIPLY, e.TONEMAPPING = this.toneMappingEnabled, this._toneMappingType) {
      case me.TONEMAPPING_ACES:
        e.TONEMAPPING_ACES = !0;
        break;
      default:
        e.TONEMAPPING_ACES = !1;
        break;
    }
    e.CONTRAST = this.contrast !== 1, e.EXPOSURE = this.exposure !== 1, e.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves, e.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture, e.COLORGRADING ? e.COLORGRADING3D = this.colorGradingTexture.is3D : e.COLORGRADING3D = !1, e.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth, e.SAMPLER3DBGRMAP = this.colorGradingBGR, e.DITHER = this._ditheringEnabled, e.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess, e.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp, e.IMAGEPROCESSING = e.VIGNETTE || e.TONEMAPPING || e.CONTRAST || e.EXPOSURE || e.COLORCURVES || e.COLORGRADING || e.DITHER;
  }
  isReady() {
    return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
  }
  bind(e, t) {
    if (this._colorCurvesEnabled && this.colorCurves && xe.Bind(this.colorCurves, e), this._vignetteEnabled || this._ditheringEnabled) {
      const i = 1 / e.getEngine().getRenderWidth(), s = 1 / e.getEngine().getRenderHeight();
      if (e.setFloat2("vInverseScreenSize", i, s), this._ditheringEnabled && e.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity), this._vignetteEnabled) {
        const r = t != null ? t : s / i;
        let n = Math.tan(this.vignetteCameraFov * 0.5), a = n * r;
        const o = Math.sqrt(a * n);
        a = X.Mix(a, o, this.vignetteStretch), n = X.Mix(n, o, this.vignetteStretch), e.setFloat4("vignetteSettings1", a, n, -a * this.vignetteCenterX, -n * this.vignetteCenterY);
        const h = -2 * this.vignetteWeight;
        e.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, h);
      }
    }
    if (e.setFloat("exposureLinear", this.exposure), e.setFloat("contrast", this.contrast), this.colorGradingTexture) {
      e.setTexture("txColorTransform", this.colorGradingTexture);
      const i = this.colorGradingTexture.getSize().height;
      e.setFloat4(
        "colorTransformSettings",
        (i - 1) / i,
        0.5 / i,
        i,
        this.colorGradingTexture.level
      );
    }
  }
  clone() {
    return ae.Clone(() => new me(), this);
  }
  serialize() {
    return ae.Serialize(this);
  }
  static Parse(e) {
    const t = ae.Parse(() => new me(), e, null, null);
    return e.vignetteCentreX !== void 0 && (t.vignetteCenterX = e.vignetteCentreX), e.vignetteCentreY !== void 0 && (t.vignetteCenterY = e.vignetteCentreY), t;
  }
  static get VIGNETTEMODE_MULTIPLY() {
    return this._VIGNETTEMODE_MULTIPLY;
  }
  static get VIGNETTEMODE_OPAQUE() {
    return this._VIGNETTEMODE_OPAQUE;
  }
}
me.TONEMAPPING_STANDARD = 0;
me.TONEMAPPING_ACES = 1;
me._VIGNETTEMODE_MULTIPLY = 0;
me._VIGNETTEMODE_OPAQUE = 1;
T([
  Pn()
], me.prototype, "colorCurves", void 0);
T([
  R()
], me.prototype, "_colorCurvesEnabled", void 0);
T([
  vt("colorGradingTexture")
], me.prototype, "_colorGradingTexture", void 0);
T([
  R()
], me.prototype, "_colorGradingEnabled", void 0);
T([
  R()
], me.prototype, "_colorGradingWithGreenDepth", void 0);
T([
  R()
], me.prototype, "_colorGradingBGR", void 0);
T([
  R()
], me.prototype, "_exposure", void 0);
T([
  R()
], me.prototype, "_toneMappingEnabled", void 0);
T([
  R()
], me.prototype, "_toneMappingType", void 0);
T([
  R()
], me.prototype, "_contrast", void 0);
T([
  R()
], me.prototype, "vignetteStretch", void 0);
T([
  R()
], me.prototype, "vignetteCenterX", void 0);
T([
  R()
], me.prototype, "vignetteCenterY", void 0);
T([
  R()
], me.prototype, "vignetteWeight", void 0);
T([
  Fr()
], me.prototype, "vignetteColor", void 0);
T([
  R()
], me.prototype, "vignetteCameraFov", void 0);
T([
  R()
], me.prototype, "_vignetteBlendMode", void 0);
T([
  R()
], me.prototype, "_vignetteEnabled", void 0);
T([
  R()
], me.prototype, "_ditheringEnabled", void 0);
T([
  R()
], me.prototype, "_ditheringIntensity", void 0);
T([
  R()
], me.prototype, "_skipFinalColorClamp", void 0);
T([
  R()
], me.prototype, "_applyByPostProcess", void 0);
T([
  R()
], me.prototype, "_isEnabled", void 0);
ae._ImageProcessingConfigurationParser = me.Parse;
le.prototype.createUniformBuffer = function(c) {
  const e = this._gl.createBuffer();
  if (!e)
    throw new Error("Unable to create uniform buffer");
  const t = new Fi(e);
  return this.bindUniformBuffer(t), c instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, c, this._gl.STATIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(c), this._gl.STATIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;
};
le.prototype.createDynamicUniformBuffer = function(c) {
  const e = this._gl.createBuffer();
  if (!e)
    throw new Error("Unable to create dynamic uniform buffer");
  const t = new Fi(e);
  return this.bindUniformBuffer(t), c instanceof Float32Array ? this._gl.bufferData(this._gl.UNIFORM_BUFFER, c, this._gl.DYNAMIC_DRAW) : this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(c), this._gl.DYNAMIC_DRAW), this.bindUniformBuffer(null), t.references = 1, t;
};
le.prototype.updateUniformBuffer = function(c, e, t, i) {
  this.bindUniformBuffer(c), t === void 0 && (t = 0), i === void 0 ? e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, e) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, t, new Float32Array(e)) : e instanceof Float32Array ? this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, e.subarray(t, t + i)) : this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(e).subarray(t, t + i)), this.bindUniformBuffer(null);
};
le.prototype.bindUniformBuffer = function(c) {
  this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, c ? c.underlyingResource : null);
};
le.prototype.bindUniformBufferBase = function(c, e, t) {
  this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, e, c ? c.underlyingResource : null);
};
le.prototype.bindUniformBlock = function(c, e, t) {
  const i = c.program, s = this._gl.getUniformBlockIndex(i, e);
  s !== 4294967295 && this._gl.uniformBlockBinding(i, s, t);
};
class V {
  constructor(e, t, i, s, r = !1) {
    this._valueCache = {}, this._engine = e, this._noUBO = !e.supportsUniformBuffers || r, this._dynamic = i, this._name = s != null ? s : "no-name", this._data = t || [], this._uniformLocations = {}, this._uniformSizes = {}, this._uniformArraySizes = {}, this._uniformLocationPointer = 0, this._needSync = !1, this._engine._features.trackUbosInFrame && (this._buffers = [], this._bufferIndex = -1, this._createBufferOnWrite = !1, this._currentFrameId = 0), this._noUBO ? (this.updateMatrix3x3 = this._updateMatrix3x3ForEffect, this.updateMatrix2x2 = this._updateMatrix2x2ForEffect, this.updateFloat = this._updateFloatForEffect, this.updateFloat2 = this._updateFloat2ForEffect, this.updateFloat3 = this._updateFloat3ForEffect, this.updateFloat4 = this._updateFloat4ForEffect, this.updateFloatArray = this._updateFloatArrayForEffect, this.updateArray = this._updateArrayForEffect, this.updateIntArray = this._updateIntArrayForEffect, this.updateUIntArray = this._updateUIntArrayForEffect, this.updateMatrix = this._updateMatrixForEffect, this.updateMatrices = this._updateMatricesForEffect, this.updateVector3 = this._updateVector3ForEffect, this.updateVector4 = this._updateVector4ForEffect, this.updateColor3 = this._updateColor3ForEffect, this.updateColor4 = this._updateColor4ForEffect, this.updateDirectColor4 = this._updateDirectColor4ForEffect, this.updateInt = this._updateIntForEffect, this.updateInt2 = this._updateInt2ForEffect, this.updateInt3 = this._updateInt3ForEffect, this.updateInt4 = this._updateInt4ForEffect, this.updateUInt = this._updateUIntForEffect, this.updateUInt2 = this._updateUInt2ForEffect, this.updateUInt3 = this._updateUInt3ForEffect, this.updateUInt4 = this._updateUInt4ForEffect) : (this._engine._uniformBuffers.push(this), this.updateMatrix3x3 = this._updateMatrix3x3ForUniform, this.updateMatrix2x2 = this._updateMatrix2x2ForUniform, this.updateFloat = this._updateFloatForUniform, this.updateFloat2 = this._updateFloat2ForUniform, this.updateFloat3 = this._updateFloat3ForUniform, this.updateFloat4 = this._updateFloat4ForUniform, this.updateFloatArray = this._updateFloatArrayForUniform, this.updateArray = this._updateArrayForUniform, this.updateIntArray = this._updateIntArrayForUniform, this.updateUIntArray = this._updateUIntArrayForUniform, this.updateMatrix = this._updateMatrixForUniform, this.updateMatrices = this._updateMatricesForUniform, this.updateVector3 = this._updateVector3ForUniform, this.updateVector4 = this._updateVector4ForUniform, this.updateColor3 = this._updateColor3ForUniform, this.updateColor4 = this._updateColor4ForUniform, this.updateDirectColor4 = this._updateDirectColor4ForUniform, this.updateInt = this._updateIntForUniform, this.updateInt2 = this._updateInt2ForUniform, this.updateInt3 = this._updateInt3ForUniform, this.updateInt4 = this._updateInt4ForUniform, this.updateUInt = this._updateUIntForUniform, this.updateUInt2 = this._updateUInt2ForUniform, this.updateUInt3 = this._updateUInt3ForUniform, this.updateUInt4 = this._updateUInt4ForUniform);
  }
  get useUbo() {
    return !this._noUBO;
  }
  get isSync() {
    return !this._needSync;
  }
  isDynamic() {
    return this._dynamic !== void 0;
  }
  getData() {
    return this._bufferData;
  }
  getBuffer() {
    return this._buffer;
  }
  _fillAlignment(e) {
    let t;
    if (e <= 2 ? t = e : t = 4, this._uniformLocationPointer % t !== 0) {
      const i = this._uniformLocationPointer;
      this._uniformLocationPointer += t - this._uniformLocationPointer % t;
      const s = this._uniformLocationPointer - i;
      for (let r = 0; r < s; r++)
        this._data.push(0);
    }
  }
  addUniform(e, t, i = 0) {
    if (this._noUBO || this._uniformLocations[e] !== void 0)
      return;
    let s;
    if (i > 0) {
      if (t instanceof Array)
        throw "addUniform should not be use with Array in UBO: " + e;
      if (this._fillAlignment(4), this._uniformArraySizes[e] = { strideSize: t, arraySize: i }, t == 16)
        t = t * i;
      else {
        const n = (4 - t) * i;
        t = t * i + n;
      }
      s = [];
      for (let r = 0; r < t; r++)
        s.push(0);
    } else {
      if (t instanceof Array)
        s = t, t = s.length;
      else {
        t = t, s = [];
        for (let r = 0; r < t; r++)
          s.push(0);
      }
      this._fillAlignment(t);
    }
    this._uniformSizes[e] = t, this._uniformLocations[e] = this._uniformLocationPointer, this._uniformLocationPointer += t;
    for (let r = 0; r < t; r++)
      this._data.push(s[r]);
    this._needSync = !0;
  }
  addMatrix(e, t) {
    this.addUniform(e, Array.prototype.slice.call(t.toArray()));
  }
  addFloat2(e, t, i) {
    const s = [t, i];
    this.addUniform(e, s);
  }
  addFloat3(e, t, i, s) {
    const r = [t, i, s];
    this.addUniform(e, r);
  }
  addColor3(e, t) {
    const i = [t.r, t.g, t.b];
    this.addUniform(e, i);
  }
  addColor4(e, t, i) {
    const s = [t.r, t.g, t.b, i];
    this.addUniform(e, s);
  }
  addVector3(e, t) {
    const i = [t.x, t.y, t.z];
    this.addUniform(e, i);
  }
  addMatrix3x3(e) {
    this.addUniform(e, 12);
  }
  addMatrix2x2(e) {
    this.addUniform(e, 8);
  }
  create() {
    this._noUBO || this._buffer || (this._fillAlignment(4), this._bufferData = new Float32Array(this._data), this._rebuild(), this._needSync = !0);
  }
  _rebuild() {
    this._noUBO || !this._bufferData || (this._dynamic ? this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData) : this._buffer = this._engine.createUniformBuffer(this._bufferData), this._engine._features.trackUbosInFrame && (this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]), this._bufferIndex = this._buffers.length - 1, this._createBufferOnWrite = !1));
  }
  get _numBuffers() {
    return this._buffers.length;
  }
  get _indexBuffer() {
    return this._bufferIndex;
  }
  get name() {
    return this._name;
  }
  _buffersEqual(e, t) {
    for (let i = 0; i < e.length; ++i)
      if (e[i] !== t[i])
        return !1;
    return !0;
  }
  _copyBuffer(e, t) {
    for (let i = 0; i < e.length; ++i)
      t[i] = e[i];
  }
  update() {
    if (!this._noUBO) {
      if (this.bindUniformBuffer(), !this._buffer) {
        this.create();
        return;
      }
      if (!this._dynamic && !this._needSync) {
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
        return;
      }
      if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1])
        if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
          this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
          return;
        } else
          this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
      this._engine.updateUniformBuffer(this._buffer, this._bufferData), this._engine._features._collectUbosUpdatedInFrame && (V._UpdatedUbosInFrame[this._name] || (V._UpdatedUbosInFrame[this._name] = 0), V._UpdatedUbosInFrame[this._name]++), this._needSync = !1, this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
    }
  }
  _createNewBuffer() {
    this._bufferIndex + 1 < this._buffers.length ? (this._bufferIndex++, this._buffer = this._buffers[this._bufferIndex][0], this._createBufferOnWrite = !1, this._needSync = !0) : this._rebuild();
  }
  _checkNewFrame() {
    this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId && (this._currentFrameId = this._engine.frameId, this._createBufferOnWrite = !1, this._buffers && this._buffers.length > 0 ? (this._needSync = this._bufferIndex !== 0, this._bufferIndex = 0, this._buffer = this._buffers[this._bufferIndex][0]) : this._bufferIndex = -1);
  }
  updateUniform(e, t, i) {
    this._checkNewFrame();
    let s = this._uniformLocations[e];
    if (s === void 0) {
      if (this._buffer) {
        O.Error("Cannot add an uniform after UBO has been created.");
        return;
      }
      this.addUniform(e, i), s = this._uniformLocations[e];
    }
    if (this._buffer || this.create(), this._dynamic)
      for (let r = 0; r < i; r++)
        this._bufferData[s + r] = t[r];
    else {
      let r = !1;
      for (let n = 0; n < i; n++)
        (i === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[s + n] !== X.FloatRound(t[n])) && (r = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + n] = t[n]);
      this._needSync = this._needSync || r;
    }
  }
  updateUniformArray(e, t, i) {
    this._checkNewFrame();
    const s = this._uniformLocations[e];
    if (s === void 0) {
      O.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
      return;
    }
    this._buffer || this.create();
    const r = this._uniformArraySizes[e];
    if (this._dynamic)
      for (let n = 0; n < i; n++)
        this._bufferData[s + n] = t[n];
    else {
      let n = !1, a = 0, o = 0;
      for (let h = 0; h < i; h++)
        if (this._bufferData[s + o * 4 + a] !== X.FloatRound(t[h]) && (n = !0, this._createBufferOnWrite && this._createNewBuffer(), this._bufferData[s + o * 4 + a] = t[h]), a++, a === r.strideSize) {
          for (; a < 4; a++)
            this._bufferData[s + o * 4 + a] = 0;
          a = 0, o++;
        }
      this._needSync = this._needSync || n;
    }
  }
  _cacheMatrix(e, t) {
    this._checkNewFrame();
    const i = this._valueCache[e], s = t.updateFlag;
    return i !== void 0 && i === s ? !1 : (this._valueCache[e] = s, !0);
  }
  _updateMatrix3x3ForUniform(e, t) {
    for (let i = 0; i < 3; i++)
      V._TempBuffer[i * 4] = t[i * 3], V._TempBuffer[i * 4 + 1] = t[i * 3 + 1], V._TempBuffer[i * 4 + 2] = t[i * 3 + 2], V._TempBuffer[i * 4 + 3] = 0;
    this.updateUniform(e, V._TempBuffer, 12);
  }
  _updateMatrix3x3ForEffect(e, t) {
    this._currentEffect.setMatrix3x3(e, t);
  }
  _updateMatrix2x2ForEffect(e, t) {
    this._currentEffect.setMatrix2x2(e, t);
  }
  _updateMatrix2x2ForUniform(e, t) {
    for (let i = 0; i < 2; i++)
      V._TempBuffer[i * 4] = t[i * 2], V._TempBuffer[i * 4 + 1] = t[i * 2 + 1], V._TempBuffer[i * 4 + 2] = 0, V._TempBuffer[i * 4 + 3] = 0;
    this.updateUniform(e, V._TempBuffer, 8);
  }
  _updateFloatForEffect(e, t) {
    this._currentEffect.setFloat(e, t);
  }
  _updateFloatForUniform(e, t) {
    V._TempBuffer[0] = t, this.updateUniform(e, V._TempBuffer, 1);
  }
  _updateFloat2ForEffect(e, t, i, s = "") {
    this._currentEffect.setFloat2(e + s, t, i);
  }
  _updateFloat2ForUniform(e, t, i) {
    V._TempBuffer[0] = t, V._TempBuffer[1] = i, this.updateUniform(e, V._TempBuffer, 2);
  }
  _updateFloat3ForEffect(e, t, i, s, r = "") {
    this._currentEffect.setFloat3(e + r, t, i, s);
  }
  _updateFloat3ForUniform(e, t, i, s) {
    V._TempBuffer[0] = t, V._TempBuffer[1] = i, V._TempBuffer[2] = s, this.updateUniform(e, V._TempBuffer, 3);
  }
  _updateFloat4ForEffect(e, t, i, s, r, n = "") {
    this._currentEffect.setFloat4(e + n, t, i, s, r);
  }
  _updateFloat4ForUniform(e, t, i, s, r) {
    V._TempBuffer[0] = t, V._TempBuffer[1] = i, V._TempBuffer[2] = s, V._TempBuffer[3] = r, this.updateUniform(e, V._TempBuffer, 4);
  }
  _updateFloatArrayForEffect(e, t) {
    this._currentEffect.setFloatArray(e, t);
  }
  _updateFloatArrayForUniform(e, t) {
    this.updateUniformArray(e, t, t.length);
  }
  _updateArrayForEffect(e, t) {
    this._currentEffect.setArray(e, t);
  }
  _updateArrayForUniform(e, t) {
    this.updateUniformArray(e, t, t.length);
  }
  _updateIntArrayForEffect(e, t) {
    this._currentEffect.setIntArray(e, t);
  }
  _updateIntArrayForUniform(e, t) {
    V._TempBufferInt32View.set(t), this.updateUniformArray(e, V._TempBuffer, t.length);
  }
  _updateUIntArrayForEffect(e, t) {
    this._currentEffect.setUIntArray(e, t);
  }
  _updateUIntArrayForUniform(e, t) {
    V._TempBufferUInt32View.set(t), this.updateUniformArray(e, V._TempBuffer, t.length);
  }
  _updateMatrixForEffect(e, t) {
    this._currentEffect.setMatrix(e, t);
  }
  _updateMatrixForUniform(e, t) {
    this._cacheMatrix(e, t) && this.updateUniform(e, t.toArray(), 16);
  }
  _updateMatricesForEffect(e, t) {
    this._currentEffect.setMatrices(e, t);
  }
  _updateMatricesForUniform(e, t) {
    this.updateUniform(e, t, t.length);
  }
  _updateVector3ForEffect(e, t) {
    this._currentEffect.setVector3(e, t);
  }
  _updateVector3ForUniform(e, t) {
    V._TempBuffer[0] = t.x, V._TempBuffer[1] = t.y, V._TempBuffer[2] = t.z, this.updateUniform(e, V._TempBuffer, 3);
  }
  _updateVector4ForEffect(e, t) {
    this._currentEffect.setVector4(e, t);
  }
  _updateVector4ForUniform(e, t) {
    V._TempBuffer[0] = t.x, V._TempBuffer[1] = t.y, V._TempBuffer[2] = t.z, V._TempBuffer[3] = t.w, this.updateUniform(e, V._TempBuffer, 4);
  }
  _updateColor3ForEffect(e, t, i = "") {
    this._currentEffect.setColor3(e + i, t);
  }
  _updateColor3ForUniform(e, t) {
    V._TempBuffer[0] = t.r, V._TempBuffer[1] = t.g, V._TempBuffer[2] = t.b, this.updateUniform(e, V._TempBuffer, 3);
  }
  _updateColor4ForEffect(e, t, i, s = "") {
    this._currentEffect.setColor4(e + s, t, i);
  }
  _updateDirectColor4ForEffect(e, t, i = "") {
    this._currentEffect.setDirectColor4(e + i, t);
  }
  _updateColor4ForUniform(e, t, i) {
    V._TempBuffer[0] = t.r, V._TempBuffer[1] = t.g, V._TempBuffer[2] = t.b, V._TempBuffer[3] = i, this.updateUniform(e, V._TempBuffer, 4);
  }
  _updateDirectColor4ForUniform(e, t) {
    V._TempBuffer[0] = t.r, V._TempBuffer[1] = t.g, V._TempBuffer[2] = t.b, V._TempBuffer[3] = t.a, this.updateUniform(e, V._TempBuffer, 4);
  }
  _updateIntForEffect(e, t, i = "") {
    this._currentEffect.setInt(e + i, t);
  }
  _updateIntForUniform(e, t) {
    V._TempBufferInt32View[0] = t, this.updateUniform(e, V._TempBuffer, 1);
  }
  _updateInt2ForEffect(e, t, i, s = "") {
    this._currentEffect.setInt2(e + s, t, i);
  }
  _updateInt2ForUniform(e, t, i) {
    V._TempBufferInt32View[0] = t, V._TempBufferInt32View[1] = i, this.updateUniform(e, V._TempBuffer, 2);
  }
  _updateInt3ForEffect(e, t, i, s, r = "") {
    this._currentEffect.setInt3(e + r, t, i, s);
  }
  _updateInt3ForUniform(e, t, i, s) {
    V._TempBufferInt32View[0] = t, V._TempBufferInt32View[1] = i, V._TempBufferInt32View[2] = s, this.updateUniform(e, V._TempBuffer, 3);
  }
  _updateInt4ForEffect(e, t, i, s, r, n = "") {
    this._currentEffect.setInt4(e + n, t, i, s, r);
  }
  _updateInt4ForUniform(e, t, i, s, r) {
    V._TempBufferInt32View[0] = t, V._TempBufferInt32View[1] = i, V._TempBufferInt32View[2] = s, V._TempBufferInt32View[3] = r, this.updateUniform(e, V._TempBuffer, 4);
  }
  _updateUIntForEffect(e, t, i = "") {
    this._currentEffect.setUInt(e + i, t);
  }
  _updateUIntForUniform(e, t) {
    V._TempBufferUInt32View[0] = t, this.updateUniform(e, V._TempBuffer, 1);
  }
  _updateUInt2ForEffect(e, t, i, s = "") {
    this._currentEffect.setUInt2(e + s, t, i);
  }
  _updateUInt2ForUniform(e, t, i) {
    V._TempBufferUInt32View[0] = t, V._TempBufferUInt32View[1] = i, this.updateUniform(e, V._TempBuffer, 2);
  }
  _updateUInt3ForEffect(e, t, i, s, r = "") {
    this._currentEffect.setUInt3(e + r, t, i, s);
  }
  _updateUInt3ForUniform(e, t, i, s) {
    V._TempBufferUInt32View[0] = t, V._TempBufferUInt32View[1] = i, V._TempBufferUInt32View[2] = s, this.updateUniform(e, V._TempBuffer, 3);
  }
  _updateUInt4ForEffect(e, t, i, s, r, n = "") {
    this._currentEffect.setUInt4(e + n, t, i, s, r);
  }
  _updateUInt4ForUniform(e, t, i, s, r) {
    V._TempBufferUInt32View[0] = t, V._TempBufferUInt32View[1] = i, V._TempBufferUInt32View[2] = s, V._TempBufferUInt32View[3] = r, this.updateUniform(e, V._TempBuffer, 4);
  }
  setTexture(e, t) {
    this._currentEffect.setTexture(e, t);
  }
  updateUniformDirectly(e, t) {
    this.updateUniform(e, t, t.length), this.update();
  }
  bindToEffect(e, t) {
    this._currentEffect = e, this._currentEffectName = t;
  }
  bindUniformBuffer() {
    !this._noUBO && this._buffer && this._currentEffect && this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
  }
  unbindEffect() {
    this._currentEffect = void 0, this._currentEffectName = void 0;
  }
  setDataBuffer(e) {
    if (!this._buffers)
      return this._buffer === e;
    for (let t = 0; t < this._buffers.length; ++t)
      if (this._buffers[t][0] === e)
        return this._bufferIndex = t, this._buffer = e, this._createBufferOnWrite = !1, this._currentEffect = void 0, !0;
    return !1;
  }
  dispose() {
    if (this._noUBO)
      return;
    const e = this._engine._uniformBuffers, t = e.indexOf(this);
    if (t !== -1 && (e[t] = e[e.length - 1], e.pop()), this._engine._features.trackUbosInFrame && this._buffers)
      for (let i = 0; i < this._buffers.length; ++i) {
        const s = this._buffers[i][0];
        this._engine._releaseBuffer(s);
      }
    else
      this._buffer && this._engine._releaseBuffer(this._buffer) && (this._buffer = null);
  }
}
V._UpdatedUbosInFrame = {};
V._MAX_UNIFORM_SIZE = 256;
V._TempBuffer = new Float32Array(V._MAX_UNIFORM_SIZE);
V._TempBufferInt32View = new Int32Array(V._TempBuffer.buffer);
V._TempBufferUInt32View = new Uint32Array(V._TempBuffer.buffer);
class es {
  constructor(e, t, i, s = 0, r = !1, n = !1, a = !1, o) {
    this._isAlreadyOwned = !1, e.getScene ? this._engine = e.getScene().getEngine() : this._engine = e, this._updatable = i, this._instanced = n, this._divisor = o || 1, t instanceof ki ? (this._data = null, this._buffer = t) : (this._data = t, this._buffer = null), this.byteStride = a ? s : s * Float32Array.BYTES_PER_ELEMENT, r || this.create();
  }
  createVertexBuffer(e, t, i, s, r, n = !1, a) {
    const o = n ? t : t * Float32Array.BYTES_PER_ELEMENT, h = s ? n ? s : s * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
    return new g(this._engine, this, e, this._updatable, !0, h, r === void 0 ? this._instanced : r, o, i, void 0, void 0, !0, this._divisor || a);
  }
  isUpdatable() {
    return this._updatable;
  }
  getData() {
    return this._data;
  }
  getBuffer() {
    return this._buffer;
  }
  getStrideSize() {
    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
  }
  create(e = null) {
    !e && this._buffer || (e = e || this._data, e && (this._buffer ? this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e), this._data = e) : this._updatable ? (this._buffer = this._engine.createDynamicVertexBuffer(e), this._data = e) : this._buffer = this._engine.createVertexBuffer(e)));
  }
  _rebuild() {
    this._buffer = null, this.create(this._data);
  }
  update(e) {
    this.create(e);
  }
  updateDirectly(e, t, i, s = !1) {
    !this._buffer || this._updatable && (this._engine.updateDynamicVertexBuffer(this._buffer, e, s ? t : t * Float32Array.BYTES_PER_ELEMENT, i ? i * this.byteStride : void 0), t === 0 && i === void 0 ? this._data = e : this._data = null);
  }
  _increaseReferences() {
    if (!!this._buffer) {
      if (!this._isAlreadyOwned) {
        this._isAlreadyOwned = !0;
        return;
      }
      this._buffer.references++;
    }
  }
  dispose() {
    !this._buffer || this._engine._releaseBuffer(this._buffer) && (this._buffer = null, this._data = null);
  }
}
class g {
  constructor(e, t, i, s, r, n, a, o, h, l, u = !1, d = !1, f = 1, _ = !1) {
    if (t instanceof es ? (this._buffer = t, this._ownsBuffer = _) : (this._buffer = new es(e, t, s, n, r, a, d), this._ownsBuffer = !0), this.uniqueId = g._Counter++, this._kind = i, l == null) {
      const m = this.getData();
      this.type = g.FLOAT, m instanceof Int8Array ? this.type = g.BYTE : m instanceof Uint8Array ? this.type = g.UNSIGNED_BYTE : m instanceof Int16Array ? this.type = g.SHORT : m instanceof Uint16Array ? this.type = g.UNSIGNED_SHORT : m instanceof Int32Array ? this.type = g.INT : m instanceof Uint32Array && (this.type = g.UNSIGNED_INT);
    } else
      this.type = l;
    const E = g.GetTypeByteLength(this.type);
    d ? (this._size = h || (n ? n / E : g.DeduceStride(i)), this.byteStride = n || this._buffer.byteStride || this._size * E, this.byteOffset = o || 0) : (this._size = h || n || g.DeduceStride(i), this.byteStride = n ? n * E : this._buffer.byteStride || this._size * E, this.byteOffset = (o || 0) * E), this.normalized = u, this._instanced = a !== void 0 ? a : !1, this._instanceDivisor = a ? f : 0, this._computeHashCode();
  }
  get instanceDivisor() {
    return this._instanceDivisor;
  }
  set instanceDivisor(e) {
    const t = e != 0;
    this._instanceDivisor = e, t !== this._instanced && (this._instanced = t, this._computeHashCode());
  }
  _computeHashCode() {
    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
  }
  _rebuild() {
    !this._buffer || this._buffer._rebuild();
  }
  getKind() {
    return this._kind;
  }
  isUpdatable() {
    return this._buffer.isUpdatable();
  }
  getData() {
    return this._buffer.getData();
  }
  getFloatData(e, t) {
    const i = this.getData();
    if (!i)
      return null;
    const s = this.getSize() * g.GetTypeByteLength(this.type), r = e * this.getSize();
    if (this.type !== g.FLOAT || this.byteStride !== s) {
      const n = new Float32Array(r);
      return this.forEach(r, (a, o) => n[o] = a), n;
    }
    if (!(i instanceof Array || i instanceof Float32Array) || this.byteOffset !== 0 || i.length !== r)
      if (i instanceof Array) {
        const n = this.byteOffset / 4;
        return i.slice(n, n + r);
      } else {
        if (i instanceof ArrayBuffer)
          return new Float32Array(i, this.byteOffset, r);
        {
          let n = i.byteOffset + this.byteOffset;
          if (t) {
            const o = new Float32Array(r), h = new Float32Array(i.buffer, n, r);
            return o.set(h), o;
          }
          const a = n % 4;
          return a && (n = Math.max(0, n - a)), new Float32Array(i.buffer, n, r);
        }
      }
    return t ? i.slice() : i;
  }
  getBuffer() {
    return this._buffer.getBuffer();
  }
  getStrideSize() {
    return this.byteStride / g.GetTypeByteLength(this.type);
  }
  getOffset() {
    return this.byteOffset / g.GetTypeByteLength(this.type);
  }
  getSize(e = !1) {
    return e ? this._size * g.GetTypeByteLength(this.type) : this._size;
  }
  getIsInstanced() {
    return this._instanced;
  }
  getInstanceDivisor() {
    return this._instanceDivisor;
  }
  create(e) {
    this._buffer.create(e);
  }
  update(e) {
    this._buffer.update(e);
  }
  updateDirectly(e, t, i = !1) {
    this._buffer.updateDirectly(e, t, void 0, i);
  }
  dispose() {
    this._ownsBuffer && this._buffer.dispose();
  }
  forEach(e, t) {
    g.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, e, this.normalized, t);
  }
  static DeduceStride(e) {
    switch (e) {
      case g.UVKind:
      case g.UV2Kind:
      case g.UV3Kind:
      case g.UV4Kind:
      case g.UV5Kind:
      case g.UV6Kind:
        return 2;
      case g.NormalKind:
      case g.PositionKind:
        return 3;
      case g.ColorKind:
      case g.MatricesIndicesKind:
      case g.MatricesIndicesExtraKind:
      case g.MatricesWeightsKind:
      case g.MatricesWeightsExtraKind:
      case g.TangentKind:
        return 4;
      default:
        throw new Error("Invalid kind '" + e + "'");
    }
  }
  static GetTypeByteLength(e) {
    switch (e) {
      case g.BYTE:
      case g.UNSIGNED_BYTE:
        return 1;
      case g.SHORT:
      case g.UNSIGNED_SHORT:
        return 2;
      case g.INT:
      case g.UNSIGNED_INT:
      case g.FLOAT:
        return 4;
      default:
        throw new Error(`Invalid type '${e}'`);
    }
  }
  static ForEach(e, t, i, s, r, n, a, o) {
    if (e instanceof Array) {
      let h = t / 4;
      const l = i / 4;
      for (let u = 0; u < n; u += s) {
        for (let d = 0; d < s; d++)
          o(e[h + d], u + d);
        h += l;
      }
    } else {
      const h = e instanceof ArrayBuffer ? new DataView(e) : new DataView(e.buffer, e.byteOffset, e.byteLength), l = g.GetTypeByteLength(r);
      for (let u = 0; u < n; u += s) {
        let d = t;
        for (let f = 0; f < s; f++) {
          const _ = g._GetFloatValue(h, r, d, a);
          o(_, u + f), d += l;
        }
        t += i;
      }
    }
  }
  static _GetFloatValue(e, t, i, s) {
    switch (t) {
      case g.BYTE: {
        let r = e.getInt8(i);
        return s && (r = Math.max(r / 127, -1)), r;
      }
      case g.UNSIGNED_BYTE: {
        let r = e.getUint8(i);
        return s && (r = r / 255), r;
      }
      case g.SHORT: {
        let r = e.getInt16(i, !0);
        return s && (r = Math.max(r / 32767, -1)), r;
      }
      case g.UNSIGNED_SHORT: {
        let r = e.getUint16(i, !0);
        return s && (r = r / 65535), r;
      }
      case g.INT:
        return e.getInt32(i, !0);
      case g.UNSIGNED_INT:
        return e.getUint32(i, !0);
      case g.FLOAT:
        return e.getFloat32(i, !0);
      default:
        throw new Error(`Invalid component type ${t}`);
    }
  }
}
g._Counter = 0;
g.BYTE = 5120;
g.UNSIGNED_BYTE = 5121;
g.SHORT = 5122;
g.UNSIGNED_SHORT = 5123;
g.INT = 5124;
g.UNSIGNED_INT = 5125;
g.FLOAT = 5126;
g.PositionKind = "position";
g.NormalKind = "normal";
g.TangentKind = "tangent";
g.UVKind = "uv";
g.UV2Kind = "uv2";
g.UV3Kind = "uv3";
g.UV4Kind = "uv4";
g.UV5Kind = "uv5";
g.UV6Kind = "uv6";
g.ColorKind = "color";
g.ColorInstanceKind = "instanceColor";
g.MatricesIndicesKind = "matricesIndices";
g.MatricesWeightsKind = "matricesWeights";
g.MatricesIndicesExtraKind = "matricesIndicesExtra";
g.MatricesWeightsExtraKind = "matricesWeightsExtra";
class zt {
  constructor() {
    this.hit = !1, this.distance = 0, this.pickedPoint = null, this.pickedMesh = null, this.bu = 0, this.bv = 0, this.faceId = -1, this.subMeshFaceId = -1, this.subMeshId = 0, this.pickedSprite = null, this.thinInstanceIndex = -1, this.ray = null, this.originMesh = null, this.aimTransform = null, this.gripTransform = null;
  }
  getNormal(e = !1, t = !0) {
    if (!this.pickedMesh || t && !this.pickedMesh.isVerticesDataPresent(g.NormalKind))
      return null;
    const i = this.pickedMesh.getIndices();
    if (!i)
      return null;
    let s;
    if (t) {
      const n = this.pickedMesh.getVerticesData(g.NormalKind);
      let a = p.FromArray(n, i[this.faceId * 3] * 3), o = p.FromArray(n, i[this.faceId * 3 + 1] * 3), h = p.FromArray(n, i[this.faceId * 3 + 2] * 3);
      a = a.scale(this.bu), o = o.scale(this.bv), h = h.scale(1 - this.bu - this.bv), s = new p(a.x + o.x + h.x, a.y + o.y + h.y, a.z + o.z + h.z);
    } else {
      const n = this.pickedMesh.getVerticesData(g.PositionKind), a = p.FromArray(n, i[this.faceId * 3] * 3), o = p.FromArray(n, i[this.faceId * 3 + 1] * 3), h = p.FromArray(n, i[this.faceId * 3 + 2] * 3), l = a.subtract(o), u = h.subtract(o);
      s = p.Cross(l, u);
    }
    const r = (n, a) => {
      let o = n.getWorldMatrix();
      n.nonUniformScaling && (D.Matrix[0].copyFrom(o), o = D.Matrix[0], o.setTranslationFromFloats(0, 0, 0), o.invert(), o.transposeToRef(D.Matrix[1]), o = D.Matrix[1]), p.TransformNormalToRef(a, o, a);
    };
    if (e && r(this.pickedMesh, s), this.ray) {
      const n = D.Vector3[0].copyFrom(s);
      e || r(this.pickedMesh, n), p.Dot(n, this.ray.direction) > 0 && s.negateInPlace();
    }
    return s.normalize(), s;
  }
  getTextureCoordinates() {
    if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(g.UVKind))
      return null;
    const e = this.pickedMesh.getIndices();
    if (!e)
      return null;
    const t = this.pickedMesh.getVerticesData(g.UVKind);
    if (!t)
      return null;
    let i = Te.FromArray(t, e[this.faceId * 3] * 2), s = Te.FromArray(t, e[this.faceId * 3 + 1] * 2), r = Te.FromArray(t, e[this.faceId * 3 + 2] * 2);
    return i = i.scale(this.bu), s = s.scale(this.bv), r = r.scale(1 - this.bu - this.bv), new Te(i.x + s.x + r.x, i.y + s.y + r.y);
  }
}
class We {
  constructor(e, t, i, s, r, n) {
    this.source = e, this.pointerX = t, this.pointerY = i, this.meshUnderPointer = s, this.sourceEvent = r, this.additionalData = n;
  }
  static CreateNew(e, t, i) {
    const s = e.getScene();
    return new We(e, s.pointerX, s.pointerY, s.meshUnderPointer || e, t, i);
  }
  static CreateNewFromSprite(e, t, i, s) {
    return new We(e, t.pointerX, t.pointerY, t.meshUnderPointer, i, s);
  }
  static CreateNewFromScene(e, t) {
    return new We(null, e.pointerX, e.pointerY, e.meshUnderPointer, t);
  }
  static CreateNewFromPrimitive(e, t, i, s) {
    return new We(e, t.x, t.y, null, i, s);
  }
}
class ts {
  constructor(e) {
    this._vertexBuffers = {}, this._scene = e;
  }
  _prepareBuffers() {
    if (this._vertexBuffers[g.PositionKind])
      return;
    const e = [];
    e.push(1, 1), e.push(-1, 1), e.push(-1, -1), e.push(1, -1), this._vertexBuffers[g.PositionKind] = new g(this._scene.getEngine(), e, g.PositionKind, !1, !1, 2), this._buildIndexBuffer();
  }
  _buildIndexBuffer() {
    const e = [];
    e.push(0), e.push(1), e.push(2), e.push(0), e.push(2), e.push(3), this._indexBuffer = this._scene.getEngine().createIndexBuffer(e);
  }
  _rebuild() {
    const e = this._vertexBuffers[g.PositionKind];
    !e || (e._rebuild(), this._buildIndexBuffer());
  }
  _prepareFrame(e = null, t = null) {
    const i = this._scene.activeCamera;
    return !i || (t = t || i._postProcesses.filter((s) => s != null), !t || t.length === 0 || !this._scene.postProcessesEnabled) ? !1 : (t[0].activate(i, e, t != null), !0);
  }
  directRender(e, t = null, i = !1, s = 0, r = 0, n = !1) {
    var a;
    const o = this._scene.getEngine();
    for (let h = 0; h < e.length; h++) {
      h < e.length - 1 ? e[h + 1].activate(this._scene.activeCamera, t == null ? void 0 : t.texture) : (t ? o.bindFramebuffer(t, s, void 0, void 0, i, r) : n || o.restoreDefaultFramebuffer(), (a = o._debugInsertMarker) === null || a === void 0 || a.call(o, `post process ${e[h].name} output`));
      const l = e[h], u = l.apply();
      u && (l.onBeforeRenderObservable.notifyObservers(u), this._prepareBuffers(), o.bindBuffers(this._vertexBuffers, this._indexBuffer, u), o.drawElementsType(0, 0, 6), l.onAfterRenderObservable.notifyObservers(u));
    }
    o.setDepthBuffer(!0), o.setDepthWrite(!0);
  }
  _finalizeFrame(e, t, i, s, r = !1) {
    var n;
    const a = this._scene.activeCamera;
    if (!a || (s = s || a._postProcesses.filter((h) => h != null), s.length === 0 || !this._scene.postProcessesEnabled))
      return;
    const o = this._scene.getEngine();
    for (let h = 0, l = s.length; h < l; h++) {
      const u = s[h];
      if (h < l - 1 ? u._outputTexture = s[h + 1].activate(a, t == null ? void 0 : t.texture) : (t ? (o.bindFramebuffer(t, i, void 0, void 0, r), u._outputTexture = t) : (o.restoreDefaultFramebuffer(), u._outputTexture = null), (n = o._debugInsertMarker) === null || n === void 0 || n.call(o, `post process ${s[h].name} output`)), e)
        break;
      const d = u.apply();
      d && (u.onBeforeRenderObservable.notifyObservers(d), this._prepareBuffers(), o.bindBuffers(this._vertexBuffers, this._indexBuffer, d), o.drawElementsType(0, 0, 6), u.onAfterRenderObservable.notifyObservers(d));
    }
    o.setDepthBuffer(!0), o.setDepthWrite(!0), o.setAlphaMode(0);
  }
  dispose() {
    const e = this._vertexBuffers[g.PositionKind];
    e && (e.dispose(), this._vertexBuffers[g.PositionKind] = null), this._indexBuffer && (this._scene.getEngine()._releaseBuffer(this._indexBuffer), this._indexBuffer = null);
  }
}
class Tt {
  constructor(e, t, i = null, s = null, r = null) {
    this.index = e, this._opaqueSubMeshes = new Qe(256), this._transparentSubMeshes = new Qe(256), this._alphaTestSubMeshes = new Qe(256), this._depthOnlySubMeshes = new Qe(256), this._particleSystems = new Qe(256), this._spriteManagers = new Qe(256), this._empty = !0, this._edgesRenderers = new ii(16), this._scene = t, this.opaqueSortCompareFn = i, this.alphaTestSortCompareFn = s, this.transparentSortCompareFn = r;
  }
  set opaqueSortCompareFn(e) {
    e ? this._opaqueSortCompareFn = e : this._opaqueSortCompareFn = Tt.PainterSortCompare, this._renderOpaque = this._renderOpaqueSorted;
  }
  set alphaTestSortCompareFn(e) {
    e ? this._alphaTestSortCompareFn = e : this._alphaTestSortCompareFn = Tt.PainterSortCompare, this._renderAlphaTest = this._renderAlphaTestSorted;
  }
  set transparentSortCompareFn(e) {
    e ? this._transparentSortCompareFn = e : this._transparentSortCompareFn = Tt.defaultTransparentSortCompare, this._renderTransparent = this._renderTransparentSorted;
  }
  render(e, t, i, s) {
    if (e) {
      e(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
      return;
    }
    const r = this._scene.getEngine();
    this._depthOnlySubMeshes.length !== 0 && (r.setColorWrite(!1), this._renderAlphaTest(this._depthOnlySubMeshes), r.setColorWrite(!0)), this._opaqueSubMeshes.length !== 0 && this._renderOpaque(this._opaqueSubMeshes), this._alphaTestSubMeshes.length !== 0 && this._renderAlphaTest(this._alphaTestSubMeshes);
    const n = r.getStencilBuffer();
    if (r.setStencilBuffer(!1), t && this._renderSprites(), i && this._renderParticles(s), this.onBeforeTransparentRendering && this.onBeforeTransparentRendering(), this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
      if (r.setStencilBuffer(n), this._scene.useOrderIndependentTransparency) {
        const a = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
        a.length && this._renderTransparent(a);
      } else
        this._renderTransparent(this._transparentSubMeshes);
      r.setAlphaMode(0);
    }
    if (r.setStencilBuffer(!1), this._edgesRenderers.length) {
      for (let a = 0; a < this._edgesRenderers.length; a++)
        this._edgesRenderers.data[a].render();
      r.setAlphaMode(0);
    }
    r.setStencilBuffer(n);
  }
  _renderOpaqueSorted(e) {
    return Tt._RenderSorted(e, this._opaqueSortCompareFn, this._scene.activeCamera, !1);
  }
  _renderAlphaTestSorted(e) {
    return Tt._RenderSorted(e, this._alphaTestSortCompareFn, this._scene.activeCamera, !1);
  }
  _renderTransparentSorted(e) {
    return Tt._RenderSorted(e, this._transparentSortCompareFn, this._scene.activeCamera, !0);
  }
  static _RenderSorted(e, t, i, s) {
    let r = 0, n;
    const a = i ? i.globalPosition : Tt._ZeroVector;
    if (s)
      for (; r < e.length; r++)
        n = e.data[r], n._alphaIndex = n.getMesh().alphaIndex, n._distanceToCamera = p.Distance(n.getBoundingInfo().boundingSphere.centerWorld, a);
    const o = e.length === e.data.length ? e.data : e.data.slice(0, e.length);
    t && o.sort(t);
    const h = o[0].getMesh().getScene();
    for (r = 0; r < o.length; r++)
      if (n = o[r], !(h._activeMeshesFrozenButKeepClipping && !n.isInFrustum(h._frustumPlanes))) {
        if (s) {
          const l = n.getMaterial();
          if (l && l.needDepthPrePass) {
            const u = l.getScene().getEngine();
            u.setColorWrite(!1), u.setAlphaMode(0), n.render(!1), u.setColorWrite(!0);
          }
        }
        n.render(s);
      }
  }
  static defaultTransparentSortCompare(e, t) {
    return e._alphaIndex > t._alphaIndex ? 1 : e._alphaIndex < t._alphaIndex ? -1 : Tt.backToFrontSortCompare(e, t);
  }
  static backToFrontSortCompare(e, t) {
    return e._distanceToCamera < t._distanceToCamera ? 1 : e._distanceToCamera > t._distanceToCamera ? -1 : 0;
  }
  static frontToBackSortCompare(e, t) {
    return e._distanceToCamera < t._distanceToCamera ? -1 : e._distanceToCamera > t._distanceToCamera ? 1 : 0;
  }
  static PainterSortCompare(e, t) {
    const i = e.getMesh(), s = t.getMesh();
    return i.material && s.material ? i.material.uniqueId - s.material.uniqueId : i.uniqueId - s.uniqueId;
  }
  prepare() {
    this._opaqueSubMeshes.reset(), this._transparentSubMeshes.reset(), this._alphaTestSubMeshes.reset(), this._depthOnlySubMeshes.reset(), this._particleSystems.reset(), this.prepareSprites(), this._edgesRenderers.reset(), this._empty = !0;
  }
  prepareSprites() {
    this._spriteManagers.reset();
  }
  dispose() {
    this._opaqueSubMeshes.dispose(), this._transparentSubMeshes.dispose(), this._alphaTestSubMeshes.dispose(), this._depthOnlySubMeshes.dispose(), this._particleSystems.dispose(), this._spriteManagers.dispose(), this._edgesRenderers.dispose();
  }
  dispatch(e, t, i) {
    t === void 0 && (t = e.getMesh()), i === void 0 && (i = e.getMaterial()), i != null && (i.needAlphaBlendingForMesh(t) ? this._transparentSubMeshes.push(e) : i.needAlphaTesting() ? (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._alphaTestSubMeshes.push(e)) : (i.needDepthPrePass && this._depthOnlySubMeshes.push(e), this._opaqueSubMeshes.push(e)), t._renderingGroup = this, t._edgesRenderer && t._edgesRenderer.isEnabled && this._edgesRenderers.pushNoDuplicate(t._edgesRenderer), this._empty = !1);
  }
  dispatchSprites(e) {
    this._spriteManagers.push(e), this._empty = !1;
  }
  dispatchParticles(e) {
    this._particleSystems.push(e), this._empty = !1;
  }
  _renderParticles(e) {
    if (this._particleSystems.length === 0)
      return;
    const t = this._scene.activeCamera;
    this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
    for (let i = 0; i < this._particleSystems.length; i++) {
      const s = this._particleSystems.data[i];
      if ((t && t.layerMask & s.layerMask) === 0)
        continue;
      const r = s.emitter;
      (!r.position || !e || e.indexOf(r) !== -1) && this._scene._activeParticles.addCount(s.render(), !1);
    }
    this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
  }
  _renderSprites() {
    if (!this._scene.spritesEnabled || this._spriteManagers.length === 0)
      return;
    const e = this._scene.activeCamera;
    this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
    for (let t = 0; t < this._spriteManagers.length; t++) {
      const i = this._spriteManagers.data[t];
      (e && e.layerMask & i.layerMask) !== 0 && i.render();
    }
    this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
  }
}
Tt._ZeroVector = p.Zero();
class Fn {
}
class ze {
  constructor(e) {
    this._useSceneAutoClearSetup = !1, this._renderingGroups = new Array(), this._autoClearDepthStencil = {}, this._customOpaqueSortCompareFn = {}, this._customAlphaTestSortCompareFn = {}, this._customTransparentSortCompareFn = {}, this._renderingGroupInfo = new Fn(), this._maintainStateBetweenFrames = !1, this._scene = e;
    for (let t = ze.MIN_RENDERINGGROUPS; t < ze.MAX_RENDERINGGROUPS; t++)
      this._autoClearDepthStencil[t] = { autoClear: !0, depth: !0, stencil: !0 };
  }
  get maintainStateBetweenFrames() {
    return this._maintainStateBetweenFrames;
  }
  set maintainStateBetweenFrames(e) {
    if (e !== this._maintainStateBetweenFrames && (this._maintainStateBetweenFrames = e, !this._maintainStateBetweenFrames)) {
      for (const t of this._scene.meshes)
        if (t.subMeshes)
          for (const i of t.subMeshes)
            i._wasDispatched = !1;
      for (const t of this._scene.spriteManagers)
        t._wasDispatched = !1;
      for (const t of this._scene.particleSystems)
        t._wasDispatched = !1;
    }
  }
  getRenderingGroup(e) {
    const t = e || 0;
    return this._prepareRenderingGroup(t), this._renderingGroups[t];
  }
  _clearDepthStencilBuffer(e = !0, t = !0) {
    this._depthStencilBufferAlreadyCleaned || (this._scene.getEngine().clear(null, !1, e, t), this._depthStencilBufferAlreadyCleaned = !0);
  }
  render(e, t, i, s) {
    const r = this._renderingGroupInfo;
    if (r.scene = this._scene, r.camera = this._scene.activeCamera, this._scene.spriteManagers && s)
      for (let n = 0; n < this._scene.spriteManagers.length; n++) {
        const a = this._scene.spriteManagers[n];
        this.dispatchSprites(a);
      }
    for (let n = ze.MIN_RENDERINGGROUPS; n < ze.MAX_RENDERINGGROUPS; n++) {
      this._depthStencilBufferAlreadyCleaned = n === ze.MIN_RENDERINGGROUPS;
      const a = this._renderingGroups[n];
      if (!a || a._empty)
        continue;
      const o = Math.pow(2, n);
      if (r.renderingGroupId = n, this._scene.onBeforeRenderingGroupObservable.notifyObservers(r, o), ze.AUTOCLEAR) {
        const h = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(n) : this._autoClearDepthStencil[n];
        h && h.autoClear && this._clearDepthStencilBuffer(h.depth, h.stencil);
      }
      for (const h of this._scene._beforeRenderingGroupDrawStage)
        h.action(n);
      a.render(e, s, i, t);
      for (const h of this._scene._afterRenderingGroupDrawStage)
        h.action(n);
      this._scene.onAfterRenderingGroupObservable.notifyObservers(r, o);
    }
  }
  reset() {
    if (!this.maintainStateBetweenFrames)
      for (let e = ze.MIN_RENDERINGGROUPS; e < ze.MAX_RENDERINGGROUPS; e++) {
        const t = this._renderingGroups[e];
        t && t.prepare();
      }
  }
  resetSprites() {
    if (!this.maintainStateBetweenFrames)
      for (let e = ze.MIN_RENDERINGGROUPS; e < ze.MAX_RENDERINGGROUPS; e++) {
        const t = this._renderingGroups[e];
        t && t.prepareSprites();
      }
  }
  dispose() {
    this.freeRenderingGroups(), this._renderingGroups.length = 0, this._renderingGroupInfo = null;
  }
  freeRenderingGroups() {
    for (let e = ze.MIN_RENDERINGGROUPS; e < ze.MAX_RENDERINGGROUPS; e++) {
      const t = this._renderingGroups[e];
      t && t.dispose();
    }
  }
  _prepareRenderingGroup(e) {
    this._renderingGroups[e] === void 0 && (this._renderingGroups[e] = new Tt(e, this._scene, this._customOpaqueSortCompareFn[e], this._customAlphaTestSortCompareFn[e], this._customTransparentSortCompareFn[e]));
  }
  dispatchSprites(e) {
    this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(e.renderingGroupId).dispatchSprites(e));
  }
  dispatchParticles(e) {
    this.maintainStateBetweenFrames && e._wasDispatched || (e._wasDispatched = !0, this.getRenderingGroup(e.renderingGroupId).dispatchParticles(e));
  }
  dispatch(e, t, i) {
    t === void 0 && (t = e.getMesh()), !(this.maintainStateBetweenFrames && e._wasDispatched) && (e._wasDispatched = !0, this.getRenderingGroup(t.renderingGroupId).dispatch(e, t, i));
  }
  setRenderingOrder(e, t = null, i = null, s = null) {
    if (this._customOpaqueSortCompareFn[e] = t, this._customAlphaTestSortCompareFn[e] = i, this._customTransparentSortCompareFn[e] = s, this._renderingGroups[e]) {
      const r = this._renderingGroups[e];
      r.opaqueSortCompareFn = this._customOpaqueSortCompareFn[e], r.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[e], r.transparentSortCompareFn = this._customTransparentSortCompareFn[e];
    }
  }
  setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) {
    this._autoClearDepthStencil[e] = {
      autoClear: t,
      depth: i,
      stencil: s
    };
  }
  getAutoClearDepthStencilSetup(e) {
    return this._autoClearDepthStencil[e];
  }
}
ze.MAX_RENDERINGGROUPS = 4;
ze.MIN_RENDERINGGROUPS = 0;
ze.AUTOCLEAR = !0;
class Z {
}
Z.NAME_EFFECTLAYER = "EffectLayer";
Z.NAME_LAYER = "Layer";
Z.NAME_LENSFLARESYSTEM = "LensFlareSystem";
Z.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
Z.NAME_PARTICLESYSTEM = "ParticleSystem";
Z.NAME_GAMEPAD = "Gamepad";
Z.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
Z.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
Z.NAME_PREPASSRENDERER = "PrePassRenderer";
Z.NAME_DEPTHRENDERER = "DepthRenderer";
Z.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
Z.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
Z.NAME_SPRITE = "Sprite";
Z.NAME_SUBSURFACE = "SubSurface";
Z.NAME_OUTLINERENDERER = "Outline";
Z.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
Z.NAME_SHADOWGENERATOR = "ShadowGenerator";
Z.NAME_OCTREE = "Octree";
Z.NAME_PHYSICSENGINE = "PhysicsEngine";
Z.NAME_AUDIO = "Audio";
Z.NAME_FLUIDRENDERER = "FluidRenderer";
Z.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
Z.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
Z.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
Z.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
Z.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
Z.STEP_BEFORECAMERADRAW_PREPASS = 0;
Z.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
Z.STEP_BEFORECAMERADRAW_LAYER = 2;
Z.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
Z.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
Z.STEP_BEFORERENDERINGMESH_PREPASS = 0;
Z.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
Z.STEP_AFTERRENDERINGMESH_PREPASS = 0;
Z.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
Z.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
Z.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
Z.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
Z.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
Z.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
Z.STEP_BEFORECLEAR_PREPASS = 1;
Z.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
Z.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
Z.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
Z.STEP_AFTERCAMERADRAW_PREPASS = 0;
Z.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
Z.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
Z.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
Z.STEP_AFTERCAMERADRAW_LAYER = 4;
Z.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
Z.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
Z.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
Z.STEP_AFTERRENDER_AUDIO = 0;
Z.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
Z.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
Z.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
Z.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
Z.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
Z.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
Z.STEP_POINTERMOVE_SPRITE = 0;
Z.STEP_POINTERDOWN_SPRITE = 0;
Z.STEP_POINTERUP_SPRITE = 0;
class ye extends Array {
  constructor(e) {
    super(...e);
  }
  static Create() {
    return Object.create(ye.prototype);
  }
  registerStep(e, t, i) {
    let s = 0, r = Number.MAX_VALUE;
    for (; s < this.length && (r = this[s].index, !(e < r)); s++)
      ;
    this.splice(s, 0, { index: e, component: t, action: i.bind(t) });
  }
  clear() {
    this.length = 0;
  }
}
class ve {
}
ve.POINTERDOWN = 1;
ve.POINTERUP = 2;
ve.POINTERMOVE = 4;
ve.POINTERWHEEL = 8;
ve.POINTERPICK = 16;
ve.POINTERTAP = 32;
ve.POINTERDOUBLETAP = 64;
class wr {
  constructor(e, t) {
    this.type = e, this.event = t;
  }
}
class wn extends wr {
  constructor(e, t, i, s) {
    super(e, t), this.ray = null, this.originalPickingInfo = null, this.skipOnPointerObservable = !1, this.localPosition = new Te(i, s);
  }
}
class ti extends wr {
  constructor(e, t, i, s = null) {
    super(e, t), this._pickInfo = i, this._inputManager = s;
  }
  get pickInfo() {
    return this._pickInfo || this._generatePickInfo(), this._pickInfo;
  }
  _generatePickInfo() {
    this._inputManager && (this._pickInfo = this._inputManager._pickMove(this.event.pointerId), this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event), this._inputManager = null);
  }
}
class ct {
  constructor() {
    this.hoverCursor = "", this.actions = new Array(), this.isRecursive = !1;
  }
  static get HasTriggers() {
    for (const e in ct.Triggers)
      if (Object.prototype.hasOwnProperty.call(ct.Triggers, e))
        return !0;
    return !1;
  }
  static get HasPickTriggers() {
    for (const e in ct.Triggers)
      if (Object.prototype.hasOwnProperty.call(ct.Triggers, e)) {
        const t = parseInt(e);
        if (t >= 1 && t <= 7)
          return !0;
      }
    return !1;
  }
  static HasSpecificTrigger(e) {
    for (const t in ct.Triggers)
      if (Object.prototype.hasOwnProperty.call(ct.Triggers, t) && parseInt(t) === e)
        return !0;
    return !1;
  }
}
ct.Triggers = {};
class is {
}
is.KEYDOWN = 1;
is.KEYUP = 2;
class Os {
  constructor(e, t) {
    this.type = e, this.event = t;
  }
}
class tr extends Os {
  constructor(e, t) {
    super(e, t), this.type = e, this.event = t, this.skipOnKeyboardObservable = !1;
  }
  get skipOnPointerObservable() {
    return this.skipOnKeyboardObservable;
  }
  set skipOnPointerObservable(e) {
    this.skipOnKeyboardObservable = e;
  }
}
var z;
(function(c) {
  c[c.Generic = 0] = "Generic", c[c.Keyboard = 1] = "Keyboard", c[c.Mouse = 2] = "Mouse", c[c.Touch = 3] = "Touch", c[c.DualShock = 4] = "DualShock", c[c.Xbox = 5] = "Xbox", c[c.Switch = 6] = "Switch", c[c.DualSense = 7] = "DualSense";
})(z || (z = {}));
var j;
(function(c) {
  c[c.Horizontal = 0] = "Horizontal", c[c.Vertical = 1] = "Vertical", c[c.LeftClick = 2] = "LeftClick", c[c.MiddleClick = 3] = "MiddleClick", c[c.RightClick = 4] = "RightClick", c[c.BrowserBack = 5] = "BrowserBack", c[c.BrowserForward = 6] = "BrowserForward", c[c.MouseWheelX = 7] = "MouseWheelX", c[c.MouseWheelY = 8] = "MouseWheelY", c[c.MouseWheelZ = 9] = "MouseWheelZ", c[c.Move = 12] = "Move";
})(j || (j = {}));
var ss;
(function(c) {
  c[c.Horizontal = 0] = "Horizontal", c[c.Vertical = 1] = "Vertical", c[c.LeftClick = 2] = "LeftClick", c[c.MiddleClick = 3] = "MiddleClick", c[c.RightClick = 4] = "RightClick", c[c.BrowserBack = 5] = "BrowserBack", c[c.BrowserForward = 6] = "BrowserForward", c[c.MouseWheelX = 7] = "MouseWheelX", c[c.MouseWheelY = 8] = "MouseWheelY", c[c.MouseWheelZ = 9] = "MouseWheelZ", c[c.DeltaHorizontal = 10] = "DeltaHorizontal", c[c.DeltaVertical = 11] = "DeltaVertical";
})(ss || (ss = {}));
var ir;
(function(c) {
  c[c.Cross = 0] = "Cross", c[c.Circle = 1] = "Circle", c[c.Square = 2] = "Square", c[c.Triangle = 3] = "Triangle", c[c.L1 = 4] = "L1", c[c.R1 = 5] = "R1", c[c.L2 = 6] = "L2", c[c.R2 = 7] = "R2", c[c.Share = 8] = "Share", c[c.Options = 9] = "Options", c[c.L3 = 10] = "L3", c[c.R3 = 11] = "R3", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.TouchPad = 17] = "TouchPad", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis";
})(ir || (ir = {}));
var sr;
(function(c) {
  c[c.Cross = 0] = "Cross", c[c.Circle = 1] = "Circle", c[c.Square = 2] = "Square", c[c.Triangle = 3] = "Triangle", c[c.L1 = 4] = "L1", c[c.R1 = 5] = "R1", c[c.L2 = 6] = "L2", c[c.R2 = 7] = "R2", c[c.Create = 8] = "Create", c[c.Options = 9] = "Options", c[c.L3 = 10] = "L3", c[c.R3 = 11] = "R3", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.TouchPad = 17] = "TouchPad", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis";
})(sr || (sr = {}));
var rr;
(function(c) {
  c[c.A = 0] = "A", c[c.B = 1] = "B", c[c.X = 2] = "X", c[c.Y = 3] = "Y", c[c.LB = 4] = "LB", c[c.RB = 5] = "RB", c[c.LT = 6] = "LT", c[c.RT = 7] = "RT", c[c.Back = 8] = "Back", c[c.Start = 9] = "Start", c[c.LS = 10] = "LS", c[c.RS = 11] = "RS", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.LStickXAxis = 17] = "LStickXAxis", c[c.LStickYAxis = 18] = "LStickYAxis", c[c.RStickXAxis = 19] = "RStickXAxis", c[c.RStickYAxis = 20] = "RStickYAxis";
})(rr || (rr = {}));
var nr;
(function(c) {
  c[c.B = 0] = "B", c[c.A = 1] = "A", c[c.Y = 2] = "Y", c[c.X = 3] = "X", c[c.L = 4] = "L", c[c.R = 5] = "R", c[c.ZL = 6] = "ZL", c[c.ZR = 7] = "ZR", c[c.Minus = 8] = "Minus", c[c.Plus = 9] = "Plus", c[c.LS = 10] = "LS", c[c.RS = 11] = "RS", c[c.DPadUp = 12] = "DPadUp", c[c.DPadDown = 13] = "DPadDown", c[c.DPadLeft = 14] = "DPadLeft", c[c.DPadRight = 15] = "DPadRight", c[c.Home = 16] = "Home", c[c.Capture = 17] = "Capture", c[c.LStickXAxis = 18] = "LStickXAxis", c[c.LStickYAxis = 19] = "LStickYAxis", c[c.RStickXAxis = 20] = "RStickXAxis", c[c.RStickYAxis = 21] = "RStickYAxis";
})(nr || (nr = {}));
var ar;
(function(c) {
  c[c.PointerMove = 0] = "PointerMove", c[c.PointerDown = 1] = "PointerDown", c[c.PointerUp = 2] = "PointerUp";
})(ar || (ar = {}));
class os {
}
os.DOM_DELTA_PIXEL = 0;
os.DOM_DELTA_LINE = 1;
os.DOM_DELTA_PAGE = 2;
class si {
  static CreateDeviceEvent(e, t, i, s, r, n) {
    switch (e) {
      case z.Keyboard:
        return this._CreateKeyboardEvent(i, s, r, n);
      case z.Mouse:
        if (i === j.MouseWheelX || i === j.MouseWheelY || i === j.MouseWheelZ)
          return this._CreateWheelEvent(e, t, i, s, r, n);
      case z.Touch:
        return this._CreatePointerEvent(e, t, i, s, r, n);
      default:
        throw `Unable to generate event for device ${z[e]}`;
    }
  }
  static _CreatePointerEvent(e, t, i, s, r, n) {
    const a = this._CreateMouseEvent(e, t, i, s, r, n);
    return e === z.Mouse ? (a.deviceType = z.Mouse, a.pointerId = 1, a.pointerType = "mouse") : (a.deviceType = z.Touch, a.pointerId = t, a.pointerType = "touch"), i === j.Move ? a.type = "pointermove" : i >= j.LeftClick && i <= j.RightClick && (a.type = s === 1 ? "pointerdown" : "pointerup", a.button = i - 2), a;
  }
  static _CreateWheelEvent(e, t, i, s, r, n) {
    const a = this._CreateMouseEvent(e, t, i, s, r, n);
    switch (a.type = "wheel", a.deltaMode = os.DOM_DELTA_PIXEL, a.deltaX = 0, a.deltaY = 0, a.deltaZ = 0, i) {
      case j.MouseWheelX:
        a.deltaX = s;
        break;
      case j.MouseWheelY:
        a.deltaY = s;
        break;
      case j.MouseWheelZ:
        a.deltaZ = s;
        break;
    }
    return a;
  }
  static _CreateMouseEvent(e, t, i, s, r, n) {
    const a = this._CreateEvent(n), o = r.pollInput(e, t, j.Horizontal), h = r.pollInput(e, t, j.Vertical);
    return n ? (a.movementX = 0, a.movementY = 0, a.offsetX = a.movementX - n.getBoundingClientRect().x, a.offsetY = a.movementY - n.getBoundingClientRect().y) : (a.movementX = r.pollInput(e, t, ss.DeltaHorizontal), a.movementY = r.pollInput(e, t, ss.DeltaVertical), a.offsetX = 0, a.offsetY = 0), this._CheckNonCharacterKeys(a, r), a.clientX = o, a.clientY = h, a.x = o, a.y = h, a.deviceType = e, a.deviceSlot = t, a.inputIndex = i, a;
  }
  static _CreateKeyboardEvent(e, t, i, s) {
    const r = this._CreateEvent(s);
    return this._CheckNonCharacterKeys(r, i), r.deviceType = z.Keyboard, r.deviceSlot = 0, r.inputIndex = e, r.type = t === 1 ? "keydown" : "keyup", r.key = String.fromCharCode(e), r.keyCode = e, r;
  }
  static _CheckNonCharacterKeys(e, t) {
    const i = t.isDeviceAvailable(z.Keyboard), s = i && t.pollInput(z.Keyboard, 0, 18) === 1, r = i && t.pollInput(z.Keyboard, 0, 17) === 1, n = i && (t.pollInput(z.Keyboard, 0, 91) === 1 || t.pollInput(z.Keyboard, 0, 92) === 1 || t.pollInput(z.Keyboard, 0, 93) === 1), a = i && t.pollInput(z.Keyboard, 0, 16) === 1;
    e.altKey = s, e.ctrlKey = r, e.metaKey = n, e.shiftKey = a;
  }
  static _CreateEvent(e) {
    const t = {};
    return t.preventDefault = () => {
    }, t.target = e, t;
  }
}
class On {
  constructor(e, t, i) {
    this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(e, t, (s, r, n, a) => {
      const o = si.CreateDeviceEvent(s, r, n, a, this);
      i(s, r, o);
    }) : this._createDummyNativeInput();
  }
  pollInput(e, t, i) {
    return this._nativeInput.pollInput(e, t, i);
  }
  isDeviceAvailable(e) {
    return e === z.Mouse || e === z.Touch;
  }
  dispose() {
    this._nativeInput.dispose();
  }
  _createDummyNativeInput() {
    return {
      pollInput: () => 0,
      isDeviceAvailable: () => !1,
      dispose: () => {
      }
    };
  }
}
const or = 255, hr = Object.keys(j).length / 2;
class Ln {
  constructor(e, t, i, s) {
    this._inputs = [], this._keyboardActive = !1, this._pointerActive = !1, this._usingSafari = X.IsSafari(), this._usingMacOS = /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform), this._keyboardDownEvent = (r) => {
    }, this._keyboardUpEvent = (r) => {
    }, this._keyboardBlurEvent = (r) => {
    }, this._pointerMoveEvent = (r) => {
    }, this._pointerDownEvent = (r) => {
    }, this._pointerUpEvent = (r) => {
    }, this._pointerCancelEvent = (r) => {
    }, this._pointerWheelEvent = (r) => {
    }, this._pointerBlurEvent = (r) => {
    }, this._eventsAttached = !1, this._mouseId = -1, this._isUsingFirefox = Fs.IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1, this._maxTouchPoints = 0, this._pointerInputClearObserver = null, this._gamepadConnectedEvent = (r) => {
    }, this._gamepadDisconnectedEvent = (r) => {
    }, this._eventPrefix = X.GetPointerPrefix(e), this._engine = e, this._onDeviceConnected = t, this._onDeviceDisconnected = i, this._onInputChanged = s, this._enableEvents(), this._usingMacOS && (this._metaKeys = []), this._engine._onEngineViewChanged || (this._engine._onEngineViewChanged = () => {
      this._enableEvents();
    });
  }
  pollInput(e, t, i) {
    const s = this._inputs[e][t];
    if (!s)
      throw `Unable to find device ${z[e]}`;
    e >= z.DualShock && e <= z.DualSense && this._updateDevice(e, t, i);
    const r = s[i];
    if (r === void 0)
      throw `Unable to find input ${i} for device ${z[e]} in slot ${t}`;
    return i === j.Move && X.Warn("Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data."), r;
  }
  isDeviceAvailable(e) {
    return this._inputs[e] !== void 0;
  }
  dispose() {
    this._onDeviceConnected = () => {
    }, this._onDeviceDisconnected = () => {
    }, this._onInputChanged = () => {
    }, delete this._engine._onEngineViewChanged, this._elementToAttachTo && this._disableEvents();
  }
  _enableEvents() {
    const e = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
    if (e && (!this._eventsAttached || this._elementToAttachTo !== e)) {
      if (this._disableEvents(), this._inputs) {
        for (const t of this._inputs)
          if (t)
            for (const i in t) {
              const s = +i, r = t[s];
              if (r)
                for (let n = 0; n < r.length; n++)
                  r[n] = 0;
            }
      }
      this._elementToAttachTo = e, this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex, this._handleKeyActions(), this._handlePointerActions(), this._handleGamepadActions(), this._eventsAttached = !0, this._checkForConnectedDevices();
    }
  }
  _disableEvents() {
    this._elementToAttachTo && (this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent), this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent), window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent), window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent)), this._pointerInputClearObserver && this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver), this._eventsAttached = !1;
  }
  _checkForConnectedDevices() {
    if (navigator.getGamepads) {
      const e = navigator.getGamepads();
      for (const t of e)
        t && this._addGamePad(t);
    }
    typeof matchMedia == "function" && matchMedia("(pointer:fine)").matches && this._addPointerDevice(z.Mouse, 0, 0, 0);
  }
  _addGamePad(e) {
    const t = this._getGamepadDeviceType(e.id), i = e.index;
    this._gamepads = this._gamepads || new Array(e.index + 1), this._registerDevice(t, i, e.buttons.length + e.axes.length), this._gamepads[i] = t;
  }
  _addPointerDevice(e, t, i, s) {
    this._pointerActive || (this._pointerActive = !0), this._registerDevice(e, t, hr);
    const r = this._inputs[e][t];
    r[0] = i, r[1] = s;
  }
  _registerDevice(e, t, i) {
    if (t === void 0)
      throw `Unable to register device ${z[e]} to undefined slot.`;
    if (this._inputs[e] || (this._inputs[e] = {}), !this._inputs[e][t]) {
      const s = new Array(i);
      s.fill(0), this._inputs[e][t] = s, this._onDeviceConnected(e, t);
    }
  }
  _unregisterDevice(e, t) {
    this._inputs[e][t] && (delete this._inputs[e][t], this._onDeviceDisconnected(e, t));
  }
  _handleKeyActions() {
    this._keyboardDownEvent = (e) => {
      this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(z.Keyboard, 0, or));
      const t = this._inputs[z.Keyboard][0];
      if (t) {
        t[e.keyCode] = 1;
        const i = e;
        i.inputIndex = e.keyCode, this._usingMacOS && e.metaKey && e.key !== "Meta" && (this._metaKeys.includes(e.keyCode) || this._metaKeys.push(e.keyCode)), this._onInputChanged(z.Keyboard, 0, i);
      }
    }, this._keyboardUpEvent = (e) => {
      this._keyboardActive || (this._keyboardActive = !0, this._registerDevice(z.Keyboard, 0, or));
      const t = this._inputs[z.Keyboard][0];
      if (t) {
        t[e.keyCode] = 0;
        const i = e;
        if (i.inputIndex = e.keyCode, this._usingMacOS && e.key === "Meta" && this._metaKeys.length > 0) {
          for (const s of this._metaKeys) {
            const r = si.CreateDeviceEvent(z.Keyboard, 0, s, 0, this, this._elementToAttachTo);
            t[s] = 0, this._onInputChanged(z.Keyboard, 0, r);
          }
          this._metaKeys.splice(0, this._metaKeys.length);
        }
        this._onInputChanged(z.Keyboard, 0, i);
      }
    }, this._keyboardBlurEvent = () => {
      if (this._keyboardActive) {
        const e = this._inputs[z.Keyboard][0];
        for (let t = 0; t < e.length; t++)
          if (e[t] !== 0) {
            e[t] = 0;
            const i = si.CreateDeviceEvent(z.Keyboard, 0, t, 0, this, this._elementToAttachTo);
            this._onInputChanged(z.Keyboard, 0, i);
          }
        this._usingMacOS && this._metaKeys.splice(0, this._metaKeys.length);
      }
    }, this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent), this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent), this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
  }
  _handlePointerActions() {
    this._maxTouchPoints = Fs.IsNavigatorAvailable() && navigator.maxTouchPoints || 2, this._activeTouchIds || (this._activeTouchIds = new Array(this._maxTouchPoints));
    for (let i = 0; i < this._maxTouchPoints; i++)
      this._activeTouchIds[i] = -1;
    this._pointerMoveEvent = (i) => {
      const s = this._getPointerType(i), r = s === z.Mouse ? 0 : this._activeTouchIds.indexOf(i.pointerId);
      this._inputs[s] || (this._inputs[s] = {}), this._inputs[s][r] || this._addPointerDevice(s, r, i.clientX, i.clientY);
      const n = this._inputs[s][r];
      if (n) {
        const a = i;
        a.inputIndex = j.Move, n[j.Horizontal] = i.clientX, n[j.Vertical] = i.clientY, this._onInputChanged(s, r, a), !this._usingSafari && i.button !== -1 && (a.inputIndex = i.button + 2, n[i.button + 2] = n[i.button + 2] ? 0 : 1, this._onInputChanged(s, r, a));
      }
    }, this._pointerDownEvent = (i) => {
      const s = this._getPointerType(i);
      let r = s === z.Mouse ? 0 : i.pointerId;
      if (s === z.Touch) {
        const a = this._activeTouchIds.indexOf(-1);
        if (a >= 0)
          r = a, this._activeTouchIds[a] = i.pointerId;
        else {
          X.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
          return;
        }
      }
      this._inputs[s] || (this._inputs[s] = {}), this._inputs[s][r] ? s === z.Touch && this._onDeviceConnected(s, r) : this._addPointerDevice(s, r, i.clientX, i.clientY);
      const n = this._inputs[s][r];
      if (n) {
        const a = n[j.Horizontal], o = n[j.Vertical];
        if (s === z.Mouse) {
          if (this._mouseId === -1 && (i.pointerId === void 0 ? this._mouseId = this._isUsingFirefox ? 0 : 1 : this._mouseId = i.pointerId), !document.pointerLockElement)
            try {
              this._elementToAttachTo.setPointerCapture(this._mouseId);
            } catch {
            }
        } else if (i.pointerId && !document.pointerLockElement)
          try {
            this._elementToAttachTo.setPointerCapture(i.pointerId);
          } catch {
          }
        n[j.Horizontal] = i.clientX, n[j.Vertical] = i.clientY, n[i.button + 2] = 1;
        const h = i;
        h.inputIndex = i.button + 2, this._onInputChanged(s, r, h), (a !== i.clientX || o !== i.clientY) && (h.inputIndex = j.Move, this._onInputChanged(s, r, h));
      }
    }, this._pointerUpEvent = (i) => {
      var s, r, n, a, o;
      const h = this._getPointerType(i), l = h === z.Mouse ? 0 : this._activeTouchIds.indexOf(i.pointerId);
      if (h === z.Touch) {
        if (l === -1)
          return;
        this._activeTouchIds[l] = -1;
      }
      const u = (s = this._inputs[h]) === null || s === void 0 ? void 0 : s[l];
      if (u && u[i.button + 2] !== 0) {
        const d = u[j.Horizontal], f = u[j.Vertical];
        u[j.Horizontal] = i.clientX, u[j.Vertical] = i.clientY, u[i.button + 2] = 0;
        const _ = i;
        (d !== i.clientX || f !== i.clientY) && (_.inputIndex = j.Move, this._onInputChanged(h, l, _)), _.inputIndex = i.button + 2, h === z.Mouse && this._mouseId >= 0 && ((n = (r = this._elementToAttachTo).hasPointerCapture) === null || n === void 0 ? void 0 : n.call(r, this._mouseId)) ? this._elementToAttachTo.releasePointerCapture(this._mouseId) : i.pointerId && ((o = (a = this._elementToAttachTo).hasPointerCapture) === null || o === void 0 ? void 0 : o.call(a, i.pointerId)) && this._elementToAttachTo.releasePointerCapture(i.pointerId), this._onInputChanged(h, l, _), h === z.Touch && this._onDeviceDisconnected(h, l);
      }
    }, this._pointerCancelEvent = (i) => {
      var s, r, n, a;
      if (i.pointerType === "mouse") {
        const o = this._inputs[z.Mouse][0];
        this._mouseId >= 0 && ((r = (s = this._elementToAttachTo).hasPointerCapture) === null || r === void 0 ? void 0 : r.call(s, this._mouseId)) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
        for (let h = j.LeftClick; h <= j.BrowserForward; h++)
          if (o[h] === 1) {
            o[h] = 0;
            const l = si.CreateDeviceEvent(z.Mouse, 0, h, 0, this, this._elementToAttachTo);
            this._onInputChanged(z.Mouse, 0, l);
          }
      } else {
        const o = this._activeTouchIds.indexOf(i.pointerId);
        !((a = (n = this._elementToAttachTo).hasPointerCapture) === null || a === void 0) && a.call(n, i.pointerId) && this._elementToAttachTo.releasePointerCapture(i.pointerId), this._inputs[z.Touch][o][j.LeftClick] = 0;
        const h = si.CreateDeviceEvent(z.Touch, o, j.LeftClick, 0, this, this._elementToAttachTo);
        this._onInputChanged(z.Touch, o, h), this._activeTouchIds[o] = -1, this._onDeviceDisconnected(z.Touch, o);
      }
    }, this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
    let e = !1;
    const t = function() {
    };
    try {
      const i = Object.defineProperty({}, "passive", {
        get: function() {
          e = !0;
        }
      });
      this._elementToAttachTo.addEventListener("test", t, i), this._elementToAttachTo.removeEventListener("test", t, i);
    } catch {
    }
    this._pointerBlurEvent = () => {
      var i, s, r, n, a;
      if (this.isDeviceAvailable(z.Mouse)) {
        const o = this._inputs[z.Mouse][0];
        this._mouseId >= 0 && ((s = (i = this._elementToAttachTo).hasPointerCapture) === null || s === void 0 ? void 0 : s.call(i, this._mouseId)) && this._elementToAttachTo.releasePointerCapture(this._mouseId);
        for (let h = j.LeftClick; h <= j.BrowserForward; h++)
          if (o[h] === 1) {
            o[h] = 0;
            const l = si.CreateDeviceEvent(z.Mouse, 0, h, 0, this, this._elementToAttachTo);
            this._onInputChanged(z.Mouse, 0, l);
          }
      }
      if (this.isDeviceAvailable(z.Touch)) {
        const o = this._inputs[z.Touch];
        for (let h = 0; h < this._activeTouchIds.length; h++) {
          const l = this._activeTouchIds[h];
          if (!((n = (r = this._elementToAttachTo).hasPointerCapture) === null || n === void 0) && n.call(r, l) && this._elementToAttachTo.releasePointerCapture(l), l !== -1 && ((a = o[h]) === null || a === void 0 ? void 0 : a[j.LeftClick]) === 1) {
            o[h][j.LeftClick] = 0;
            const u = si.CreateDeviceEvent(z.Touch, h, j.LeftClick, 0, this, this._elementToAttachTo);
            this._onInputChanged(z.Touch, h, u), this._activeTouchIds[h] = -1, this._onDeviceDisconnected(z.Touch, h);
          }
        }
      }
    }, this._pointerWheelEvent = (i) => {
      const s = z.Mouse, r = 0;
      this._inputs[s] || (this._inputs[s] = []), this._inputs[s][r] || (this._pointerActive = !0, this._registerDevice(s, r, hr));
      const n = this._inputs[s][r];
      if (n) {
        n[j.MouseWheelX] = i.deltaX || 0, n[j.MouseWheelY] = i.deltaY || i.wheelDelta || 0, n[j.MouseWheelZ] = i.deltaZ || 0;
        const a = i;
        n[j.MouseWheelX] !== 0 && (a.inputIndex = j.MouseWheelX, this._onInputChanged(s, r, a)), n[j.MouseWheelY] !== 0 && (a.inputIndex = j.MouseWheelY, this._onInputChanged(s, r, a)), n[j.MouseWheelZ] !== 0 && (a.inputIndex = j.MouseWheelZ, this._onInputChanged(s, r, a));
      }
    }, this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent), this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent), this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent), this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, e ? { passive: !1 } : !1), this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {
      if (this.isDeviceAvailable(z.Mouse)) {
        const i = this._inputs[z.Mouse][0];
        i[j.MouseWheelX] = 0, i[j.MouseWheelY] = 0, i[j.MouseWheelZ] = 0;
      }
    });
  }
  _handleGamepadActions() {
    this._gamepadConnectedEvent = (e) => {
      this._addGamePad(e.gamepad);
    }, this._gamepadDisconnectedEvent = (e) => {
      if (this._gamepads) {
        const t = this._getGamepadDeviceType(e.gamepad.id), i = e.gamepad.index;
        this._unregisterDevice(t, i), delete this._gamepads[i];
      }
    }, window.addEventListener("gamepadconnected", this._gamepadConnectedEvent), window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
  }
  _updateDevice(e, t, i) {
    const s = navigator.getGamepads()[t];
    if (s && e === this._gamepads[t]) {
      const r = this._inputs[e][t];
      i >= s.buttons.length ? r[i] = s.axes[i - s.buttons.length].valueOf() : r[i] = s.buttons[i].value;
    }
  }
  _getGamepadDeviceType(e) {
    return e.indexOf("054c") !== -1 ? e.indexOf("0ce6") !== -1 ? z.DualSense : z.DualShock : e.indexOf("Xbox One") !== -1 || e.search("Xbox 360") !== -1 || e.search("xinput") !== -1 ? z.Xbox : e.indexOf("057e") !== -1 ? z.Switch : z.Generic;
  }
  _getPointerType(e) {
    let t = z.Mouse;
    return (e.pointerType === "touch" || e.pointerType === "pen" || e.touches) && (t = z.Touch), t;
  }
}
class lr {
  constructor(e, t, i = 0) {
    this.deviceType = t, this.deviceSlot = i, this.onInputChangedObservable = new w(), this._deviceInputSystem = e;
  }
  getInput(e) {
    return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, e);
  }
}
class Nn {
  constructor(e) {
    this._registeredManagers = new Array(), this._refCount = 0, this.registerManager = (n) => {
      for (let a = 0; a < this._devices.length; a++) {
        const o = this._devices[a];
        for (const h in o) {
          const l = +h;
          n._addDevice(new lr(this._deviceInputSystem, a, l));
        }
      }
      this._registeredManagers.push(n);
    }, this.unregisterManager = (n) => {
      const a = this._registeredManagers.indexOf(n);
      a > -1 && this._registeredManagers.splice(a, 1);
    };
    const t = Object.keys(z).length / 2;
    this._devices = new Array(t);
    const i = (n, a) => {
      this._devices[n] || (this._devices[n] = new Array()), this._devices[n][a] || (this._devices[n][a] = a);
      for (const o of this._registeredManagers) {
        const h = new lr(this._deviceInputSystem, n, a);
        o._addDevice(h);
      }
    }, s = (n, a) => {
      var o;
      !((o = this._devices[n]) === null || o === void 0) && o[a] && delete this._devices[n][a];
      for (const h of this._registeredManagers)
        h._removeDevice(n, a);
    }, r = (n, a, o) => {
      if (o)
        for (const h of this._registeredManagers)
          h._onInputChanged(n, a, o);
    };
    typeof _native < "u" ? this._deviceInputSystem = new On(i, s, r) : this._deviceInputSystem = new Ln(e, i, s, r);
  }
  dispose() {
    this._deviceInputSystem.dispose();
  }
}
class Bn {
  constructor(e) {
    const t = Object.keys(z).length / 2;
    this._devices = new Array(t), this._firstDevice = new Array(t), this._engine = e, this._engine._deviceSourceManager || (this._engine._deviceSourceManager = new Nn(e)), this._engine._deviceSourceManager._refCount++, this.onDeviceConnectedObservable = new w((i) => {
      for (const s of this._devices)
        if (s)
          for (const r of s)
            r && this.onDeviceConnectedObservable.notifyObserver(i, r);
    }), this.onDeviceDisconnectedObservable = new w(), this._engine._deviceSourceManager.registerManager(this), this._onDisposeObserver = e.onDisposeObservable.add(() => {
      this.dispose();
    });
  }
  getDeviceSource(e, t) {
    if (t === void 0) {
      if (this._firstDevice[e] === void 0)
        return null;
      t = this._firstDevice[e];
    }
    return !this._devices[e] || this._devices[e][t] === void 0 ? null : this._devices[e][t];
  }
  getDeviceSources(e) {
    return this._devices[e] ? this._devices[e].filter((t) => !!t) : [];
  }
  dispose() {
    this.onDeviceConnectedObservable.clear(), this.onDeviceDisconnectedObservable.clear(), this._engine._deviceSourceManager && (this._engine._deviceSourceManager.unregisterManager(this), --this._engine._deviceSourceManager._refCount < 1 && (this._engine._deviceSourceManager.dispose(), delete this._engine._deviceSourceManager)), this._engine.onDisposeObservable.remove(this._onDisposeObserver);
  }
  _addDevice(e) {
    this._devices[e.deviceType] || (this._devices[e.deviceType] = new Array()), this._devices[e.deviceType][e.deviceSlot] || (this._devices[e.deviceType][e.deviceSlot] = e, this._updateFirstDevices(e.deviceType)), this.onDeviceConnectedObservable.notifyObservers(e);
  }
  _removeDevice(e, t) {
    var i, s;
    const r = (i = this._devices[e]) === null || i === void 0 ? void 0 : i[t];
    this.onDeviceDisconnectedObservable.notifyObservers(r), !((s = this._devices[e]) === null || s === void 0) && s[t] && delete this._devices[e][t], this._updateFirstDevices(e);
  }
  _onInputChanged(e, t, i) {
    var s, r;
    (r = (s = this._devices[e]) === null || s === void 0 ? void 0 : s[t]) === null || r === void 0 || r.onInputChangedObservable.notifyObservers(i);
  }
  _updateFirstDevices(e) {
    switch (e) {
      case z.Keyboard:
      case z.Mouse:
        this._firstDevice[e] = 0;
        break;
      case z.Touch:
      case z.DualSense:
      case z.DualShock:
      case z.Xbox:
      case z.Switch:
      case z.Generic: {
        delete this._firstDevice[e];
        const t = this._devices[e];
        if (t) {
          for (let i = 0; i < t.length; i++)
            if (t[i]) {
              this._firstDevice[e] = i;
              break;
            }
        }
        break;
      }
    }
  }
}
class cr {
  constructor() {
    this._singleClick = !1, this._doubleClick = !1, this._hasSwiped = !1, this._ignore = !1;
  }
  get singleClick() {
    return this._singleClick;
  }
  get doubleClick() {
    return this._doubleClick;
  }
  get hasSwiped() {
    return this._hasSwiped;
  }
  get ignore() {
    return this._ignore;
  }
  set singleClick(e) {
    this._singleClick = e;
  }
  set doubleClick(e) {
    this._doubleClick = e;
  }
  set hasSwiped(e) {
    this._hasSwiped = e;
  }
  set ignore(e) {
    this._ignore = e;
  }
}
class Pe {
  constructor(e) {
    this._alreadyAttached = !1, this._meshPickProceed = !1, this._currentPickResult = null, this._previousPickResult = null, this._totalPointersPressed = 0, this._doubleClickOccured = !1, this._isSwiping = !1, this._swipeButtonPressed = -1, this._skipPointerTap = !1, this._isMultiTouchGesture = !1, this._pointerX = 0, this._pointerY = 0, this._startingPointerPosition = new Te(0, 0), this._previousStartingPointerPosition = new Te(0, 0), this._startingPointerTime = 0, this._previousStartingPointerTime = 0, this._pointerCaptures = {}, this._meshUnderPointerId = {}, this._movePointerInfo = null, this._cameraObserverCount = 0, this._deviceSourceManager = null, this._scene = e || fe.LastCreatedScene, this._scene;
  }
  get meshUnderPointer() {
    return this._movePointerInfo && (this._movePointerInfo._generatePickInfo(), this._movePointerInfo = null), this._pointerOverMesh;
  }
  getMeshUnderPointerByPointerId(e) {
    return this._meshUnderPointerId[e] || null;
  }
  get unTranslatedPointer() {
    return new Te(this._unTranslatedPointerX, this._unTranslatedPointerY);
  }
  get pointerX() {
    return this._pointerX;
  }
  set pointerX(e) {
    this._pointerX = e;
  }
  get pointerY() {
    return this._pointerY;
  }
  set pointerY(e) {
    this._pointerY = e;
  }
  _updatePointerPosition(e) {
    const t = this._scene.getEngine().getInputElementClientRect();
    !t || (this._pointerX = e.clientX - t.left, this._pointerY = e.clientY - t.top, this._unTranslatedPointerX = this._pointerX, this._unTranslatedPointerY = this._pointerY);
  }
  _processPointerMove(e, t) {
    const i = this._scene, s = i.getEngine(), r = s.getInputElement();
    r && (r.tabIndex = s.canvasTabIndex, i.doNotHandleCursors || (r.style.cursor = i.defaultCursor)), this._setCursorAndPointerOverMesh(e, t.pointerId, i);
    for (const o of i._pointerMoveStage) {
      const h = !!(e != null && e.pickedMesh);
      e = o.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, h, r);
    }
    const n = t.inputIndex >= j.MouseWheelX && t.inputIndex <= j.MouseWheelZ ? ve.POINTERWHEEL : ve.POINTERMOVE;
    i.onPointerMove && (e = e || this._pickMove(t.pointerId), i.onPointerMove(t, e, n));
    let a;
    e ? (a = new ti(n, t, e), this._setRayOnPointerInfo(e, t)) : (a = new ti(n, t, null, this), this._movePointerInfo = a), i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(a, n);
  }
  _setRayOnPointerInfo(e, t) {
    const i = this._scene;
    e && i._pickingAvailable && (e.ray || (e.ray = i.createPickingRay(t.offsetX, t.offsetY, x.Identity(), i.activeCamera)));
  }
  _addCameraPointerObserver(e, t) {
    return this._cameraObserverCount++, this._scene.onPointerObservable.add(e, t);
  }
  _removeCameraPointerObserver(e) {
    return this._cameraObserverCount--, this._scene.onPointerObservable.remove(e);
  }
  _checkForPicking() {
    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);
  }
  _checkPrePointerObservable(e, t, i) {
    const s = this._scene, r = new wn(i, t, this._unTranslatedPointerX, this._unTranslatedPointerY);
    return e && (r.originalPickingInfo = e, r.ray = e.ray, e.originMesh && (r.nearInteractionPickingInfo = e)), s.onPrePointerObservable.notifyObservers(r, i), !!r.skipOnPointerObservable;
  }
  _pickMove(e) {
    const t = this._scene, i = t.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, t.pointerMovePredicate, !1, t.cameraToUseForPointers, t.pointerMoveTrianglePredicate);
    return this._setCursorAndPointerOverMesh(i, e, t), i;
  }
  _setCursorAndPointerOverMesh(e, t, i) {
    const r = i.getEngine().getInputElement();
    if (e != null && e.pickedMesh) {
      if (this.setPointerOverMesh(e.pickedMesh, t, e), !i.doNotHandleCursors && r && this._pointerOverMesh) {
        const n = this._pointerOverMesh._getActionManagerForTrigger();
        n && n.hasPointerTriggers && (r.style.cursor = n.hoverCursor || i.hoverCursor);
      }
    } else
      this.setPointerOverMesh(null, t, e);
  }
  simulatePointerMove(e, t) {
    const i = new PointerEvent("pointermove", t);
    i.inputIndex = j.Move, !this._checkPrePointerObservable(e, i, ve.POINTERMOVE) && this._processPointerMove(e, i);
  }
  simulatePointerDown(e, t) {
    const i = new PointerEvent("pointerdown", t);
    i.inputIndex = i.button + 2, !this._checkPrePointerObservable(e, i, ve.POINTERDOWN) && this._processPointerDown(e, i);
  }
  _processPointerDown(e, t) {
    const i = this._scene;
    if (e != null && e.pickedMesh) {
      this._pickedDownMesh = e.pickedMesh;
      const n = e.pickedMesh._getActionManagerForTrigger();
      if (n) {
        if (n.hasPickTriggers)
          switch (n.processTrigger(5, We.CreateNew(e.pickedMesh, t)), t.button) {
            case 0:
              n.processTrigger(2, We.CreateNew(e.pickedMesh, t));
              break;
            case 1:
              n.processTrigger(4, We.CreateNew(e.pickedMesh, t));
              break;
            case 2:
              n.processTrigger(3, We.CreateNew(e.pickedMesh, t));
              break;
          }
        n.hasSpecificTrigger(8) && window.setTimeout(() => {
          const a = i.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (o) => o.isPickable && o.isVisible && o.isReady() && o.actionManager && o.actionManager.hasSpecificTrigger(8) && o === this._pickedDownMesh, !1, i.cameraToUseForPointers);
          (a == null ? void 0 : a.pickedMesh) && n && this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > Pe.LongPressDelay && !this._isPointerSwiping() && (this._startingPointerTime = 0, n.processTrigger(8, We.CreateNew(a.pickedMesh, t)));
        }, Pe.LongPressDelay);
      }
    } else
      for (const n of i._pointerDownStage)
        e = n.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, !1);
    let s;
    const r = ve.POINTERDOWN;
    e ? (i.onPointerDown && i.onPointerDown(t, e, r), s = new ti(r, t, e), this._setRayOnPointerInfo(e, t)) : s = new ti(r, t, null, this), i.onPointerObservable.hasObservers() && i.onPointerObservable.notifyObservers(s, r);
  }
  _isPointerSwiping() {
    return this._isSwiping;
  }
  simulatePointerUp(e, t, i) {
    const s = new PointerEvent("pointerup", t);
    s.inputIndex = j.Move;
    const r = new cr();
    i ? r.doubleClick = !0 : r.singleClick = !0, !this._checkPrePointerObservable(e, s, ve.POINTERUP) && this._processPointerUp(e, s, r);
  }
  _processPointerUp(e, t, i) {
    const s = this._scene;
    if (e != null && e.pickedMesh) {
      if (this._pickedUpMesh = e.pickedMesh, this._pickedDownMesh === this._pickedUpMesh && (s.onPointerPick && s.onPointerPick(t, e), i.singleClick && !i.ignore && s.onPointerObservable.observers.length > this._cameraObserverCount)) {
        const n = ve.POINTERPICK, a = new ti(n, t, e);
        this._setRayOnPointerInfo(e, t), s.onPointerObservable.notifyObservers(a, n);
      }
      const r = e.pickedMesh._getActionManagerForTrigger();
      if (r && !i.ignore) {
        r.processTrigger(7, We.CreateNew(e.pickedMesh, t, e)), !i.hasSwiped && i.singleClick && r.processTrigger(1, We.CreateNew(e.pickedMesh, t, e));
        const n = e.pickedMesh._getActionManagerForTrigger(6);
        i.doubleClick && n && n.processTrigger(6, We.CreateNew(e.pickedMesh, t, e));
      }
    } else if (!i.ignore)
      for (const r of s._pointerUpStage)
        e = r.action(this._unTranslatedPointerX, this._unTranslatedPointerY, e, t, i.doubleClick);
    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
      const r = this._pickedDownMesh._getActionManagerForTrigger(16);
      r && r.processTrigger(16, We.CreateNew(this._pickedDownMesh, t));
    }
    if (!i.ignore) {
      const r = new ti(ve.POINTERUP, t, e);
      if (this._setRayOnPointerInfo(e, t), s.onPointerObservable.notifyObservers(r, ve.POINTERUP), s.onPointerUp && s.onPointerUp(t, e, ve.POINTERUP), !i.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {
        let n = 0;
        if (i.singleClick ? n = ve.POINTERTAP : i.doubleClick && (n = ve.POINTERDOUBLETAP), n) {
          const a = new ti(n, t, e);
          s.onPointerObservable.hasObservers() && s.onPointerObservable.hasSpecificMask(n) && s.onPointerObservable.notifyObservers(a, n);
        }
      }
    }
  }
  isPointerCaptured(e = 0) {
    return this._pointerCaptures[e];
  }
  attachControl(e = !0, t = !0, i = !0, s = null) {
    const r = this._scene, n = r.getEngine();
    s || (s = n.getInputElement()), this._alreadyAttached && this.detachControl(), s && (this._alreadyAttachedTo = s), this._deviceSourceManager = new Bn(n), this._initActionManager = (a) => {
      if (!this._meshPickProceed) {
        const o = r.skipPointerUpPicking || r._registeredActions === 0 && !this._checkForPicking() && !r.onPointerUp ? null : r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerUpPredicate, !1, r.cameraToUseForPointers);
        this._currentPickResult = o, o && (a = o.hit && o.pickedMesh ? o.pickedMesh._getActionManagerForTrigger() : null), this._meshPickProceed = !0;
      }
      return a;
    }, this._delayedSimpleClick = (a, o, h) => {
      (Date.now() - this._previousStartingPointerTime > Pe.DoubleClickDelay && !this._doubleClickOccured || a !== this._previousButtonPressed) && (this._doubleClickOccured = !1, o.singleClick = !0, o.ignore = !1, h(o, this._currentPickResult));
    }, this._initClickEvent = (a, o, h, l) => {
      const u = new cr();
      this._currentPickResult = null;
      let d = null, f = a.hasSpecificMask(ve.POINTERPICK) || o.hasSpecificMask(ve.POINTERPICK) || a.hasSpecificMask(ve.POINTERTAP) || o.hasSpecificMask(ve.POINTERTAP) || a.hasSpecificMask(ve.POINTERDOUBLETAP) || o.hasSpecificMask(ve.POINTERDOUBLETAP);
      !f && ct && (d = this._initActionManager(d, u), d && (f = d.hasPickTriggers));
      let _ = !1;
      if (f) {
        const E = h.button;
        if (u.hasSwiped = this._isPointerSwiping(), !u.hasSwiped) {
          let m = !Pe.ExclusiveDoubleClickMode;
          m || (m = !a.hasSpecificMask(ve.POINTERDOUBLETAP) && !o.hasSpecificMask(ve.POINTERDOUBLETAP), m && !ct.HasSpecificTrigger(6) && (d = this._initActionManager(d, u), d && (m = !d.hasSpecificTrigger(6)))), m ? (Date.now() - this._previousStartingPointerTime > Pe.DoubleClickDelay || E !== this._previousButtonPressed) && (u.singleClick = !0, l(u, this._currentPickResult), _ = !0) : (this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout, this._delayedSimpleClickTimeout = window.setTimeout(this._delayedSimpleClick.bind(this, E, u, l), Pe.DoubleClickDelay));
          let v = a.hasSpecificMask(ve.POINTERDOUBLETAP) || o.hasSpecificMask(ve.POINTERDOUBLETAP);
          !v && ct.HasSpecificTrigger(6) && (d = this._initActionManager(d, u), d && (v = d.hasSpecificTrigger(6))), v && (E === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < Pe.DoubleClickDelay && !this._doubleClickOccured ? (!u.hasSwiped && !this._isPointerSwiping() ? (this._previousStartingPointerTime = 0, this._doubleClickOccured = !0, u.doubleClick = !0, u.ignore = !1, Pe.ExclusiveDoubleClickMode && this._previousDelayedSimpleClickTimeout && clearTimeout(this._previousDelayedSimpleClickTimeout), this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout, l(u, this._currentPickResult)) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = E, Pe.ExclusiveDoubleClickMode ? (this._previousDelayedSimpleClickTimeout && clearTimeout(this._previousDelayedSimpleClickTimeout), this._previousDelayedSimpleClickTimeout = this._delayedSimpleClickTimeout, l(u, this._previousPickResult)) : l(u, this._currentPickResult)), _ = !0) : (this._doubleClickOccured = !1, this._previousStartingPointerTime = this._startingPointerTime, this._previousStartingPointerPosition.x = this._startingPointerPosition.x, this._previousStartingPointerPosition.y = this._startingPointerPosition.y, this._previousButtonPressed = E));
        }
      }
      _ || l(u, this._currentPickResult);
    }, this._onPointerMove = (a) => {
      if (a.pointerId === void 0 && (a.pointerId = 0), this._updatePointerPosition(a), !this._isSwiping && this._swipeButtonPressed !== -1 && (this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > Pe.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > Pe.DragMovementThreshold), this._checkPrePointerObservable(null, a, a.inputIndex >= j.MouseWheelX && a.inputIndex <= j.MouseWheelZ ? ve.POINTERWHEEL : ve.POINTERMOVE) || !r.cameraToUseForPointers && !r.activeCamera)
        return;
      if (r.skipPointerMovePicking) {
        this._processPointerMove(new zt(), a);
        return;
      }
      r.pointerMovePredicate || (r.pointerMovePredicate = (h) => h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (h.enablePointerMoveEvents || r.constantlyUpdateMeshUnderPointer || h._getActionManagerForTrigger() !== null) && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & h.layerMask) !== 0));
      const o = r._registeredActions > 0 ? this._pickMove(a.pointerId) : null;
      this._processPointerMove(o, a);
    }, this._onPointerDown = (a) => {
      if (this._totalPointersPressed++, this._pickedDownMesh = null, this._meshPickProceed = !1, a.pointerId === void 0 && (a.pointerId = 0), this._updatePointerPosition(a), this._swipeButtonPressed === -1 && (this._swipeButtonPressed = a.button), r.preventDefaultOnPointerDown && s && (a.preventDefault(), s.focus()), this._startingPointerPosition.x = this._pointerX, this._startingPointerPosition.y = this._pointerY, this._startingPointerTime = Date.now(), this._checkPrePointerObservable(null, a, ve.POINTERDOWN) || !r.cameraToUseForPointers && !r.activeCamera)
        return;
      this._pointerCaptures[a.pointerId] = !0, r.pointerDownPredicate || (r.pointerDownPredicate = (h) => h.isPickable && h.isVisible && h.isReady() && h.isEnabled() && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & h.layerMask) !== 0)), this._pickedDownMesh = null;
      let o;
      r.skipPointerDownPicking || r._registeredActions === 0 && !this._checkForPicking() && !r.onPointerDown ? o = new zt() : o = r.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, r.pointerDownPredicate, !1, r.cameraToUseForPointers), this._processPointerDown(o, a);
    }, this._onPointerUp = (a) => {
      this._totalPointersPressed !== 0 && (this._totalPointersPressed--, this._pickedUpMesh = null, this._meshPickProceed = !1, a.pointerId === void 0 && (a.pointerId = 0), this._updatePointerPosition(a), r.preventDefaultOnPointerUp && s && (a.preventDefault(), s.focus()), this._initClickEvent(r.onPrePointerObservable, r.onPointerObservable, a, (o, h) => {
        if (r.onPrePointerObservable.hasObservers() && (this._skipPointerTap = !1, !o.ignore)) {
          if (this._checkPrePointerObservable(null, a, ve.POINTERUP)) {
            this._swipeButtonPressed === a.button && (this._isSwiping = !1, this._swipeButtonPressed = -1);
            return;
          }
          o.hasSwiped || (o.singleClick && r.onPrePointerObservable.hasSpecificMask(ve.POINTERTAP) && this._checkPrePointerObservable(null, a, ve.POINTERTAP) && (this._skipPointerTap = !0), o.doubleClick && r.onPrePointerObservable.hasSpecificMask(ve.POINTERDOUBLETAP) && this._checkPrePointerObservable(null, a, ve.POINTERDOUBLETAP) && (this._skipPointerTap = !0));
        }
        this._pointerCaptures[a.pointerId] = !1, !(!r.cameraToUseForPointers && !r.activeCamera) && (r.pointerUpPredicate || (r.pointerUpPredicate = (l) => l.isPickable && l.isVisible && l.isReady() && l.isEnabled() && (!r.cameraToUseForPointers || (r.cameraToUseForPointers.layerMask & l.layerMask) !== 0)), !this._meshPickProceed && (ct && ct.HasTriggers || this._checkForPicking() || r.onPointerUp) && this._initActionManager(null, o), h || (h = this._currentPickResult), this._processPointerUp(h, a, o), this._previousPickResult = this._currentPickResult, this._swipeButtonPressed === a.button && (this._isSwiping = !1, this._swipeButtonPressed = -1));
      }));
    }, this._onKeyDown = (a) => {
      const o = is.KEYDOWN;
      if (r.onPreKeyboardObservable.hasObservers()) {
        const h = new tr(o, a);
        if (r.onPreKeyboardObservable.notifyObservers(h, o), h.skipOnKeyboardObservable)
          return;
      }
      if (r.onKeyboardObservable.hasObservers()) {
        const h = new Os(o, a);
        r.onKeyboardObservable.notifyObservers(h, o);
      }
      r.actionManager && r.actionManager.processTrigger(14, We.CreateNewFromScene(r, a));
    }, this._onKeyUp = (a) => {
      const o = is.KEYUP;
      if (r.onPreKeyboardObservable.hasObservers()) {
        const h = new tr(o, a);
        if (r.onPreKeyboardObservable.notifyObservers(h, o), h.skipOnKeyboardObservable)
          return;
      }
      if (r.onKeyboardObservable.hasObservers()) {
        const h = new Os(o, a);
        r.onKeyboardObservable.notifyObservers(h, o);
      }
      r.actionManager && r.actionManager.processTrigger(15, We.CreateNewFromScene(r, a));
    }, this._deviceSourceManager.onDeviceConnectedObservable.add((a) => {
      a.deviceType === z.Mouse ? a.onInputChangedObservable.add((o) => {
        o.inputIndex === j.LeftClick || o.inputIndex === j.MiddleClick || o.inputIndex === j.RightClick || o.inputIndex === j.BrowserBack || o.inputIndex === j.BrowserForward ? t && a.getInput(o.inputIndex) === 1 ? this._onPointerDown(o) : e && a.getInput(o.inputIndex) === 0 && this._onPointerUp(o) : i && (o.inputIndex === j.Move ? this._onPointerMove(o) : (o.inputIndex === j.MouseWheelX || o.inputIndex === j.MouseWheelY || o.inputIndex === j.MouseWheelZ) && this._onPointerMove(o));
      }) : a.deviceType === z.Touch ? a.onInputChangedObservable.add((o) => {
        o.inputIndex === j.LeftClick && (t && a.getInput(o.inputIndex) === 1 ? (this._onPointerDown(o), this._totalPointersPressed > 1 && (this._isMultiTouchGesture = !0)) : e && a.getInput(o.inputIndex) === 0 && (this._onPointerUp(o), this._totalPointersPressed === 0 && (this._isMultiTouchGesture = !1))), i && o.inputIndex === j.Move && this._onPointerMove(o);
      }) : a.deviceType === z.Keyboard && a.onInputChangedObservable.add((o) => {
        o.type === "keydown" ? this._onKeyDown(o) : o.type === "keyup" && this._onKeyUp(o);
      });
    }), this._alreadyAttached = !0;
  }
  detachControl() {
    this._alreadyAttached && (this._deviceSourceManager.dispose(), this._deviceSourceManager = null, this._alreadyAttachedTo && !this._scene.doNotHandleCursors && (this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor), this._alreadyAttached = !1, this._alreadyAttachedTo = null);
  }
  setPointerOverMesh(e, t = 0, i) {
    if (this._meshUnderPointerId[t] === e && (!e || !e._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting))
      return;
    const s = this._meshUnderPointerId[t];
    let r;
    s && (r = s._getActionManagerForTrigger(10), r && r.processTrigger(10, We.CreateNew(s, void 0, { pointerId: t }))), e ? (this._meshUnderPointerId[t] = e, this._pointerOverMesh = e, r = e._getActionManagerForTrigger(9), r && r.processTrigger(9, We.CreateNew(e, void 0, { pointerId: t, pickResult: i }))) : (delete this._meshUnderPointerId[t], this._pointerOverMesh = null);
  }
  getPointerOverMesh() {
    return this.meshUnderPointer;
  }
  _invalidateMesh(e) {
    this._pointerOverMesh === e && (this._pointerOverMesh = null), this._pickedDownMesh === e && (this._pickedDownMesh = null), this._pickedUpMesh === e && (this._pickedUpMesh = null);
    for (const t in this._meshUnderPointerId)
      this._meshUnderPointerId[t] === e && delete this._meshUnderPointerId[t];
  }
}
Pe.DragMovementThreshold = 10;
Pe.LongPressDelay = 500;
Pe.DoubleClickDelay = 300;
Pe.ExclusiveDoubleClickMode = !1;
class xt {
  constructor(e, t, i, s) {
    this.normal = new p(e, t, i), this.d = s;
  }
  asArray() {
    return [this.normal.x, this.normal.y, this.normal.z, this.d];
  }
  clone() {
    return new xt(this.normal.x, this.normal.y, this.normal.z, this.d);
  }
  getClassName() {
    return "Plane";
  }
  getHashCode() {
    let e = this.normal.getHashCode();
    return e = e * 397 ^ (this.d | 0), e;
  }
  normalize() {
    const e = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
    let t = 0;
    return e !== 0 && (t = 1 / e), this.normal.x *= t, this.normal.y *= t, this.normal.z *= t, this.d *= t, this;
  }
  transform(e) {
    const t = xt._TmpMatrix;
    e.invertToRef(t);
    const i = t.m, s = this.normal.x, r = this.normal.y, n = this.normal.z, a = this.d, o = s * i[0] + r * i[1] + n * i[2] + a * i[3], h = s * i[4] + r * i[5] + n * i[6] + a * i[7], l = s * i[8] + r * i[9] + n * i[10] + a * i[11], u = s * i[12] + r * i[13] + n * i[14] + a * i[15];
    return new xt(o, h, l, u);
  }
  dotCoordinate(e) {
    return this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z + this.d;
  }
  copyFromPoints(e, t, i) {
    const s = t.x - e.x, r = t.y - e.y, n = t.z - e.z, a = i.x - e.x, o = i.y - e.y, h = i.z - e.z, l = r * h - n * o, u = n * a - s * h, d = s * o - r * a, f = Math.sqrt(l * l + u * u + d * d);
    let _;
    return f !== 0 ? _ = 1 / f : _ = 0, this.normal.x = l * _, this.normal.y = u * _, this.normal.z = d * _, this.d = -(this.normal.x * e.x + this.normal.y * e.y + this.normal.z * e.z), this;
  }
  isFrontFacingTo(e, t) {
    return p.Dot(this.normal, e) <= t;
  }
  signedDistanceTo(e) {
    return p.Dot(e, this.normal) + this.d;
  }
  static FromArray(e) {
    return new xt(e[0], e[1], e[2], e[3]);
  }
  static FromPoints(e, t, i) {
    const s = new xt(0, 0, 0, 0);
    return s.copyFromPoints(e, t, i), s;
  }
  static FromPositionAndNormal(e, t) {
    const i = new xt(0, 0, 0, 0);
    return t.normalize(), i.normal = t, i.d = -(t.x * e.x + t.y * e.y + t.z * e.z), i;
  }
  static SignedDistanceToPlaneFromPositionAndNormal(e, t, i) {
    const s = -(t.x * e.x + t.y * e.y + t.z * e.z);
    return p.Dot(i, t) + s;
  }
}
xt._TmpMatrix = x.Identity();
class mt {
  static GetPlanes(e) {
    const t = [];
    for (let i = 0; i < 6; i++)
      t.push(new xt(0, 0, 0, 0));
    return mt.GetPlanesToRef(e, t), t;
  }
  static GetNearPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] + i[2], t.normal.y = i[7] + i[6], t.normal.z = i[11] + i[10], t.d = i[15] + i[14], t.normalize();
  }
  static GetFarPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] - i[2], t.normal.y = i[7] - i[6], t.normal.z = i[11] - i[10], t.d = i[15] - i[14], t.normalize();
  }
  static GetLeftPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] + i[0], t.normal.y = i[7] + i[4], t.normal.z = i[11] + i[8], t.d = i[15] + i[12], t.normalize();
  }
  static GetRightPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] - i[0], t.normal.y = i[7] - i[4], t.normal.z = i[11] - i[8], t.d = i[15] - i[12], t.normalize();
  }
  static GetTopPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] - i[1], t.normal.y = i[7] - i[5], t.normal.z = i[11] - i[9], t.d = i[15] - i[13], t.normalize();
  }
  static GetBottomPlaneToRef(e, t) {
    const i = e.m;
    t.normal.x = i[3] + i[1], t.normal.y = i[7] + i[5], t.normal.z = i[11] + i[9], t.d = i[15] + i[13], t.normalize();
  }
  static GetPlanesToRef(e, t) {
    mt.GetNearPlaneToRef(e, t[0]), mt.GetFarPlaneToRef(e, t[1]), mt.GetLeftPlaneToRef(e, t[2]), mt.GetRightPlaneToRef(e, t[3]), mt.GetTopPlaneToRef(e, t[4]), mt.GetBottomPlaneToRef(e, t[5]);
  }
}
class Or {
  static get UniqueId() {
    const e = this._UniqueIdCounter;
    return this._UniqueIdCounter++, e;
  }
}
Or._UniqueIdCounter = 1;
class Ee {
  static CompareLightsPriority(e, t) {
    return e.shadowEnabled !== t.shadowEnabled ? (t.shadowEnabled ? 1 : 0) - (e.shadowEnabled ? 1 : 0) : t.renderPriority - e.renderPriority;
  }
}
Ee.FALLOFF_DEFAULT = 0;
Ee.FALLOFF_PHYSICAL = 1;
Ee.FALLOFF_GLTF = 2;
Ee.FALLOFF_STANDARD = 3;
Ee.LIGHTMAP_DEFAULT = 0;
Ee.LIGHTMAP_SPECULAR = 1;
Ee.LIGHTMAP_SHADOWSONLY = 2;
Ee.INTENSITYMODE_AUTOMATIC = 0;
Ee.INTENSITYMODE_LUMINOUSPOWER = 1;
Ee.INTENSITYMODE_LUMINOUSINTENSITY = 2;
Ee.INTENSITYMODE_ILLUMINANCE = 3;
Ee.INTENSITYMODE_LUMINANCE = 4;
Ee.LIGHTTYPEID_POINTLIGHT = 0;
Ee.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
Ee.LIGHTTYPEID_SPOTLIGHT = 2;
Ee.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
var Ct;
(function(c) {
  c[c.BackwardCompatible = 0] = "BackwardCompatible", c[c.Intermediate = 1] = "Intermediate", c[c.Aggressive = 2] = "Aggressive";
})(Ct || (Ct = {}));
class re extends as {
  constructor(e, t) {
    super(), this._inputManager = new Pe(this), this.cameraToUseForPointers = null, this._isScene = !0, this._blockEntityCollection = !1, this.autoClear = !0, this.autoClearDepthAndStencil = !0, this.clearColor = new ge(0.2, 0.2, 0.3, 1), this.ambientColor = new se(0, 0, 0), this.environmentIntensity = 1, this._performancePriority = Ct.BackwardCompatible, this._forceWireframe = !1, this._skipFrustumClipping = !1, this._forcePointsCloud = !1, this.animationsEnabled = !0, this._animationPropertiesOverride = null, this.useConstantAnimationDeltaTime = !1, this.constantlyUpdateMeshUnderPointer = !1, this.hoverCursor = "pointer", this.defaultCursor = "", this.doNotHandleCursors = !1, this.preventDefaultOnPointerDown = !0, this.preventDefaultOnPointerUp = !0, this.metadata = null, this.reservedDataStore = null, this.disableOfflineSupportExceptionRules = new Array(), this.onDisposeObservable = new w(), this._onDisposeObserver = null, this.onBeforeRenderObservable = new w(), this._onBeforeRenderObserver = null, this.onAfterRenderObservable = new w(), this.onAfterRenderCameraObservable = new w(), this._onAfterRenderObserver = null, this.onBeforeAnimationsObservable = new w(), this.onAfterAnimationsObservable = new w(), this.onBeforeDrawPhaseObservable = new w(), this.onAfterDrawPhaseObservable = new w(), this.onReadyObservable = new w(), this.onBeforeCameraRenderObservable = new w(), this._onBeforeCameraRenderObserver = null, this.onAfterCameraRenderObservable = new w(), this._onAfterCameraRenderObserver = null, this.onBeforeActiveMeshesEvaluationObservable = new w(), this.onAfterActiveMeshesEvaluationObservable = new w(), this.onBeforeParticlesRenderingObservable = new w(), this.onAfterParticlesRenderingObservable = new w(), this.onDataLoadedObservable = new w(), this.onNewCameraAddedObservable = new w(), this.onCameraRemovedObservable = new w(), this.onNewLightAddedObservable = new w(), this.onLightRemovedObservable = new w(), this.onNewGeometryAddedObservable = new w(), this.onGeometryRemovedObservable = new w(), this.onNewTransformNodeAddedObservable = new w(), this.onTransformNodeRemovedObservable = new w(), this.onNewMeshAddedObservable = new w(), this.onMeshRemovedObservable = new w(), this.onNewSkeletonAddedObservable = new w(), this.onSkeletonRemovedObservable = new w(), this.onNewMaterialAddedObservable = new w(), this.onNewMultiMaterialAddedObservable = new w(), this.onMaterialRemovedObservable = new w(), this.onMultiMaterialRemovedObservable = new w(), this.onNewTextureAddedObservable = new w(), this.onTextureRemovedObservable = new w(), this.onBeforeRenderTargetsRenderObservable = new w(), this.onAfterRenderTargetsRenderObservable = new w(), this.onBeforeStepObservable = new w(), this.onAfterStepObservable = new w(), this.onActiveCameraChanged = new w(), this.onActiveCamerasChanged = new w(), this.onBeforeRenderingGroupObservable = new w(), this.onAfterRenderingGroupObservable = new w(), this.onMeshImportedObservable = new w(), this.onAnimationFileImportedObservable = new w(), this._registeredForLateAnimationBindings = new ii(256), this.skipPointerMovePicking = !1, this.skipPointerDownPicking = !1, this.skipPointerUpPicking = !1, this.onPrePointerObservable = new w(), this.onPointerObservable = new w(), this.onPreKeyboardObservable = new w(), this.onKeyboardObservable = new w(), this._useRightHandedSystem = !1, this._timeAccumulator = 0, this._currentStepId = 0, this._currentInternalStep = 0, this._fogEnabled = !0, this._fogMode = re.FOGMODE_NONE, this.fogColor = new se(0.2, 0.2, 0.3), this.fogDensity = 0.1, this.fogStart = 0, this.fogEnd = 1e3, this.needsPreviousWorldMatrices = !1, this._shadowsEnabled = !0, this._lightsEnabled = !0, this._unObserveActiveCameras = null, this._texturesEnabled = !0, this.physicsEnabled = !0, this.particlesEnabled = !0, this.spritesEnabled = !0, this._skeletonsEnabled = !0, this.lensFlaresEnabled = !0, this.collisionsEnabled = !0, this.gravity = new p(0, -9.807, 0), this.postProcessesEnabled = !0, this.renderTargetsEnabled = !0, this.dumpNextRenderTargets = !1, this.customRenderTargets = new Array(), this.importedMeshesFiles = new Array(), this.probesEnabled = !0, this._meshesForIntersections = new ii(256), this.proceduralTexturesEnabled = !0, this._totalVertices = new yt(), this._activeIndices = new yt(), this._activeParticles = new yt(), this._activeBones = new yt(), this._animationTime = 0, this.animationTimeScale = 1, this._renderId = 0, this._frameId = 0, this._executeWhenReadyTimeoutId = null, this._intermediateRendering = !1, this._defaultFrameBufferCleared = !1, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1, this._toBeDisposed = new Array(256), this._activeRequests = new Array(), this._pendingData = new Array(), this._isDisposed = !1, this.dispatchAllSubMeshesOfActiveMeshes = !1, this._activeMeshes = new Qe(256), this._processedMaterials = new Qe(256), this._renderTargets = new ii(256), this._materialsRenderTargets = new ii(256), this._activeParticleSystems = new Qe(256), this._activeSkeletons = new ii(32), this._softwareSkinnedMeshes = new ii(32), this._activeAnimatables = new Array(), this._transformMatrix = x.Zero(), this.requireLightSorting = !1, this._components = [], this._serializableComponents = [], this._transientComponents = [], this._beforeCameraUpdateStage = ye.Create(), this._beforeClearStage = ye.Create(), this._beforeRenderTargetClearStage = ye.Create(), this._gatherRenderTargetsStage = ye.Create(), this._gatherActiveCameraRenderTargetsStage = ye.Create(), this._isReadyForMeshStage = ye.Create(), this._beforeEvaluateActiveMeshStage = ye.Create(), this._evaluateSubMeshStage = ye.Create(), this._preActiveMeshStage = ye.Create(), this._cameraDrawRenderTargetStage = ye.Create(), this._beforeCameraDrawStage = ye.Create(), this._beforeRenderTargetDrawStage = ye.Create(), this._beforeRenderingGroupDrawStage = ye.Create(), this._beforeRenderingMeshStage = ye.Create(), this._afterRenderingMeshStage = ye.Create(), this._afterRenderingGroupDrawStage = ye.Create(), this._afterCameraDrawStage = ye.Create(), this._afterCameraPostProcessStage = ye.Create(), this._afterRenderTargetDrawStage = ye.Create(), this._afterRenderTargetPostProcessStage = ye.Create(), this._afterRenderStage = ye.Create(), this._pointerMoveStage = ye.Create(), this._pointerDownStage = ye.Create(), this._pointerUpStage = ye.Create(), this._geometriesByUniqueId = null, this._defaultMeshCandidates = {
      data: [],
      length: 0
    }, this._defaultSubMeshCandidates = {
      data: [],
      length: 0
    }, this._preventFreeActiveMeshesAndRenderingGroups = !1, this._activeMeshesFrozen = !1, this._activeMeshesFrozenButKeepClipping = !1, this._skipEvaluateActiveMeshesCompletely = !1, this._allowPostProcessClearColor = !0, this.getDeterministicFrameTime = () => this._engine.getTimeStep(), this._registeredActions = 0, this._blockMaterialDirtyMechanism = !1, this._perfCollector = null, this.activeCameras = new Array();
    const i = {
      useGeometryUniqueIdsMap: !0,
      useMaterialMeshMap: !0,
      useClonedMeshMap: !0,
      virtual: !1,
      ...t
    };
    this._engine = e || fe.LastCreatedEngine, i.virtual ? this._engine._virtualScenes.push(this) : (fe._LastCreatedScene = this, this._engine.scenes.push(this)), this._uid = null, this._renderingManager = new ze(this), ts && (this.postProcessManager = new ts(this)), Ze() && this.attachControl(), this._createUbo(), me && (this._imageProcessingConfiguration = new me()), this.setDefaultCandidateProviders(), i.useGeometryUniqueIdsMap && (this._geometriesByUniqueId = {}), this.useMaterialMeshMap = i.useMaterialMeshMap, this.useClonedMeshMap = i.useClonedMeshMap, (!t || !t.virtual) && this._engine.onNewSceneAddedObservable.notifyObservers(this);
  }
  static DefaultMaterialFactory(e) {
    throw Q("StandardMaterial");
  }
  static CollisionCoordinatorFactory() {
    throw Q("DefaultCollisionCoordinator");
  }
  get environmentTexture() {
    return this._environmentTexture;
  }
  set environmentTexture(e) {
    this._environmentTexture !== e && (this._environmentTexture = e, this.markAllMaterialsAsDirty(1));
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  get performancePriority() {
    return this._performancePriority;
  }
  set performancePriority(e) {
    if (e !== this._performancePriority)
      switch (this._performancePriority = e, e) {
        case Ct.BackwardCompatible:
          this.skipFrustumClipping = !1, this._renderingManager.maintainStateBetweenFrames = !1, this.skipPointerMovePicking = !1, this.autoClear = !0;
          break;
        case Ct.Intermediate:
          this.skipFrustumClipping = !1, this._renderingManager.maintainStateBetweenFrames = !1, this.skipPointerMovePicking = !0, this.autoClear = !1;
          break;
        case Ct.Aggressive:
          this.skipFrustumClipping = !0, this._renderingManager.maintainStateBetweenFrames = !0, this.skipPointerMovePicking = !0, this.autoClear = !1;
          break;
      }
  }
  set forceWireframe(e) {
    this._forceWireframe !== e && (this._forceWireframe = e, this.markAllMaterialsAsDirty(16));
  }
  get forceWireframe() {
    return this._forceWireframe;
  }
  set skipFrustumClipping(e) {
    this._skipFrustumClipping !== e && (this._skipFrustumClipping = e);
  }
  get skipFrustumClipping() {
    return this._skipFrustumClipping;
  }
  set forcePointsCloud(e) {
    this._forcePointsCloud !== e && (this._forcePointsCloud = e, this.markAllMaterialsAsDirty(16));
  }
  get forcePointsCloud() {
    return this._forcePointsCloud;
  }
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride;
  }
  set animationPropertiesOverride(e) {
    this._animationPropertiesOverride = e;
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  set beforeRender(e) {
    this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), e && (this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e));
  }
  set afterRender(e) {
    this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), e && (this._onAfterRenderObserver = this.onAfterRenderObservable.add(e));
  }
  set beforeCameraRender(e) {
    this._onBeforeCameraRenderObserver && this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver), this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(e);
  }
  set afterCameraRender(e) {
    this._onAfterCameraRenderObserver && this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver), this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(e);
  }
  get unTranslatedPointer() {
    return this._inputManager.unTranslatedPointer;
  }
  static get DragMovementThreshold() {
    return Pe.DragMovementThreshold;
  }
  static set DragMovementThreshold(e) {
    Pe.DragMovementThreshold = e;
  }
  static get LongPressDelay() {
    return Pe.LongPressDelay;
  }
  static set LongPressDelay(e) {
    Pe.LongPressDelay = e;
  }
  static get DoubleClickDelay() {
    return Pe.DoubleClickDelay;
  }
  static set DoubleClickDelay(e) {
    Pe.DoubleClickDelay = e;
  }
  static get ExclusiveDoubleClickMode() {
    return Pe.ExclusiveDoubleClickMode;
  }
  static set ExclusiveDoubleClickMode(e) {
    Pe.ExclusiveDoubleClickMode = e;
  }
  bindEyePosition(e, t = "vEyePosition", i = !1) {
    var s;
    const r = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (s = this.activeCamera.globalPosition) !== null && s !== void 0 ? s : this.activeCamera.devicePosition, n = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
    return D.Vector4[0].set(r.x, r.y, r.z, n ? -1 : 1), e && (i ? e.setFloat3(t, D.Vector4[0].x, D.Vector4[0].y, D.Vector4[0].z) : e.setVector4(t, D.Vector4[0])), D.Vector4[0];
  }
  finalizeSceneUbo() {
    const e = this.getSceneUniformBuffer(), t = this.bindEyePosition(null);
    return e.updateFloat4("vEyePosition", t.x, t.y, t.z, t.w), e.update(), e;
  }
  set useRightHandedSystem(e) {
    this._useRightHandedSystem !== e && (this._useRightHandedSystem = e, this.markAllMaterialsAsDirty(16));
  }
  get useRightHandedSystem() {
    return this._useRightHandedSystem;
  }
  setStepId(e) {
    this._currentStepId = e;
  }
  getStepId() {
    return this._currentStepId;
  }
  getInternalStep() {
    return this._currentInternalStep;
  }
  set fogEnabled(e) {
    this._fogEnabled !== e && (this._fogEnabled = e, this.markAllMaterialsAsDirty(16));
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  set fogMode(e) {
    this._fogMode !== e && (this._fogMode = e, this.markAllMaterialsAsDirty(16));
  }
  get fogMode() {
    return this._fogMode;
  }
  get prePass() {
    return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
  }
  set shadowsEnabled(e) {
    this._shadowsEnabled !== e && (this._shadowsEnabled = e, this.markAllMaterialsAsDirty(2));
  }
  get shadowsEnabled() {
    return this._shadowsEnabled;
  }
  set lightsEnabled(e) {
    this._lightsEnabled !== e && (this._lightsEnabled = e, this.markAllMaterialsAsDirty(2));
  }
  get lightsEnabled() {
    return this._lightsEnabled;
  }
  get activeCameras() {
    return this._activeCameras;
  }
  set activeCameras(e) {
    this._unObserveActiveCameras && (this._unObserveActiveCameras(), this._unObserveActiveCameras = null), e && (this._unObserveActiveCameras = br(e, () => {
      this.onActiveCamerasChanged.notifyObservers(this);
    })), this._activeCameras = e;
  }
  get activeCamera() {
    return this._activeCamera;
  }
  set activeCamera(e) {
    e !== this._activeCamera && (this._activeCamera = e, this.onActiveCameraChanged.notifyObservers(this));
  }
  get defaultMaterial() {
    return this._defaultMaterial || (this._defaultMaterial = re.DefaultMaterialFactory(this)), this._defaultMaterial;
  }
  set defaultMaterial(e) {
    this._defaultMaterial = e;
  }
  set texturesEnabled(e) {
    this._texturesEnabled !== e && (this._texturesEnabled = e, this.markAllMaterialsAsDirty(1));
  }
  get texturesEnabled() {
    return this._texturesEnabled;
  }
  set skeletonsEnabled(e) {
    this._skeletonsEnabled !== e && (this._skeletonsEnabled = e, this.markAllMaterialsAsDirty(8));
  }
  get skeletonsEnabled() {
    return this._skeletonsEnabled;
  }
  get collisionCoordinator() {
    return this._collisionCoordinator || (this._collisionCoordinator = re.CollisionCoordinatorFactory(), this._collisionCoordinator.init(this)), this._collisionCoordinator;
  }
  get renderingManager() {
    return this._renderingManager;
  }
  get frustumPlanes() {
    return this._frustumPlanes;
  }
  _registerTransientComponents() {
    if (this._transientComponents.length > 0) {
      for (const e of this._transientComponents)
        e.register();
      this._transientComponents.length = 0;
    }
  }
  _addComponent(e) {
    this._components.push(e), this._transientComponents.push(e);
    const t = e;
    t.addFromContainer && t.serialize && this._serializableComponents.push(t);
  }
  _getComponent(e) {
    for (const t of this._components)
      if (t.name === e)
        return t;
    return null;
  }
  getClassName() {
    return "Scene";
  }
  _getDefaultMeshCandidates() {
    return this._defaultMeshCandidates.data = this.meshes, this._defaultMeshCandidates.length = this.meshes.length, this._defaultMeshCandidates;
  }
  _getDefaultSubMeshCandidates(e) {
    return this._defaultSubMeshCandidates.data = e.subMeshes, this._defaultSubMeshCandidates.length = e.subMeshes.length, this._defaultSubMeshCandidates;
  }
  setDefaultCandidateProviders() {
    this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this), this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this), this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
  }
  get meshUnderPointer() {
    return this._inputManager.meshUnderPointer;
  }
  get pointerX() {
    return this._inputManager.pointerX;
  }
  set pointerX(e) {
    this._inputManager.pointerX = e;
  }
  get pointerY() {
    return this._inputManager.pointerY;
  }
  set pointerY(e) {
    this._inputManager.pointerY = e;
  }
  getCachedMaterial() {
    return this._cachedMaterial;
  }
  getCachedEffect() {
    return this._cachedEffect;
  }
  getCachedVisibility() {
    return this._cachedVisibility;
  }
  isCachedMaterialInvalid(e, t, i = 1) {
    return this._cachedEffect !== t || this._cachedMaterial !== e || this._cachedVisibility !== i;
  }
  getEngine() {
    return this._engine;
  }
  getTotalVertices() {
    return this._totalVertices.current;
  }
  get totalVerticesPerfCounter() {
    return this._totalVertices;
  }
  getActiveIndices() {
    return this._activeIndices.current;
  }
  get totalActiveIndicesPerfCounter() {
    return this._activeIndices;
  }
  getActiveParticles() {
    return this._activeParticles.current;
  }
  get activeParticlesPerfCounter() {
    return this._activeParticles;
  }
  getActiveBones() {
    return this._activeBones.current;
  }
  get activeBonesPerfCounter() {
    return this._activeBones;
  }
  getActiveMeshes() {
    return this._activeMeshes;
  }
  getAnimationRatio() {
    return this._animationRatio !== void 0 ? this._animationRatio : 1;
  }
  getRenderId() {
    return this._renderId;
  }
  getFrameId() {
    return this._frameId;
  }
  incrementRenderId() {
    this._renderId++;
  }
  _createUbo() {
    this.setSceneUniformBuffer(this.createSceneUniformBuffer());
  }
  simulatePointerMove(e, t) {
    return this._inputManager.simulatePointerMove(e, t), this;
  }
  simulatePointerDown(e, t) {
    return this._inputManager.simulatePointerDown(e, t), this;
  }
  simulatePointerUp(e, t, i) {
    return this._inputManager.simulatePointerUp(e, t, i), this;
  }
  isPointerCaptured(e = 0) {
    return this._inputManager.isPointerCaptured(e);
  }
  attachControl(e = !0, t = !0, i = !0) {
    this._inputManager.attachControl(e, t, i);
  }
  detachControl() {
    this._inputManager.detachControl();
  }
  isReady(e = !0) {
    if (this._isDisposed)
      return !1;
    let t;
    const i = this.getEngine();
    let s = !0;
    for (this._pendingData.length > 0 && (s = !1), e && (this._processedMaterials.reset(), this._materialsRenderTargets.reset()), t = 0; t < this.meshes.length; t++) {
      const r = this.meshes[t];
      if (!r.subMeshes || r.subMeshes.length === 0)
        continue;
      if (!r.isReady(!0)) {
        s = !1;
        continue;
      }
      const n = r.hasThinInstances || r.getClassName() === "InstancedMesh" || r.getClassName() === "InstancedLinesMesh" || i.getCaps().instancedArrays && r.instances.length > 0;
      for (const o of this._isReadyForMeshStage)
        o.action(r, n) || (s = !1);
      if (!e)
        continue;
      const a = r.material || this.defaultMaterial;
      if (a)
        if (a._storeEffectOnSubMeshes)
          for (const o of r.subMeshes) {
            const h = o.getMaterial();
            h && h.hasRenderTargetTextures && h.getRenderTargetTextures != null && this._processedMaterials.indexOf(h) === -1 && (this._processedMaterials.push(h), this._materialsRenderTargets.concatWithNoDuplicate(h.getRenderTargetTextures()));
          }
        else
          a.hasRenderTargetTextures && a.getRenderTargetTextures != null && this._processedMaterials.indexOf(a) === -1 && (this._processedMaterials.push(a), this._materialsRenderTargets.concatWithNoDuplicate(a.getRenderTargetTextures()));
    }
    if (!s || !i.areAllEffectsReady())
      return !1;
    if (e) {
      for (t = 0; t < this._materialsRenderTargets.length; ++t)
        if (!this._materialsRenderTargets.data[t].isReadyForRendering())
          return !1;
    }
    for (t = 0; t < this.geometries.length; t++)
      if (this.geometries[t].delayLoadState === 2)
        return !1;
    if (this.activeCameras && this.activeCameras.length > 0) {
      for (const r of this.activeCameras)
        if (!r.isReady(!0))
          return !1;
    } else if (this.activeCamera && !this.activeCamera.isReady(!0))
      return !1;
    for (const r of this.particleSystems)
      if (!r.isReady())
        return !1;
    return !0;
  }
  resetCachedMaterial() {
    this._cachedMaterial = null, this._cachedEffect = null, this._cachedVisibility = null;
  }
  registerBeforeRender(e) {
    this.onBeforeRenderObservable.add(e);
  }
  unregisterBeforeRender(e) {
    this.onBeforeRenderObservable.removeCallback(e);
  }
  registerAfterRender(e) {
    this.onAfterRenderObservable.add(e);
  }
  unregisterAfterRender(e) {
    this.onAfterRenderObservable.removeCallback(e);
  }
  _executeOnceBeforeRender(e) {
    const t = () => {
      e(), setTimeout(() => {
        this.unregisterBeforeRender(t);
      });
    };
    this.registerBeforeRender(t);
  }
  executeOnceBeforeRender(e, t) {
    t !== void 0 ? setTimeout(() => {
      this._executeOnceBeforeRender(e);
    }, t) : this._executeOnceBeforeRender(e);
  }
  addPendingData(e) {
    this._pendingData.push(e);
  }
  removePendingData(e) {
    const t = this.isLoading, i = this._pendingData.indexOf(e);
    i !== -1 && this._pendingData.splice(i, 1), t && !this.isLoading && this.onDataLoadedObservable.notifyObservers(this);
  }
  getWaitingItemsCount() {
    return this._pendingData.length;
  }
  get isLoading() {
    return this._pendingData.length > 0;
  }
  executeWhenReady(e, t = !1) {
    this.onReadyObservable.addOnce(e), this._executeWhenReadyTimeoutId === null && this._checkIsReady(t);
  }
  whenReadyAsync(e = !1) {
    return new Promise((t) => {
      this.executeWhenReady(() => {
        t();
      }, e);
    });
  }
  _checkIsReady(e = !1) {
    if (this._registerTransientComponents(), this.isReady(e)) {
      this.onReadyObservable.notifyObservers(this), this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null;
      return;
    }
    if (this._isDisposed) {
      this.onReadyObservable.clear(), this._executeWhenReadyTimeoutId = null;
      return;
    }
    this._executeWhenReadyTimeoutId = setTimeout(() => {
      this.incrementRenderId(), this._checkIsReady(e);
    }, 100);
  }
  get animatables() {
    return this._activeAnimatables;
  }
  resetLastAnimationTimeFrame() {
    this._animationTimeLast = ai.Now;
  }
  getViewMatrix() {
    return this._viewMatrix;
  }
  getProjectionMatrix() {
    return this._projectionMatrix;
  }
  getTransformMatrix() {
    return this._transformMatrix;
  }
  setTransformMatrix(e, t, i, s) {
    !i && !s && this._multiviewSceneUbo && (this._multiviewSceneUbo.dispose(), this._multiviewSceneUbo = null), !(this._viewUpdateFlag === e.updateFlag && this._projectionUpdateFlag === t.updateFlag) && (this._viewUpdateFlag = e.updateFlag, this._projectionUpdateFlag = t.updateFlag, this._viewMatrix = e, this._projectionMatrix = t, this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._frustumPlanes ? mt.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = mt.GetPlanes(this._transformMatrix), this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo ? this._updateMultiviewUbo(i, s) : this._sceneUbo.useUbo && (this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix), this._sceneUbo.updateMatrix("view", this._viewMatrix), this._sceneUbo.updateMatrix("projection", this._projectionMatrix)));
  }
  getSceneUniformBuffer() {
    return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
  }
  createSceneUniformBuffer(e) {
    const t = new V(this._engine, void 0, !1, e != null ? e : "scene");
    return t.addUniform("viewProjection", 16), t.addUniform("view", 16), t.addUniform("projection", 16), t.addUniform("vEyePosition", 4), t;
  }
  setSceneUniformBuffer(e) {
    this._sceneUbo = e, this._viewUpdateFlag = -1, this._projectionUpdateFlag = -1;
  }
  getUniqueId() {
    return Or.UniqueId;
  }
  addMesh(e, t = !1) {
    this._blockEntityCollection || (this.meshes.push(e), e._resyncLightSources(), e.parent || e._addToSceneRootNodes(), this.onNewMeshAddedObservable.notifyObservers(e), t && e.getChildMeshes().forEach((i) => {
      this.addMesh(i);
    }));
  }
  removeMesh(e, t = !1) {
    const i = this.meshes.indexOf(e);
    return i !== -1 && (this.meshes[i] = this.meshes[this.meshes.length - 1], this.meshes.pop(), e.parent || e._removeFromSceneRootNodes()), this._inputManager._invalidateMesh(e), this.onMeshRemovedObservable.notifyObservers(e), t && e.getChildMeshes().forEach((s) => {
      this.removeMesh(s);
    }), i;
  }
  addTransformNode(e) {
    this._blockEntityCollection || e.getScene() === this && e._indexInSceneTransformNodesArray !== -1 || (e._indexInSceneTransformNodesArray = this.transformNodes.length, this.transformNodes.push(e), e.parent || e._addToSceneRootNodes(), this.onNewTransformNodeAddedObservable.notifyObservers(e));
  }
  removeTransformNode(e) {
    const t = e._indexInSceneTransformNodesArray;
    if (t !== -1) {
      if (t !== this.transformNodes.length - 1) {
        const i = this.transformNodes[this.transformNodes.length - 1];
        this.transformNodes[t] = i, i._indexInSceneTransformNodesArray = t;
      }
      e._indexInSceneTransformNodesArray = -1, this.transformNodes.pop(), e.parent || e._removeFromSceneRootNodes();
    }
    return this.onTransformNodeRemovedObservable.notifyObservers(e), t;
  }
  removeSkeleton(e) {
    const t = this.skeletons.indexOf(e);
    return t !== -1 && (this.skeletons.splice(t, 1), this.onSkeletonRemovedObservable.notifyObservers(e), this._executeActiveContainerCleanup(this._activeSkeletons)), t;
  }
  removeMorphTargetManager(e) {
    const t = this.morphTargetManagers.indexOf(e);
    return t !== -1 && this.morphTargetManagers.splice(t, 1), t;
  }
  removeLight(e) {
    const t = this.lights.indexOf(e);
    if (t !== -1) {
      for (const i of this.meshes)
        i._removeLightSource(e, !1);
      this.lights.splice(t, 1), this.sortLightsByPriority(), e.parent || e._removeFromSceneRootNodes();
    }
    return this.onLightRemovedObservable.notifyObservers(e), t;
  }
  removeCamera(e) {
    const t = this.cameras.indexOf(e);
    if (t !== -1 && (this.cameras.splice(t, 1), e.parent || e._removeFromSceneRootNodes()), this.activeCameras) {
      const i = this.activeCameras.indexOf(e);
      i !== -1 && this.activeCameras.splice(i, 1);
    }
    return this.activeCamera === e && (this.cameras.length > 0 ? this.activeCamera = this.cameras[0] : this.activeCamera = null), this.onCameraRemovedObservable.notifyObservers(e), t;
  }
  removeParticleSystem(e) {
    const t = this.particleSystems.indexOf(e);
    return t !== -1 && (this.particleSystems.splice(t, 1), this._executeActiveContainerCleanup(this._activeParticleSystems)), t;
  }
  removeAnimation(e) {
    const t = this.animations.indexOf(e);
    return t !== -1 && this.animations.splice(t, 1), t;
  }
  stopAnimation(e, t, i) {
  }
  removeAnimationGroup(e) {
    const t = this.animationGroups.indexOf(e);
    return t !== -1 && this.animationGroups.splice(t, 1), t;
  }
  removeMultiMaterial(e) {
    const t = this.multiMaterials.indexOf(e);
    return t !== -1 && this.multiMaterials.splice(t, 1), this.onMultiMaterialRemovedObservable.notifyObservers(e), t;
  }
  removeMaterial(e) {
    const t = e._indexInSceneMaterialArray;
    if (t !== -1 && t < this.materials.length) {
      if (t !== this.materials.length - 1) {
        const i = this.materials[this.materials.length - 1];
        this.materials[t] = i, i._indexInSceneMaterialArray = t;
      }
      e._indexInSceneMaterialArray = -1, this.materials.pop();
    }
    return this.onMaterialRemovedObservable.notifyObservers(e), t;
  }
  removeActionManager(e) {
    const t = this.actionManagers.indexOf(e);
    return t !== -1 && this.actionManagers.splice(t, 1), t;
  }
  removeTexture(e) {
    const t = this.textures.indexOf(e);
    return t !== -1 && this.textures.splice(t, 1), this.onTextureRemovedObservable.notifyObservers(e), t;
  }
  addLight(e) {
    if (!this._blockEntityCollection) {
      this.lights.push(e), this.sortLightsByPriority(), e.parent || e._addToSceneRootNodes();
      for (const t of this.meshes)
        t.lightSources.indexOf(e) === -1 && (t.lightSources.push(e), t._resyncLightSources());
      this.onNewLightAddedObservable.notifyObservers(e);
    }
  }
  sortLightsByPriority() {
    this.requireLightSorting && this.lights.sort(Ee.CompareLightsPriority);
  }
  addCamera(e) {
    this._blockEntityCollection || (this.cameras.push(e), this.onNewCameraAddedObservable.notifyObservers(e), e.parent || e._addToSceneRootNodes());
  }
  addSkeleton(e) {
    this._blockEntityCollection || (this.skeletons.push(e), this.onNewSkeletonAddedObservable.notifyObservers(e));
  }
  addParticleSystem(e) {
    this._blockEntityCollection || this.particleSystems.push(e);
  }
  addAnimation(e) {
    this._blockEntityCollection || this.animations.push(e);
  }
  addAnimationGroup(e) {
    this._blockEntityCollection || this.animationGroups.push(e);
  }
  addMultiMaterial(e) {
    this._blockEntityCollection || (this.multiMaterials.push(e), this.onNewMultiMaterialAddedObservable.notifyObservers(e));
  }
  addMaterial(e) {
    this._blockEntityCollection || e.getScene() === this && e._indexInSceneMaterialArray !== -1 || (e._indexInSceneMaterialArray = this.materials.length, this.materials.push(e), this.onNewMaterialAddedObservable.notifyObservers(e));
  }
  addMorphTargetManager(e) {
    this._blockEntityCollection || this.morphTargetManagers.push(e);
  }
  addGeometry(e) {
    this._blockEntityCollection || (this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = this.geometries.length), this.geometries.push(e));
  }
  addActionManager(e) {
    this.actionManagers.push(e);
  }
  addTexture(e) {
    this._blockEntityCollection || (this.textures.push(e), this.onNewTextureAddedObservable.notifyObservers(e));
  }
  switchActiveCamera(e, t = !0) {
    !this._engine.getInputElement() || (this.activeCamera && this.activeCamera.detachControl(), this.activeCamera = e, t && e.attachControl());
  }
  setActiveCameraById(e) {
    const t = this.getCameraById(e);
    return t ? (this.activeCamera = t, t) : null;
  }
  setActiveCameraByName(e) {
    const t = this.getCameraByName(e);
    return t ? (this.activeCamera = t, t) : null;
  }
  getAnimationGroupByName(e) {
    for (let t = 0; t < this.animationGroups.length; t++)
      if (this.animationGroups[t].name === e)
        return this.animationGroups[t];
    return null;
  }
  _getMaterial(e, t) {
    for (let i = 0; i < this.materials.length; i++) {
      const s = this.materials[i];
      if (t(s))
        return s;
    }
    if (e)
      for (let i = 0; i < this.multiMaterials.length; i++) {
        const s = this.multiMaterials[i];
        if (t(s))
          return s;
      }
    return null;
  }
  getMaterialByUniqueID(e, t = !1) {
    return this._getMaterial(t, (i) => i.uniqueId === e);
  }
  getMaterialById(e, t = !1) {
    return this._getMaterial(t, (i) => i.id === e);
  }
  getMaterialByName(e, t = !1) {
    return this._getMaterial(t, (i) => i.name === e);
  }
  getLastMaterialById(e, t = !1) {
    for (let i = this.materials.length - 1; i >= 0; i--)
      if (this.materials[i].id === e)
        return this.materials[i];
    if (t) {
      for (let i = this.multiMaterials.length - 1; i >= 0; i--)
        if (this.multiMaterials[i].id === e)
          return this.multiMaterials[i];
    }
    return null;
  }
  getTextureByUniqueId(e) {
    for (let t = 0; t < this.textures.length; t++)
      if (this.textures[t].uniqueId === e)
        return this.textures[t];
    return null;
  }
  getTextureByName(e) {
    for (let t = 0; t < this.textures.length; t++)
      if (this.textures[t].name === e)
        return this.textures[t];
    return null;
  }
  getCameraById(e) {
    for (let t = 0; t < this.cameras.length; t++)
      if (this.cameras[t].id === e)
        return this.cameras[t];
    return null;
  }
  getCameraByUniqueId(e) {
    for (let t = 0; t < this.cameras.length; t++)
      if (this.cameras[t].uniqueId === e)
        return this.cameras[t];
    return null;
  }
  getCameraByName(e) {
    for (let t = 0; t < this.cameras.length; t++)
      if (this.cameras[t].name === e)
        return this.cameras[t];
    return null;
  }
  getBoneById(e) {
    for (let t = 0; t < this.skeletons.length; t++) {
      const i = this.skeletons[t];
      for (let s = 0; s < i.bones.length; s++)
        if (i.bones[s].id === e)
          return i.bones[s];
    }
    return null;
  }
  getBoneByName(e) {
    for (let t = 0; t < this.skeletons.length; t++) {
      const i = this.skeletons[t];
      for (let s = 0; s < i.bones.length; s++)
        if (i.bones[s].name === e)
          return i.bones[s];
    }
    return null;
  }
  getLightByName(e) {
    for (let t = 0; t < this.lights.length; t++)
      if (this.lights[t].name === e)
        return this.lights[t];
    return null;
  }
  getLightById(e) {
    for (let t = 0; t < this.lights.length; t++)
      if (this.lights[t].id === e)
        return this.lights[t];
    return null;
  }
  getLightByUniqueId(e) {
    for (let t = 0; t < this.lights.length; t++)
      if (this.lights[t].uniqueId === e)
        return this.lights[t];
    return null;
  }
  getParticleSystemById(e) {
    for (let t = 0; t < this.particleSystems.length; t++)
      if (this.particleSystems[t].id === e)
        return this.particleSystems[t];
    return null;
  }
  getGeometryById(e) {
    for (let t = 0; t < this.geometries.length; t++)
      if (this.geometries[t].id === e)
        return this.geometries[t];
    return null;
  }
  _getGeometryByUniqueId(e) {
    if (this._geometriesByUniqueId) {
      const t = this._geometriesByUniqueId[e];
      if (t !== void 0)
        return this.geometries[t];
    } else
      for (let t = 0; t < this.geometries.length; t++)
        if (this.geometries[t].uniqueId === e)
          return this.geometries[t];
    return null;
  }
  pushGeometry(e, t) {
    return !t && this._getGeometryByUniqueId(e.uniqueId) ? !1 : (this.addGeometry(e), this.onNewGeometryAddedObservable.notifyObservers(e), !0);
  }
  removeGeometry(e) {
    let t;
    if (this._geometriesByUniqueId) {
      if (t = this._geometriesByUniqueId[e.uniqueId], t === void 0)
        return !1;
    } else if (t = this.geometries.indexOf(e), t < 0)
      return !1;
    if (t !== this.geometries.length - 1) {
      const i = this.geometries[this.geometries.length - 1];
      i && (this.geometries[t] = i, this._geometriesByUniqueId && (this._geometriesByUniqueId[i.uniqueId] = t));
    }
    return this._geometriesByUniqueId && (this._geometriesByUniqueId[e.uniqueId] = void 0), this.geometries.pop(), this.onGeometryRemovedObservable.notifyObservers(e), !0;
  }
  getGeometries() {
    return this.geometries;
  }
  getMeshById(e) {
    for (let t = 0; t < this.meshes.length; t++)
      if (this.meshes[t].id === e)
        return this.meshes[t];
    return null;
  }
  getMeshesById(e) {
    return this.meshes.filter(function(t) {
      return t.id === e;
    });
  }
  getTransformNodeById(e) {
    for (let t = 0; t < this.transformNodes.length; t++)
      if (this.transformNodes[t].id === e)
        return this.transformNodes[t];
    return null;
  }
  getTransformNodeByUniqueId(e) {
    for (let t = 0; t < this.transformNodes.length; t++)
      if (this.transformNodes[t].uniqueId === e)
        return this.transformNodes[t];
    return null;
  }
  getTransformNodesById(e) {
    return this.transformNodes.filter(function(t) {
      return t.id === e;
    });
  }
  getMeshByUniqueId(e) {
    for (let t = 0; t < this.meshes.length; t++)
      if (this.meshes[t].uniqueId === e)
        return this.meshes[t];
    return null;
  }
  getLastMeshById(e) {
    for (let t = this.meshes.length - 1; t >= 0; t--)
      if (this.meshes[t].id === e)
        return this.meshes[t];
    return null;
  }
  getLastEntryById(e) {
    let t;
    for (t = this.meshes.length - 1; t >= 0; t--)
      if (this.meshes[t].id === e)
        return this.meshes[t];
    for (t = this.transformNodes.length - 1; t >= 0; t--)
      if (this.transformNodes[t].id === e)
        return this.transformNodes[t];
    for (t = this.cameras.length - 1; t >= 0; t--)
      if (this.cameras[t].id === e)
        return this.cameras[t];
    for (t = this.lights.length - 1; t >= 0; t--)
      if (this.lights[t].id === e)
        return this.lights[t];
    return null;
  }
  getNodeById(e) {
    const t = this.getMeshById(e);
    if (t)
      return t;
    const i = this.getTransformNodeById(e);
    if (i)
      return i;
    const s = this.getLightById(e);
    if (s)
      return s;
    const r = this.getCameraById(e);
    if (r)
      return r;
    const n = this.getBoneById(e);
    return n || null;
  }
  getNodeByName(e) {
    const t = this.getMeshByName(e);
    if (t)
      return t;
    const i = this.getTransformNodeByName(e);
    if (i)
      return i;
    const s = this.getLightByName(e);
    if (s)
      return s;
    const r = this.getCameraByName(e);
    if (r)
      return r;
    const n = this.getBoneByName(e);
    return n || null;
  }
  getMeshByName(e) {
    for (let t = 0; t < this.meshes.length; t++)
      if (this.meshes[t].name === e)
        return this.meshes[t];
    return null;
  }
  getTransformNodeByName(e) {
    for (let t = 0; t < this.transformNodes.length; t++)
      if (this.transformNodes[t].name === e)
        return this.transformNodes[t];
    return null;
  }
  getLastSkeletonById(e) {
    for (let t = this.skeletons.length - 1; t >= 0; t--)
      if (this.skeletons[t].id === e)
        return this.skeletons[t];
    return null;
  }
  getSkeletonByUniqueId(e) {
    for (let t = 0; t < this.skeletons.length; t++)
      if (this.skeletons[t].uniqueId === e)
        return this.skeletons[t];
    return null;
  }
  getSkeletonById(e) {
    for (let t = 0; t < this.skeletons.length; t++)
      if (this.skeletons[t].id === e)
        return this.skeletons[t];
    return null;
  }
  getSkeletonByName(e) {
    for (let t = 0; t < this.skeletons.length; t++)
      if (this.skeletons[t].name === e)
        return this.skeletons[t];
    return null;
  }
  getMorphTargetManagerById(e) {
    for (let t = 0; t < this.morphTargetManagers.length; t++)
      if (this.morphTargetManagers[t].uniqueId === e)
        return this.morphTargetManagers[t];
    return null;
  }
  getMorphTargetById(e) {
    for (let t = 0; t < this.morphTargetManagers.length; ++t) {
      const i = this.morphTargetManagers[t];
      for (let s = 0; s < i.numTargets; ++s) {
        const r = i.getTarget(s);
        if (r.id === e)
          return r;
      }
    }
    return null;
  }
  getMorphTargetByName(e) {
    for (let t = 0; t < this.morphTargetManagers.length; ++t) {
      const i = this.morphTargetManagers[t];
      for (let s = 0; s < i.numTargets; ++s) {
        const r = i.getTarget(s);
        if (r.name === e)
          return r;
      }
    }
    return null;
  }
  getPostProcessByName(e) {
    for (let t = 0; t < this.postProcesses.length; ++t) {
      const i = this.postProcesses[t];
      if (i.name === e)
        return i;
    }
    return null;
  }
  isActiveMesh(e) {
    return this._activeMeshes.indexOf(e) !== -1;
  }
  get uid() {
    return this._uid || (this._uid = X.RandomId()), this._uid;
  }
  addExternalData(e, t) {
    return this._externalData || (this._externalData = new Js()), this._externalData.add(e, t);
  }
  getExternalData(e) {
    return this._externalData ? this._externalData.get(e) : null;
  }
  getOrAddExternalDataWithFactory(e, t) {
    return this._externalData || (this._externalData = new Js()), this._externalData.getOrAddWithFactory(e, t);
  }
  removeExternalData(e) {
    return this._externalData.remove(e);
  }
  _evaluateSubMesh(e, t, i, s) {
    if (s || e.isInFrustum(this._frustumPlanes)) {
      for (const n of this._evaluateSubMeshStage)
        n.action(t, e);
      const r = e.getMaterial();
      r != null && (r.hasRenderTargetTextures && r.getRenderTargetTextures != null && this._processedMaterials.indexOf(r) === -1 && (this._processedMaterials.push(r), this._materialsRenderTargets.concatWithNoDuplicate(r.getRenderTargetTextures())), this._renderingManager.dispatch(e, t, r));
    }
  }
  freeProcessedMaterials() {
    this._processedMaterials.dispose();
  }
  get blockfreeActiveMeshesAndRenderingGroups() {
    return this._preventFreeActiveMeshesAndRenderingGroups;
  }
  set blockfreeActiveMeshesAndRenderingGroups(e) {
    this._preventFreeActiveMeshesAndRenderingGroups !== e && (e && (this.freeActiveMeshes(), this.freeRenderingGroups()), this._preventFreeActiveMeshesAndRenderingGroups = e);
  }
  freeActiveMeshes() {
    if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._activeMeshes.dispose(), this.activeCamera && this.activeCamera._activeMeshes && this.activeCamera._activeMeshes.dispose(), this.activeCameras))
      for (let e = 0; e < this.activeCameras.length; e++) {
        const t = this.activeCameras[e];
        t && t._activeMeshes && t._activeMeshes.dispose();
      }
  }
  freeRenderingGroups() {
    if (!this.blockfreeActiveMeshesAndRenderingGroups && (this._renderingManager && this._renderingManager.freeRenderingGroups(), this.textures))
      for (let e = 0; e < this.textures.length; e++) {
        const t = this.textures[e];
        t && t.renderList && t.freeRenderingGroups();
      }
  }
  _isInIntermediateRendering() {
    return this._intermediateRendering;
  }
  freezeActiveMeshes(e = !1, t, i, s = !0, r = !1) {
    return this.executeWhenReady(() => {
      if (!this.activeCamera) {
        i && i("No active camera found");
        return;
      }
      if (this._frustumPlanes || this.updateTransformMatrix(), this._evaluateActiveMeshes(), this._activeMeshesFrozen = !0, this._activeMeshesFrozenButKeepClipping = r, this._skipEvaluateActiveMeshesCompletely = e, s)
        for (let n = 0; n < this._activeMeshes.length; n++)
          this._activeMeshes.data[n]._freeze();
      t && t();
    }), this;
  }
  unfreezeActiveMeshes() {
    for (let e = 0; e < this.meshes.length; e++) {
      const t = this.meshes[e];
      t._internalAbstractMeshDataInfo && (t._internalAbstractMeshDataInfo._isActive = !1);
    }
    for (let e = 0; e < this._activeMeshes.length; e++)
      this._activeMeshes.data[e]._unFreeze();
    return this._activeMeshesFrozen = !1, this;
  }
  _executeActiveContainerCleanup(e) {
    !(this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) && this._activeMeshesFrozen && this._activeMeshes.length || this.onBeforeRenderObservable.addOnce(() => e.dispose());
  }
  _evaluateActiveMeshes() {
    var e;
    if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
      this._activeMeshes.length > 0 && ((e = this.activeCamera) === null || e === void 0 || e._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset());
      return;
    }
    if (this._activeMeshesFrozen && this._activeMeshes.length) {
      if (!this._skipEvaluateActiveMeshesCompletely) {
        const s = this._activeMeshes.length;
        for (let r = 0; r < s; r++)
          this._activeMeshes.data[r].computeWorldMatrix();
      }
      if (this._activeParticleSystems) {
        const s = this._activeParticleSystems.length;
        for (let r = 0; r < s; r++)
          this._activeParticleSystems.data[r].animate();
      }
      this._renderingManager.resetSprites();
      return;
    }
    if (!this.activeCamera)
      return;
    this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this), this.activeCamera._activeMeshes.reset(), this._activeMeshes.reset(), this._renderingManager.reset(), this._processedMaterials.reset(), this._activeParticleSystems.reset(), this._activeSkeletons.reset(), this._softwareSkinnedMeshes.reset(), this._materialsRenderTargets.reset();
    for (const s of this._beforeEvaluateActiveMeshStage)
      s.action();
    const t = this.getActiveMeshCandidates(), i = t.length;
    for (let s = 0; s < i; s++) {
      const r = t.data[s];
      if (r._internalAbstractMeshDataInfo._currentLODIsUpToDate = !1, r.isBlocked || (this._totalVertices.addCount(r.getTotalVertices(), !1), !r.isReady() || !r.isEnabled() || r.scaling.hasAZeroComponent))
        continue;
      r.computeWorldMatrix(), r.actionManager && r.actionManager.hasSpecificTriggers2(12, 13) && this._meshesForIntersections.pushNoDuplicate(r);
      let n = this.customLODSelector ? this.customLODSelector(r, this.activeCamera) : r.getLOD(this.activeCamera);
      if (r._internalAbstractMeshDataInfo._currentLOD = n, r._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0, n != null && (n !== r && n.billboardMode !== 0 && n.computeWorldMatrix(), r._preActivate(), r.isVisible && r.visibility > 0 && (r.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || r.alwaysSelectAsActiveMesh || r.isInFrustum(this._frustumPlanes)))) {
        this._activeMeshes.push(r), this.activeCamera._activeMeshes.push(r), n !== r && n._activate(this._renderId, !1);
        for (const a of this._preActiveMeshStage)
          a.action(r);
        r._activate(this._renderId, !1) && (r.isAnInstance ? r._internalAbstractMeshDataInfo._actAsRegularMesh && (n = r) : n._internalAbstractMeshDataInfo._onlyForInstances = !1, n._internalAbstractMeshDataInfo._isActive = !0, this._activeMesh(r, n)), r._postActivate();
      }
    }
    if (this.particlesEnabled) {
      this.onBeforeParticlesRenderingObservable.notifyObservers(this);
      for (let s = 0; s < this.particleSystems.length; s++) {
        const r = this.particleSystems[s];
        if (!r.isStarted() || !r.emitter)
          continue;
        const n = r.emitter;
        (!n.position || n.isEnabled()) && (this._activeParticleSystems.push(r), r.animate(), this._renderingManager.dispatchParticles(r));
      }
      this.onAfterParticlesRenderingObservable.notifyObservers(this);
    }
  }
  _activeMesh(e, t) {
    this._skeletonsEnabled && t.skeleton !== null && t.skeleton !== void 0 && (this._activeSkeletons.pushNoDuplicate(t.skeleton) && (t.skeleton.prepare(), this._activeBones.addCount(t.skeleton.bones.length, !1)), t.computeBonesUsingShaders || this._softwareSkinnedMeshes.pushNoDuplicate(t));
    let i = e.hasInstances || e.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || t.alwaysSelectAsActiveMesh;
    if (t && t.subMeshes && t.subMeshes.length > 0) {
      const s = this.getActiveSubMeshCandidates(t), r = s.length;
      i = i || r === 1;
      for (let n = 0; n < r; n++) {
        const a = s.data[n];
        this._evaluateSubMesh(a, t, e, i);
      }
    }
  }
  updateTransformMatrix(e) {
    if (!!this.activeCamera)
      if (this.activeCamera._renderingMultiview) {
        const t = this.activeCamera._rigCameras[0], i = this.activeCamera._rigCameras[1];
        this.setTransformMatrix(t.getViewMatrix(), t.getProjectionMatrix(e), i.getViewMatrix(), i.getProjectionMatrix(e));
      } else
        this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(e));
  }
  _bindFrameBuffer(e, t = !0) {
    e && e._multiviewTexture ? e._multiviewTexture._bindFrameBuffer() : e && e.outputRenderTarget ? e.outputRenderTarget._bindFrameBuffer() : this._engine._currentFrameBufferIsDefaultFrameBuffer() || this._engine.restoreDefaultFramebuffer(), t && this._clearFrameBuffer(e);
  }
  _clearFrameBuffer(e) {
    if (!(e && e._multiviewTexture))
      if (e && e.outputRenderTarget && !e._renderingMultiview) {
        const t = e.outputRenderTarget;
        t.onClearObservable.hasObservers() ? t.onClearObservable.notifyObservers(this._engine) : t.skipInitialClear || (this.autoClear && this._engine.clear(t.clearColor || this.clearColor, !t._cleared, !0, !0), t._cleared = !0);
      } else
        this._defaultFrameBufferCleared ? this._engine.clear(null, !1, !0, !0) : (this._defaultFrameBufferCleared = !0, this._clear());
  }
  _renderForCamera(e, t, i = !0) {
    var s, r, n;
    if (e && e._skipRendering)
      return;
    const a = this._engine;
    if (this._activeCamera = e, !this.activeCamera)
      throw new Error("Active camera not set");
    if (a.setViewport(this.activeCamera.viewport), this.resetCachedMaterial(), this._renderId++, !this.prePass && i) {
      let h = !0;
      e._renderingMultiview && e.outputRenderTarget && (h = e.outputRenderTarget.skipInitialClear, this.autoClear && (e.outputRenderTarget.skipInitialClear = !1)), this._bindFrameBuffer(this._activeCamera), e._renderingMultiview && e.outputRenderTarget && (e.outputRenderTarget.skipInitialClear = h);
    }
    this.updateTransformMatrix(), this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera), this._evaluateActiveMeshes();
    for (let h = 0; h < this._softwareSkinnedMeshes.length; h++) {
      const l = this._softwareSkinnedMeshes.data[h];
      l.applySkeleton(l.skeleton);
    }
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this), this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets), e.customRenderTargets && e.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(e.customRenderTargets), t && t.customRenderTargets && t.customRenderTargets.length > 0 && this._renderTargets.concatWithNoDuplicate(t.customRenderTargets), this.environmentTexture && this.environmentTexture.isRenderTarget && this._renderTargets.pushNoDuplicate(this.environmentTexture);
    for (const h of this._gatherActiveCameraRenderTargetsStage)
      h.action(this._renderTargets);
    let o = !1;
    if (this.renderTargetsEnabled) {
      if (this._intermediateRendering = !0, this._renderTargets.length > 0) {
        X.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
        for (let h = 0; h < this._renderTargets.length; h++) {
          const l = this._renderTargets.data[h];
          if (l._shouldRender()) {
            this._renderId++;
            const u = l.activeCamera && l.activeCamera !== this.activeCamera;
            l.render(u, this.dumpNextRenderTargets), o = !0;
          }
        }
        X.EndPerformanceCounter("Render targets", this._renderTargets.length > 0), this._renderId++;
      }
      for (const h of this._cameraDrawRenderTargetStage)
        o = h.action(this.activeCamera) || o;
      this._intermediateRendering = !1;
    }
    this._engine.currentRenderPassId = (n = (r = (s = e.outputRenderTarget) === null || s === void 0 ? void 0 : s.renderPassId) !== null && r !== void 0 ? r : e.renderPassId) !== null && n !== void 0 ? n : 0, o && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this), this.postProcessManager && !e._multiviewTexture && !this.prePass && this.postProcessManager._prepareFrame();
    for (const h of this._beforeCameraDrawStage)
      h.action(this.activeCamera);
    this.onBeforeDrawPhaseObservable.notifyObservers(this), a.snapshotRendering && a.snapshotRenderingMode === 1 && this.finalizeSceneUbo(), this._renderingManager.render(null, null, !0, !0), this.onAfterDrawPhaseObservable.notifyObservers(this);
    for (const h of this._afterCameraDrawStage)
      h.action(this.activeCamera);
    if (this.postProcessManager && !e._multiviewTexture) {
      const h = e.outputRenderTarget ? e.outputRenderTarget.renderTarget : void 0;
      this.postProcessManager._finalizeFrame(e.isIntermediate, h);
    }
    for (const h of this._afterCameraPostProcessStage)
      h.action(this.activeCamera);
    this._renderTargets.reset(), this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
  }
  _processSubCameras(e, t = !0) {
    if (e.cameraRigMode === 0 || e._renderingMultiview) {
      e._renderingMultiview && !this._multiviewSceneUbo && this._createMultiviewUbo(), this._renderForCamera(e, void 0, t), this.onAfterRenderCameraObservable.notifyObservers(e);
      return;
    }
    if (e._useMultiviewToSingleView)
      this._renderMultiviewToSingleView(e);
    else {
      this.onBeforeCameraRenderObservable.notifyObservers(e);
      for (let i = 0; i < e._rigCameras.length; i++)
        this._renderForCamera(e._rigCameras[i], e);
    }
    this._activeCamera = e, this.updateTransformMatrix(), this.onAfterRenderCameraObservable.notifyObservers(e);
  }
  _checkIntersections() {
    for (let e = 0; e < this._meshesForIntersections.length; e++) {
      const t = this._meshesForIntersections.data[e];
      if (!!t.actionManager)
        for (let i = 0; t.actionManager && i < t.actionManager.actions.length; i++) {
          const s = t.actionManager.actions[i];
          if (s.trigger === 12 || s.trigger === 13) {
            const r = s.getTriggerParameter(), n = r.mesh ? r.mesh : r, a = n.intersectsMesh(t, r.usePreciseIntersection), o = t._intersectionsInProgress.indexOf(n);
            a && o === -1 ? s.trigger === 12 ? (s._executeCurrent(We.CreateNew(t, void 0, n)), t._intersectionsInProgress.push(n)) : s.trigger === 13 && t._intersectionsInProgress.push(n) : !a && o > -1 && (s.trigger === 13 && s._executeCurrent(We.CreateNew(t, void 0, n)), (!t.actionManager.hasSpecificTrigger(13, (h) => {
              const l = h.mesh ? h.mesh : h;
              return n === l;
            }) || s.trigger === 13) && t._intersectionsInProgress.splice(o, 1));
          }
        }
    }
  }
  _advancePhysicsEngineStep(e) {
  }
  _animate() {
  }
  animate() {
    if (this._engine.isDeterministicLockStep()) {
      let e = Math.max(re.MinDeltaTime, Math.min(this._engine.getDeltaTime(), re.MaxDeltaTime)) + this._timeAccumulator;
      const t = this._engine.getTimeStep(), i = 1e3 / t / 1e3;
      let s = 0;
      const r = this._engine.getLockstepMaxSteps();
      let n = Math.floor(e / t);
      for (n = Math.min(n, r); e > 0 && s < n; )
        this.onBeforeStepObservable.notifyObservers(this), this._animationRatio = t * i, this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(t), this.onAfterStepObservable.notifyObservers(this), this._currentStepId++, s++, e -= t;
      this._timeAccumulator = e < 0 ? 0 : e;
    } else {
      const e = this.useConstantAnimationDeltaTime ? 16 : Math.max(re.MinDeltaTime, Math.min(this._engine.getDeltaTime(), re.MaxDeltaTime));
      this._animationRatio = e * (60 / 1e3), this._animate(), this.onAfterAnimationsObservable.notifyObservers(this), this.physicsEnabled && this._advancePhysicsEngineStep(e);
    }
  }
  _clear() {
    (this.autoClearDepthAndStencil || this.autoClear) && this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
  }
  _checkCameraRenderTarget(e) {
    var t;
    if ((e == null ? void 0 : e.outputRenderTarget) && !(e != null && e.isRigCamera) && (e.outputRenderTarget._cleared = !1), !((t = e == null ? void 0 : e.rigCameras) === null || t === void 0) && t.length)
      for (let i = 0; i < e.rigCameras.length; ++i) {
        const s = e.rigCameras[i].outputRenderTarget;
        s && (s._cleared = !1);
      }
  }
  resetDrawCache(e) {
    if (!!this.meshes)
      for (const t of this.meshes)
        t.resetDrawCache(e);
  }
  render(e = !0, t = !1) {
    var i, s, r;
    if (this.isDisposed)
      return;
    this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null && this._checkIsReady(), this._frameId++, this._defaultFrameBufferCleared = !1, this._checkCameraRenderTarget(this.activeCamera), !((i = this.activeCameras) === null || i === void 0) && i.length && this.activeCameras.forEach(this._checkCameraRenderTarget), this._registerTransientComponents(), this._activeParticles.fetchNewFrame(), this._totalVertices.fetchNewFrame(), this._activeIndices.fetchNewFrame(), this._activeBones.fetchNewFrame(), this._meshesForIntersections.reset(), this.resetCachedMaterial(), this.onBeforeAnimationsObservable.notifyObservers(this), this.actionManager && this.actionManager.processTrigger(11), t || this.animate();
    for (const o of this._beforeCameraUpdateStage)
      o.action();
    if (e) {
      if (this.activeCameras && this.activeCameras.length > 0)
        for (let o = 0; o < this.activeCameras.length; o++) {
          const h = this.activeCameras[o];
          if (h.update(), h.cameraRigMode !== 0)
            for (let l = 0; l < h._rigCameras.length; l++)
              h._rigCameras[l].update();
        }
      else if (this.activeCamera && (this.activeCamera.update(), this.activeCamera.cameraRigMode !== 0))
        for (let o = 0; o < this.activeCamera._rigCameras.length; o++)
          this.activeCamera._rigCameras[o].update();
    }
    this.onBeforeRenderObservable.notifyObservers(this);
    const n = this.getEngine();
    this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
    const a = !((s = this.activeCameras) === null || s === void 0) && s.length ? this.activeCameras[0] : this.activeCamera;
    if (this.renderTargetsEnabled) {
      X.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !0;
      for (let o = 0; o < this.customRenderTargets.length; o++) {
        const h = this.customRenderTargets[o];
        if (h._shouldRender()) {
          if (this._renderId++, this.activeCamera = h.activeCamera || this.activeCamera, !this.activeCamera)
            throw new Error("Active camera not set");
          n.setViewport(this.activeCamera.viewport), this.updateTransformMatrix(), h.render(a !== this.activeCamera, this.dumpNextRenderTargets);
        }
      }
      X.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0), this._intermediateRendering = !1, this._renderId++;
    }
    this._engine.currentRenderPassId = (r = a == null ? void 0 : a.renderPassId) !== null && r !== void 0 ? r : 0, this.activeCamera = a, this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass && this._bindFrameBuffer(this._activeCamera, !1), this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
    for (const o of this._beforeClearStage)
      o.action();
    this._clearFrameBuffer(this.activeCamera);
    for (const o of this._gatherRenderTargetsStage)
      o.action(this._renderTargets);
    if (this.activeCameras && this.activeCameras.length > 0)
      for (let o = 0; o < this.activeCameras.length; o++)
        this._processSubCameras(this.activeCameras[o], o > 0);
    else {
      if (!this.activeCamera)
        throw new Error("No camera defined");
      this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
    }
    this._checkIntersections();
    for (const o of this._afterRenderStage)
      o.action();
    if (this.afterRender && this.afterRender(), this.onAfterRenderObservable.notifyObservers(this), this._toBeDisposed.length) {
      for (let o = 0; o < this._toBeDisposed.length; o++) {
        const h = this._toBeDisposed[o];
        h && h.dispose();
      }
      this._toBeDisposed.length = 0;
    }
    this.dumpNextRenderTargets && (this.dumpNextRenderTargets = !1), this._activeBones.addCount(0, !0), this._activeIndices.addCount(0, !0), this._activeParticles.addCount(0, !0), this._engine.restoreDefaultFramebuffer();
  }
  freezeMaterials() {
    for (let e = 0; e < this.materials.length; e++)
      this.materials[e].freeze();
  }
  unfreezeMaterials() {
    for (let e = 0; e < this.materials.length; e++)
      this.materials[e].unfreeze();
  }
  dispose() {
    if (this.isDisposed)
      return;
    this.beforeRender = null, this.afterRender = null, this.metadata = null, this.skeletons.length = 0, this.morphTargetManagers.length = 0, this._transientComponents.length = 0, this._isReadyForMeshStage.clear(), this._beforeEvaluateActiveMeshStage.clear(), this._evaluateSubMeshStage.clear(), this._preActiveMeshStage.clear(), this._cameraDrawRenderTargetStage.clear(), this._beforeCameraDrawStage.clear(), this._beforeRenderTargetDrawStage.clear(), this._beforeRenderingGroupDrawStage.clear(), this._beforeRenderingMeshStage.clear(), this._afterRenderingMeshStage.clear(), this._afterRenderingGroupDrawStage.clear(), this._afterCameraDrawStage.clear(), this._afterRenderTargetDrawStage.clear(), this._afterRenderStage.clear(), this._beforeCameraUpdateStage.clear(), this._beforeClearStage.clear(), this._gatherRenderTargetsStage.clear(), this._gatherActiveCameraRenderTargetsStage.clear(), this._pointerMoveStage.clear(), this._pointerDownStage.clear(), this._pointerUpStage.clear(), this.importedMeshesFiles = new Array(), this.stopAllAnimations && this.stopAllAnimations(), this.resetCachedMaterial(), this.activeCamera && (this.activeCamera._activeMeshes.dispose(), this.activeCamera = null), this.activeCameras = null, this._activeMeshes.dispose(), this._renderingManager.dispose(), this._processedMaterials.dispose(), this._activeParticleSystems.dispose(), this._activeSkeletons.dispose(), this._softwareSkinnedMeshes.dispose(), this._renderTargets.dispose(), this._materialsRenderTargets.dispose(), this._registeredForLateAnimationBindings.dispose(), this._meshesForIntersections.dispose(), this._toBeDisposed.length = 0;
    const e = this._activeRequests.slice();
    for (const r of e)
      r.abort();
    this._activeRequests.length = 0;
    try {
      this.onDisposeObservable.notifyObservers(this);
    } catch (r) {
      console.error("An error occurred while calling onDisposeObservable!", r);
    }
    if (this.onDisposeObservable.clear(), this.onBeforeRenderObservable.clear(), this.onAfterRenderObservable.clear(), this.onBeforeRenderTargetsRenderObservable.clear(), this.onAfterRenderTargetsRenderObservable.clear(), this.onAfterStepObservable.clear(), this.onBeforeStepObservable.clear(), this.onBeforeActiveMeshesEvaluationObservable.clear(), this.onAfterActiveMeshesEvaluationObservable.clear(), this.onBeforeParticlesRenderingObservable.clear(), this.onAfterParticlesRenderingObservable.clear(), this.onBeforeDrawPhaseObservable.clear(), this.onAfterDrawPhaseObservable.clear(), this.onBeforeAnimationsObservable.clear(), this.onAfterAnimationsObservable.clear(), this.onDataLoadedObservable.clear(), this.onBeforeRenderingGroupObservable.clear(), this.onAfterRenderingGroupObservable.clear(), this.onMeshImportedObservable.clear(), this.onBeforeCameraRenderObservable.clear(), this.onAfterCameraRenderObservable.clear(), this.onReadyObservable.clear(), this.onNewCameraAddedObservable.clear(), this.onCameraRemovedObservable.clear(), this.onNewLightAddedObservable.clear(), this.onLightRemovedObservable.clear(), this.onNewGeometryAddedObservable.clear(), this.onGeometryRemovedObservable.clear(), this.onNewTransformNodeAddedObservable.clear(), this.onTransformNodeRemovedObservable.clear(), this.onNewMeshAddedObservable.clear(), this.onMeshRemovedObservable.clear(), this.onNewSkeletonAddedObservable.clear(), this.onSkeletonRemovedObservable.clear(), this.onNewMaterialAddedObservable.clear(), this.onNewMultiMaterialAddedObservable.clear(), this.onMaterialRemovedObservable.clear(), this.onMultiMaterialRemovedObservable.clear(), this.onNewTextureAddedObservable.clear(), this.onTextureRemovedObservable.clear(), this.onPrePointerObservable.clear(), this.onPointerObservable.clear(), this.onPreKeyboardObservable.clear(), this.onKeyboardObservable.clear(), this.onActiveCameraChanged.clear(), this.detachControl(), this._engine.getInputElement())
      for (let r = 0; r < this.cameras.length; r++)
        this.cameras[r].detachControl();
    this._disposeList(this.animationGroups), this._disposeList(this.lights), this._disposeList(this.meshes, (r) => r.dispose(!0)), this._disposeList(this.transformNodes, (r) => r.dispose(!0));
    const i = this.cameras;
    this._disposeList(i), this._defaultMaterial && this._defaultMaterial.dispose(), this._disposeList(this.multiMaterials), this._disposeList(this.materials), this._disposeList(this.particleSystems), this._disposeList(this.postProcesses), this._disposeList(this.textures), this._disposeList(this.morphTargetManagers), this._sceneUbo.dispose(), this._multiviewSceneUbo && this._multiviewSceneUbo.dispose(), this.postProcessManager.dispose(), this._disposeList(this._components);
    let s = this._engine.scenes.indexOf(this);
    s > -1 && this._engine.scenes.splice(s, 1), fe._LastCreatedScene === this && (this._engine.scenes.length > 0 ? fe._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1] : fe._LastCreatedScene = null), s = this._engine._virtualScenes.indexOf(this), s > -1 && this._engine._virtualScenes.splice(s, 1), this._engine.wipeCaches(!0), this._isDisposed = !0;
  }
  _disposeList(e, t) {
    const i = e.slice(0);
    t = t != null ? t : (s) => s.dispose();
    for (const s of i)
      t(s);
    e.length = 0;
  }
  get isDisposed() {
    return this._isDisposed;
  }
  clearCachedVertexData() {
    for (let e = 0; e < this.meshes.length; e++) {
      const i = this.meshes[e].geometry;
      i && i.clearCachedData();
    }
  }
  cleanCachedTextureBuffer() {
    for (const e of this.textures)
      e._buffer && (e._buffer = null);
  }
  getWorldExtends(e) {
    const t = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), i = new p(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    return e = e || (() => !0), this.meshes.filter(e).forEach((s) => {
      if (s.computeWorldMatrix(!0), !s.subMeshes || s.subMeshes.length === 0 || s.infiniteDistance)
        return;
      const r = s.getBoundingInfo(), n = r.boundingBox.minimumWorld, a = r.boundingBox.maximumWorld;
      p.CheckExtends(n, t, i), p.CheckExtends(a, t, i);
    }), {
      min: t,
      max: i
    };
  }
  createPickingRay(e, t, i, s, r = !1) {
    throw Q("Ray");
  }
  createPickingRayToRef(e, t, i, s, r, n = !1, a = !1) {
    throw Q("Ray");
  }
  createPickingRayInCameraSpace(e, t, i) {
    throw Q("Ray");
  }
  createPickingRayInCameraSpaceToRef(e, t, i, s) {
    throw Q("Ray");
  }
  get _pickingAvailable() {
    return !1;
  }
  pick(e, t, i, s, r, n) {
    return new zt();
  }
  pickWithBoundingInfo(e, t, i, s, r) {
    return new zt();
  }
  pickWithRay(e, t, i, s) {
    throw Q("Ray");
  }
  multiPick(e, t, i, s, r) {
    throw Q("Ray");
  }
  multiPickWithRay(e, t, i) {
    throw Q("Ray");
  }
  setPointerOverMesh(e, t, i) {
    this._inputManager.setPointerOverMesh(e, t, i);
  }
  getPointerOverMesh() {
    return this._inputManager.getPointerOverMesh();
  }
  _rebuildGeometries() {
    for (const e of this.geometries)
      e._rebuild();
    for (const e of this.meshes)
      e._rebuild();
    this.postProcessManager && this.postProcessManager._rebuild();
    for (const e of this._components)
      e.rebuild();
    for (const e of this.particleSystems)
      e.rebuild();
    if (this.spriteManagers)
      for (const e of this.spriteManagers)
        e.rebuild();
  }
  _rebuildTextures() {
    for (const e of this.textures)
      e._rebuild();
    this.markAllMaterialsAsDirty(1);
  }
  _getByTags(e, t, i) {
    if (t === void 0)
      return e;
    const s = [];
    i = i || ((r) => {
    });
    for (const r in e) {
      const n = e[r];
      pe && pe.MatchesQuery(n, t) && (s.push(n), i(n));
    }
    return s;
  }
  getMeshesByTags(e, t) {
    return this._getByTags(this.meshes, e, t);
  }
  getCamerasByTags(e, t) {
    return this._getByTags(this.cameras, e, t);
  }
  getLightsByTags(e, t) {
    return this._getByTags(this.lights, e, t);
  }
  getMaterialByTags(e, t) {
    return this._getByTags(this.materials, e, t).concat(this._getByTags(this.multiMaterials, e, t));
  }
  getTransformNodesByTags(e, t) {
    return this._getByTags(this.transformNodes, e, t);
  }
  setRenderingOrder(e, t = null, i = null, s = null) {
    this._renderingManager.setRenderingOrder(e, t, i, s);
  }
  setRenderingAutoClearDepthStencil(e, t, i = !0, s = !0) {
    this._renderingManager.setRenderingAutoClearDepthStencil(e, t, i, s);
  }
  getAutoClearDepthStencilSetup(e) {
    return this._renderingManager.getAutoClearDepthStencilSetup(e);
  }
  get blockMaterialDirtyMechanism() {
    return this._blockMaterialDirtyMechanism;
  }
  set blockMaterialDirtyMechanism(e) {
    this._blockMaterialDirtyMechanism !== e && (this._blockMaterialDirtyMechanism = e, e || this.markAllMaterialsAsDirty(63));
  }
  markAllMaterialsAsDirty(e, t) {
    if (!this._blockMaterialDirtyMechanism)
      for (const i of this.materials)
        t && !t(i) || i.markAsDirty(e);
  }
  _loadFile(e, t, i, s, r, n, a) {
    const o = Qt(e, t, i, s ? this.offlineProvider : void 0, r, n, a);
    return this._activeRequests.push(o), o.onCompleteObservable.add((h) => {
      this._activeRequests.splice(this._activeRequests.indexOf(h), 1);
    }), o;
  }
  _loadFileAsync(e, t, i, s, r) {
    return new Promise((n, a) => {
      this._loadFile(e, (o) => {
        n(o);
      }, t, i, s, (o, h) => {
        a(h);
      }, r);
    });
  }
  _requestFile(e, t, i, s, r, n, a) {
    const o = zs(e, t, i, s ? this.offlineProvider : void 0, r, n, a);
    return this._activeRequests.push(o), o.onCompleteObservable.add((h) => {
      this._activeRequests.splice(this._activeRequests.indexOf(h), 1);
    }), o;
  }
  _requestFileAsync(e, t, i, s, r) {
    return new Promise((n, a) => {
      this._requestFile(e, (o) => {
        n(o);
      }, t, i, s, (o) => {
        a(o);
      }, r);
    });
  }
  _readFile(e, t, i, s, r) {
    const n = wi(e, t, i, s, r);
    return this._activeRequests.push(n), n.onCompleteObservable.add((a) => {
      this._activeRequests.splice(this._activeRequests.indexOf(a), 1);
    }), n;
  }
  _readFileAsync(e, t, i) {
    return new Promise((s, r) => {
      this._readFile(e, (n) => {
        s(n);
      }, t, i, (n) => {
        r(n);
      });
    });
  }
  getPerfCollector() {
    throw Q("performanceViewerSceneExtension");
  }
}
re.FOGMODE_NONE = 0;
re.FOGMODE_EXP = 1;
re.FOGMODE_EXP2 = 2;
re.FOGMODE_LINEAR = 3;
re.MinDeltaTime = 1;
re.MaxDeltaTime = 1e3;
re.prototype.setActiveCameraByID = function(c) {
  return this.setActiveCameraById(c);
};
re.prototype.getLastMaterialByID = function(c) {
  return this.getLastMaterialById(c);
};
re.prototype.getMaterialByID = function(c) {
  return this.getMaterialById(c);
};
re.prototype.getTextureByUniqueID = function(c) {
  return this.getTextureByUniqueId(c);
};
re.prototype.getCameraByID = function(c) {
  return this.getCameraById(c);
};
re.prototype.getCameraByUniqueID = function(c) {
  return this.getCameraByUniqueId(c);
};
re.prototype.getBoneByID = function(c) {
  return this.getBoneById(c);
};
re.prototype.getLightByID = function(c) {
  return this.getLightById(c);
};
re.prototype.getLightByUniqueID = function(c) {
  return this.getLightByUniqueId(c);
};
re.prototype.getParticleSystemByID = function(c) {
  return this.getParticleSystemById(c);
};
re.prototype.getGeometryByID = function(c) {
  return this.getGeometryById(c);
};
re.prototype.getMeshByID = function(c) {
  return this.getMeshById(c);
};
re.prototype.getMeshesByID = function(c) {
  return this.getMeshesById(c);
};
re.prototype.getTransformNodeByID = function(c) {
  return this.getTransformNodeById(c);
};
re.prototype.getTransformNodeByUniqueID = function(c) {
  return this.getTransformNodeByUniqueId(c);
};
re.prototype.getTransformNodesByID = function(c) {
  return this.getTransformNodesById(c);
};
re.prototype.getMeshByUniqueID = function(c) {
  return this.getMeshByUniqueId(c);
};
re.prototype.getLastMeshByID = function(c) {
  return this.getLastMeshById(c);
};
re.prototype.getLastEntryByID = function(c) {
  return this.getLastEntryById(c);
};
re.prototype.getNodeByID = function(c) {
  return this.getNodeById(c);
};
re.prototype.getLastSkeletonByID = function(c) {
  return this.getLastSkeletonById(c);
};
function Ls(c, e, t) {
  try {
    const i = c.next();
    i.done ? e(i) : i.value ? i.value.then(() => {
      i.value = void 0, e(i);
    }, t) : e(i);
  } catch (i) {
    t(i);
  }
}
function Un(c = 25) {
  let e;
  return (t, i, s) => {
    const r = performance.now();
    e === void 0 || r - e > c ? (e = r, setTimeout(() => {
      Ls(t, i, s);
    }, 0)) : Ls(t, i, s);
  };
}
function Lr(c, e, t, i, s) {
  const r = () => {
    let n;
    const a = (o) => {
      o.done ? t(o.value) : n === void 0 ? n = !0 : r();
    };
    do
      n = void 0, !s || !s.aborted ? e(c, a, i) : i(new Error("Aborted")), n === void 0 && (n = !1);
    while (n);
  };
  r();
}
function Ks(c, e) {
  let t;
  return Lr(c, Ls, (i) => t = i, (i) => {
    throw i;
  }, e), t;
}
function kn(c, e, t) {
  return new Promise((i, s) => {
    Lr(c, e, i, s, t);
  });
}
function Vn(c, e) {
  return (...t) => Ks(c(...t), e);
}
class Wn {
  constructor() {
    this._doNotSerialize = !1, this._isDisposed = !1, this._sceneRootNodesIndex = -1, this._isEnabled = !0, this._isParentEnabled = !0, this._isReady = !0, this._onEnabledStateChangedObservable = new w(), this._onClonedObservable = new w();
  }
}
class Xe {
  constructor(e, t = null) {
    this._isDirty = !1, this._nodeDataStorage = new Wn(), this.state = "", this.metadata = null, this.reservedDataStore = null, this._accessibilityTag = null, this.onAccessibilityTagChangedObservable = new w(), this._parentContainer = null, this.animations = new Array(), this._ranges = {}, this.onReady = null, this._currentRenderId = -1, this._parentUpdateId = -1, this._childUpdateId = -1, this._waitingParentId = null, this._waitingParentInstanceIndex = null, this._waitingParsedUniqueId = null, this._cache = {}, this._parentNode = null, this._children = null, this._worldMatrix = x.Identity(), this._worldMatrixDeterminant = 0, this._worldMatrixDeterminantIsDirty = !0, this._animationPropertiesOverride = null, this._isNode = !0, this.onDisposeObservable = new w(), this._onDisposeObserver = null, this._behaviors = new Array(), this.name = e, this.id = e, this._scene = t || fe.LastCreatedScene, this.uniqueId = this._scene.getUniqueId(), this._initCache();
  }
  static AddNodeConstructor(e, t) {
    this._NodeConstructors[e] = t;
  }
  static Construct(e, t, i, s) {
    const r = this._NodeConstructors[e];
    return r ? r(t, i, s) : null;
  }
  set accessibilityTag(e) {
    this._accessibilityTag = e, this.onAccessibilityTagChangedObservable.notifyObservers(e);
  }
  get accessibilityTag() {
    return this._accessibilityTag;
  }
  get doNotSerialize() {
    return this._nodeDataStorage._doNotSerialize ? !0 : this._parentNode ? this._parentNode.doNotSerialize : !1;
  }
  set doNotSerialize(e) {
    this._nodeDataStorage._doNotSerialize = e;
  }
  isDisposed() {
    return this._nodeDataStorage._isDisposed;
  }
  set parent(e) {
    if (this._parentNode === e)
      return;
    const t = this._parentNode;
    if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
      const i = this._parentNode._children.indexOf(this);
      i !== -1 && this._parentNode._children.splice(i, 1), !e && !this._nodeDataStorage._isDisposed && this._addToSceneRootNodes();
    }
    this._parentNode = e, this._parentNode && ((this._parentNode._children === void 0 || this._parentNode._children === null) && (this._parentNode._children = new Array()), this._parentNode._children.push(this), t || this._removeFromSceneRootNodes()), this._syncParentEnabledState();
  }
  get parent() {
    return this._parentNode;
  }
  _serializeAsParent(e) {
    e.parentId = this.uniqueId;
  }
  _addToSceneRootNodes() {
    this._nodeDataStorage._sceneRootNodesIndex === -1 && (this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length, this._scene.rootNodes.push(this));
  }
  _removeFromSceneRootNodes() {
    if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
      const e = this._scene.rootNodes, t = e.length - 1;
      e[this._nodeDataStorage._sceneRootNodesIndex] = e[t], e[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex, this._scene.rootNodes.pop(), this._nodeDataStorage._sceneRootNodesIndex = -1;
    }
  }
  get animationPropertiesOverride() {
    return this._animationPropertiesOverride ? this._animationPropertiesOverride : this._scene.animationPropertiesOverride;
  }
  set animationPropertiesOverride(e) {
    this._animationPropertiesOverride = e;
  }
  getClassName() {
    return "Node";
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  get onEnabledStateChangedObservable() {
    return this._nodeDataStorage._onEnabledStateChangedObservable;
  }
  get onClonedObservable() {
    return this._nodeDataStorage._onClonedObservable;
  }
  getScene() {
    return this._scene;
  }
  getEngine() {
    return this._scene.getEngine();
  }
  addBehavior(e, t = !1) {
    return this._behaviors.indexOf(e) !== -1 ? this : (e.init(), this._scene.isLoading && !t ? this._scene.onDataLoadedObservable.addOnce(() => {
      e.attach(this);
    }) : e.attach(this), this._behaviors.push(e), this);
  }
  removeBehavior(e) {
    const t = this._behaviors.indexOf(e);
    return t === -1 ? this : (this._behaviors[t].detach(), this._behaviors.splice(t, 1), this);
  }
  get behaviors() {
    return this._behaviors;
  }
  getBehaviorByName(e) {
    for (const t of this._behaviors)
      if (t.name === e)
        return t;
    return null;
  }
  getWorldMatrix() {
    return this._currentRenderId !== this._scene.getRenderId() && this.computeWorldMatrix(), this._worldMatrix;
  }
  _getWorldMatrixDeterminant() {
    return this._worldMatrixDeterminantIsDirty && (this._worldMatrixDeterminantIsDirty = !1, this._worldMatrixDeterminant = this._worldMatrix.determinant()), this._worldMatrixDeterminant;
  }
  get worldMatrixFromCache() {
    return this._worldMatrix;
  }
  _initCache() {
    this._cache = {}, this._cache.parent = void 0;
  }
  updateCache(e) {
    !e && this.isSynchronized() || (this._cache.parent = this.parent, this._updateCache());
  }
  _getActionManagerForTrigger(e, t = !0) {
    return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null;
  }
  _updateCache(e) {
  }
  _isSynchronized() {
    return !0;
  }
  _markSyncedWithParent() {
    this._parentNode && (this._parentUpdateId = this._parentNode._childUpdateId);
  }
  isSynchronizedWithParent() {
    return this._parentNode ? this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId ? !1 : this._parentNode.isSynchronized() : !0;
  }
  isSynchronized() {
    return this._cache.parent !== this._parentNode ? (this._cache.parent = this._parentNode, !1) : this._parentNode && !this.isSynchronizedWithParent() ? !1 : this._isSynchronized();
  }
  isReady(e = !1) {
    return this._nodeDataStorage._isReady;
  }
  markAsDirty(e) {
    return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;
  }
  isEnabled(e = !0) {
    return e === !1 ? this._nodeDataStorage._isEnabled : this._nodeDataStorage._isEnabled ? this._nodeDataStorage._isParentEnabled : !1;
  }
  _syncParentEnabledState() {
    this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : !0, this._children && this._children.forEach((e) => {
      e._syncParentEnabledState();
    });
  }
  setEnabled(e) {
    this._nodeDataStorage._isEnabled !== e && (this._nodeDataStorage._isEnabled = e, this._syncParentEnabledState(), this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(e));
  }
  isDescendantOf(e) {
    return this.parent ? this.parent === e ? !0 : this.parent.isDescendantOf(e) : !1;
  }
  _getDescendants(e, t = !1, i) {
    if (!!this._children)
      for (let s = 0; s < this._children.length; s++) {
        const r = this._children[s];
        (!i || i(r)) && e.push(r), t || r._getDescendants(e, !1, i);
      }
  }
  getDescendants(e, t) {
    const i = new Array();
    return this._getDescendants(i, e, t), i;
  }
  getChildMeshes(e, t) {
    const i = [];
    return this._getDescendants(i, e, (s) => (!t || t(s)) && s.cullingStrategy !== void 0), i;
  }
  getChildren(e, t = !0) {
    return this.getDescendants(t, e);
  }
  _setReady(e) {
    if (e !== this._nodeDataStorage._isReady) {
      if (!e) {
        this._nodeDataStorage._isReady = !1;
        return;
      }
      this.onReady && this.onReady(this), this._nodeDataStorage._isReady = !0;
    }
  }
  getAnimationByName(e) {
    for (let t = 0; t < this.animations.length; t++) {
      const i = this.animations[t];
      if (i.name === e)
        return i;
    }
    return null;
  }
  createAnimationRange(e, t, i) {
    if (!this._ranges[e]) {
      this._ranges[e] = Xe._AnimationRangeFactory(e, t, i);
      for (let s = 0, r = this.animations.length; s < r; s++)
        this.animations[s] && this.animations[s].createRange(e, t, i);
    }
  }
  deleteAnimationRange(e, t = !0) {
    for (let i = 0, s = this.animations.length; i < s; i++)
      this.animations[i] && this.animations[i].deleteRange(e, t);
    this._ranges[e] = null;
  }
  getAnimationRange(e) {
    return this._ranges[e] || null;
  }
  getAnimationRanges() {
    const e = [];
    let t;
    for (t in this._ranges)
      e.push(this._ranges[t]);
    return e;
  }
  beginAnimation(e, t, i, s) {
    const r = this.getAnimationRange(e);
    return r ? this._scene.beginAnimation(this, r.from, r.to, t, i, s) : null;
  }
  serializeAnimationRanges() {
    const e = [];
    for (const t in this._ranges) {
      const i = this._ranges[t];
      if (!i)
        continue;
      const s = {};
      s.name = t, s.from = i.from, s.to = i.to, e.push(s);
    }
    return e;
  }
  computeWorldMatrix(e) {
    return this._worldMatrix || (this._worldMatrix = x.Identity()), this._worldMatrix;
  }
  dispose(e, t = !1) {
    if (this._nodeDataStorage._isDisposed = !0, !e) {
      const i = this.getDescendants(!0);
      for (const s of i)
        s.dispose(e, t);
    }
    this.parent ? this.parent = null : this._removeFromSceneRootNodes(), this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.onEnabledStateChangedObservable.clear(), this.onClonedObservable.clear();
    for (const i of this._behaviors)
      i.detach();
    this._behaviors.length = 0, this.metadata = null;
  }
  static ParseAnimationRanges(e, t, i) {
    if (t.ranges)
      for (let s = 0; s < t.ranges.length; s++) {
        const r = t.ranges[s];
        e.createAnimationRange(r.name, r.from, r.to);
      }
  }
  getHierarchyBoundingVectors(e = !0, t = null) {
    this.getScene().incrementRenderId(), this.computeWorldMatrix(!0);
    let i, s;
    const r = this;
    if (r.getBoundingInfo && r.subMeshes) {
      const n = r.getBoundingInfo();
      i = n.boundingBox.minimumWorld.clone(), s = n.boundingBox.maximumWorld.clone();
    } else
      i = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), s = new p(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    if (e) {
      const n = this.getDescendants(!1);
      for (const a of n) {
        const o = a;
        if (o.computeWorldMatrix(!0), t && !t(o) || !o.getBoundingInfo || o.getTotalVertices() === 0)
          continue;
        const l = o.getBoundingInfo().boundingBox, u = l.minimumWorld, d = l.maximumWorld;
        p.CheckExtends(u, i, s), p.CheckExtends(d, i, s);
      }
    }
    return {
      min: i,
      max: s
    };
  }
}
Xe._AnimationRangeFactory = (c, e, t) => {
  throw Q("AnimationRange");
};
Xe._NodeConstructors = {};
T([
  R()
], Xe.prototype, "name", void 0);
T([
  R()
], Xe.prototype, "id", void 0);
T([
  R()
], Xe.prototype, "uniqueId", void 0);
T([
  R()
], Xe.prototype, "state", void 0);
T([
  R()
], Xe.prototype, "metadata", void 0);
class Oi {
  constructor(e, t, i, s) {
    this.x = e, this.y = t, this.width = i, this.height = s;
  }
  toGlobal(e, t) {
    return new Oi(this.x * e, this.y * t, this.width * e, this.height * t);
  }
  toGlobalToRef(e, t, i) {
    return i.x = this.x * e, i.y = this.y * t, i.width = this.width * e, i.height = this.height * t, this;
  }
  clone() {
    return new Oi(this.x, this.y, this.width, this.height);
  }
}
class q extends Xe {
  constructor(e, t, i, s = !0) {
    super(e, i), this._position = p.Zero(), this._upVector = p.Up(), this._orthoLeft = null, this._orthoRight = null, this._orthoBottom = null, this._orthoTop = null, this.fov = 0.8, this.projectionPlaneTilt = 0, this.minZ = 1, this.maxZ = 1e4, this.inertia = 0.9, this._mode = q.PERSPECTIVE_CAMERA, this.isIntermediate = !1, this.viewport = new Oi(0, 0, 1, 1), this.layerMask = 268435455, this.fovMode = q.FOVMODE_VERTICAL_FIXED, this.cameraRigMode = q.RIG_MODE_NONE, this.customRenderTargets = new Array(), this.outputRenderTarget = null, this.onViewMatrixChangedObservable = new w(), this.onProjectionMatrixChangedObservable = new w(), this.onAfterCheckInputsObservable = new w(), this.onRestoreStateObservable = new w(), this.isRigCamera = !1, this._rigCameras = new Array(), this._webvrViewMatrix = x.Identity(), this._skipRendering = !1, this._projectionMatrix = new x(), this._postProcesses = new Array(), this._activeMeshes = new Qe(256), this._globalPosition = p.Zero(), this._computedViewMatrix = x.Identity(), this._doNotComputeProjectionMatrix = !1, this._transformMatrix = x.Zero(), this._refreshFrustumPlanes = !0, this._absoluteRotation = Y.Identity(), this._isCamera = !0, this._isLeftCamera = !1, this._isRightCamera = !1, this.getScene().addCamera(this), s && !this.getScene().activeCamera && (this.getScene().activeCamera = this), this.position = t, this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${e}`);
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._position = e;
  }
  set upVector(e) {
    this._upVector = e;
  }
  get upVector() {
    return this._upVector;
  }
  get screenArea() {
    var e, t, i, s;
    let r = 0, n = 0;
    if (this.mode === q.PERSPECTIVE_CAMERA)
      this.fovMode === q.FOVMODE_VERTICAL_FIXED ? (n = this.minZ * 2 * Math.tan(this.fov / 2), r = this.getEngine().getAspectRatio(this) * n) : (r = this.minZ * 2 * Math.tan(this.fov / 2), n = r / this.getEngine().getAspectRatio(this));
    else {
      const a = this.getEngine().getRenderWidth() / 2, o = this.getEngine().getRenderHeight() / 2;
      r = ((e = this.orthoRight) !== null && e !== void 0 ? e : a) - ((t = this.orthoLeft) !== null && t !== void 0 ? t : -a), n = ((i = this.orthoTop) !== null && i !== void 0 ? i : o) - ((s = this.orthoBottom) !== null && s !== void 0 ? s : -o);
    }
    return r * n;
  }
  set orthoLeft(e) {
    this._orthoLeft = e;
    for (const t of this._rigCameras)
      t.orthoLeft = e;
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoRight(e) {
    this._orthoRight = e;
    for (const t of this._rigCameras)
      t.orthoRight = e;
  }
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoBottom(e) {
    this._orthoBottom = e;
    for (const t of this._rigCameras)
      t.orthoBottom = e;
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoTop(e) {
    this._orthoTop = e;
    for (const t of this._rigCameras)
      t.orthoTop = e;
  }
  get orthoTop() {
    return this._orthoTop;
  }
  set mode(e) {
    this._mode = e;
    for (const t of this._rigCameras)
      t.mode = e;
  }
  get mode() {
    return this._mode;
  }
  storeState() {
    return this._stateStored = !0, this._storedFov = this.fov, this;
  }
  _restoreStateValues() {
    return this._stateStored ? (this.fov = this._storedFov, !0) : !1;
  }
  restoreState() {
    return this._restoreStateValues() ? (this.onRestoreStateObservable.notifyObservers(this), !0) : !1;
  }
  getClassName() {
    return "Camera";
  }
  toString(e) {
    let t = "Name: " + this.name;
    if (t += ", type: " + this.getClassName(), this.animations)
      for (let i = 0; i < this.animations.length; i++)
        t += ", animation[0]: " + this.animations[i].toString(e);
    return t;
  }
  applyVerticalCorrection() {
    const e = this.absoluteRotation.toEulerAngles();
    this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -e.x : e.x;
  }
  get globalPosition() {
    return this._globalPosition;
  }
  getActiveMeshes() {
    return this._activeMeshes;
  }
  isActiveMesh(e) {
    return this._activeMeshes.indexOf(e) !== -1;
  }
  isReady(e = !1) {
    if (e) {
      for (const t of this._postProcesses)
        if (t && !t.isReady())
          return !1;
    }
    return super.isReady(e);
  }
  _initCache() {
    super._initCache(), this._cache.position = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.upVector = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.mode = void 0, this._cache.minZ = void 0, this._cache.maxZ = void 0, this._cache.fov = void 0, this._cache.fovMode = void 0, this._cache.aspectRatio = void 0, this._cache.orthoLeft = void 0, this._cache.orthoRight = void 0, this._cache.orthoBottom = void 0, this._cache.orthoTop = void 0, this._cache.renderWidth = void 0, this._cache.renderHeight = void 0;
  }
  _updateCache(e) {
    e || super._updateCache(), this._cache.position.copyFrom(this.position), this._cache.upVector.copyFrom(this.upVector);
  }
  _isSynchronized() {
    return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
  }
  _isSynchronizedViewMatrix() {
    return super._isSynchronized() ? this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent() : !1;
  }
  _isSynchronizedProjectionMatrix() {
    let e = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
    if (!e)
      return !1;
    const t = this.getEngine();
    return this.mode === q.PERSPECTIVE_CAMERA ? e = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === t.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt : e = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === t.getRenderWidth() && this._cache.renderHeight === t.getRenderHeight(), e;
  }
  attachControl(e, t) {
  }
  detachControl(e) {
  }
  update() {
    this._checkInputs(), this.cameraRigMode !== q.RIG_MODE_NONE && this._updateRigCameras();
  }
  _checkInputs() {
    this.onAfterCheckInputsObservable.notifyObservers(this);
  }
  get rigCameras() {
    return this._rigCameras;
  }
  get rigPostProcess() {
    return this._rigPostProcess;
  }
  _getFirstPostProcess() {
    for (let e = 0; e < this._postProcesses.length; e++)
      if (this._postProcesses[e] !== null)
        return this._postProcesses[e];
    return null;
  }
  _cascadePostProcessesToRigCams() {
    const e = this._getFirstPostProcess();
    e && e.markTextureDirty();
    for (let t = 0, i = this._rigCameras.length; t < i; t++) {
      const s = this._rigCameras[t], r = s._rigPostProcess;
      r ? (r.getEffectName() === "pass" && (s.isIntermediate = this._postProcesses.length === 0), s._postProcesses = this._postProcesses.slice(0).concat(r), r.markTextureDirty()) : s._postProcesses = this._postProcesses.slice(0);
    }
  }
  attachPostProcess(e, t = null) {
    return !e.isReusable() && this._postProcesses.indexOf(e) > -1 ? (O.Error("You're trying to reuse a post process not defined as reusable."), 0) : (t == null || t < 0 ? this._postProcesses.push(e) : this._postProcesses[t] === null ? this._postProcesses[t] = e : this._postProcesses.splice(t, 0, e), this._cascadePostProcessesToRigCams(), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._postProcesses.indexOf(e));
  }
  detachPostProcess(e) {
    const t = this._postProcesses.indexOf(e);
    t !== -1 && (this._postProcesses[t] = null), this._scene.prePassRenderer && this._scene.prePassRenderer.markAsDirty(), this._cascadePostProcessesToRigCams();
  }
  getWorldMatrix() {
    return this._isSynchronizedViewMatrix() ? this._worldMatrix : (this.getViewMatrix(), this._worldMatrix);
  }
  _getViewMatrix() {
    return x.Identity();
  }
  getViewMatrix(e) {
    return !e && this._isSynchronizedViewMatrix() ? this._computedViewMatrix : (this.updateCache(), this._computedViewMatrix = this._getViewMatrix(), this._currentRenderId = this.getScene().getRenderId(), this._childUpdateId++, this._refreshFrustumPlanes = !0, this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix && this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix), this.parent && this.parent.onViewMatrixChangedObservable && this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent), this.onViewMatrixChangedObservable.notifyObservers(this), this._computedViewMatrix.invertToRef(this._worldMatrix), this._computedViewMatrix);
  }
  freezeProjectionMatrix(e) {
    this._doNotComputeProjectionMatrix = !0, e !== void 0 && (this._projectionMatrix = e);
  }
  unfreezeProjectionMatrix() {
    this._doNotComputeProjectionMatrix = !1;
  }
  getProjectionMatrix(e) {
    var t, i, s, r, n, a, o, h;
    if (this._doNotComputeProjectionMatrix || !e && this._isSynchronizedProjectionMatrix())
      return this._projectionMatrix;
    this._cache.mode = this.mode, this._cache.minZ = this.minZ, this._cache.maxZ = this.maxZ, this._refreshFrustumPlanes = !0;
    const l = this.getEngine(), u = this.getScene(), d = l.useReverseDepthBuffer;
    if (this.mode === q.PERSPECTIVE_CAMERA) {
      this._cache.fov = this.fov, this._cache.fovMode = this.fovMode, this._cache.aspectRatio = l.getAspectRatio(this), this._cache.projectionPlaneTilt = this.projectionPlaneTilt, this.minZ <= 0 && (this.minZ = 0.1);
      let f;
      u.useRightHandedSystem ? f = x.PerspectiveFovRHToRef : f = x.PerspectiveFovLHToRef, f(this.fov, l.getAspectRatio(this), d ? this.maxZ : this.minZ, d ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === q.FOVMODE_VERTICAL_FIXED, l.isNDCHalfZRange, this.projectionPlaneTilt, d);
    } else {
      const f = l.getRenderWidth() / 2, _ = l.getRenderHeight() / 2;
      u.useRightHandedSystem ? x.OrthoOffCenterRHToRef((t = this.orthoLeft) !== null && t !== void 0 ? t : -f, (i = this.orthoRight) !== null && i !== void 0 ? i : f, (s = this.orthoBottom) !== null && s !== void 0 ? s : -_, (r = this.orthoTop) !== null && r !== void 0 ? r : _, d ? this.maxZ : this.minZ, d ? this.minZ : this.maxZ, this._projectionMatrix, l.isNDCHalfZRange) : x.OrthoOffCenterLHToRef((n = this.orthoLeft) !== null && n !== void 0 ? n : -f, (a = this.orthoRight) !== null && a !== void 0 ? a : f, (o = this.orthoBottom) !== null && o !== void 0 ? o : -_, (h = this.orthoTop) !== null && h !== void 0 ? h : _, d ? this.maxZ : this.minZ, d ? this.minZ : this.maxZ, this._projectionMatrix, l.isNDCHalfZRange), this._cache.orthoLeft = this.orthoLeft, this._cache.orthoRight = this.orthoRight, this._cache.orthoBottom = this.orthoBottom, this._cache.orthoTop = this.orthoTop, this._cache.renderWidth = l.getRenderWidth(), this._cache.renderHeight = l.getRenderHeight();
    }
    return this.onProjectionMatrixChangedObservable.notifyObservers(this), this._projectionMatrix;
  }
  getTransformationMatrix() {
    return this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix), this._transformMatrix;
  }
  _updateFrustumPlanes() {
    !this._refreshFrustumPlanes || (this.getTransformationMatrix(), this._frustumPlanes ? mt.GetPlanesToRef(this._transformMatrix, this._frustumPlanes) : this._frustumPlanes = mt.GetPlanes(this._transformMatrix), this._refreshFrustumPlanes = !1);
  }
  isInFrustum(e, t = !1) {
    if (this._updateFrustumPlanes(), t && this.rigCameras.length > 0) {
      let i = !1;
      return this.rigCameras.forEach((s) => {
        s._updateFrustumPlanes(), i = i || e.isInFrustum(s._frustumPlanes);
      }), i;
    } else
      return e.isInFrustum(this._frustumPlanes);
  }
  isCompletelyInFrustum(e) {
    return this._updateFrustumPlanes(), e.isCompletelyInFrustum(this._frustumPlanes);
  }
  getForwardRay(e = 100, t, i) {
    throw Q("Ray");
  }
  getForwardRayToRef(e, t = 100, i, s) {
    throw Q("Ray");
  }
  dispose(e, t = !1) {
    for (this.onViewMatrixChangedObservable.clear(), this.onProjectionMatrixChangedObservable.clear(), this.onAfterCheckInputsObservable.clear(), this.onRestoreStateObservable.clear(), this.inputs && this.inputs.clear(), this.getScene().stopAnimation(this), this.getScene().removeCamera(this); this._rigCameras.length > 0; ) {
      const s = this._rigCameras.pop();
      s && s.dispose();
    }
    if (this._parentContainer) {
      const s = this._parentContainer.cameras.indexOf(this);
      s > -1 && this._parentContainer.cameras.splice(s, 1), this._parentContainer = null;
    }
    if (this._rigPostProcess)
      this._rigPostProcess.dispose(this), this._rigPostProcess = null, this._postProcesses.length = 0;
    else if (this.cameraRigMode !== q.RIG_MODE_NONE)
      this._rigPostProcess = null, this._postProcesses.length = 0;
    else {
      let s = this._postProcesses.length;
      for (; --s >= 0; ) {
        const r = this._postProcesses[s];
        r && r.dispose(this);
      }
    }
    let i = this.customRenderTargets.length;
    for (; --i >= 0; )
      this.customRenderTargets[i].dispose();
    this.customRenderTargets.length = 0, this._activeMeshes.dispose(), this.getScene().getEngine().releaseRenderPassId(this.renderPassId), super.dispose(e, t);
  }
  get isLeftCamera() {
    return this._isLeftCamera;
  }
  get isRightCamera() {
    return this._isRightCamera;
  }
  get leftCamera() {
    return this._rigCameras.length < 1 ? null : this._rigCameras[0];
  }
  get rightCamera() {
    return this._rigCameras.length < 2 ? null : this._rigCameras[1];
  }
  getLeftTarget() {
    return this._rigCameras.length < 1 ? null : this._rigCameras[0].getTarget();
  }
  getRightTarget() {
    return this._rigCameras.length < 2 ? null : this._rigCameras[1].getTarget();
  }
  setCameraRigMode(e, t) {
    if (this.cameraRigMode !== e) {
      for (; this._rigCameras.length > 0; ) {
        const i = this._rigCameras.pop();
        i && i.dispose();
      }
      if (this.cameraRigMode = e, this._cameraRigParams = {}, this._cameraRigParams.interaxialDistance = t.interaxialDistance || 0.0637, this._cameraRigParams.stereoHalfAngle = X.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637), this.cameraRigMode !== q.RIG_MODE_NONE) {
        const i = this.createRigCamera(this.name + "_L", 0);
        i && (i._isLeftCamera = !0);
        const s = this.createRigCamera(this.name + "_R", 1);
        s && (s._isRightCamera = !0), i && s && (this._rigCameras.push(i), this._rigCameras.push(s));
      }
      this._setRigMode(t), this._cascadePostProcessesToRigCams(), this.update();
    }
  }
  _setRigMode(e) {
  }
  _getVRProjectionMatrix() {
    return x.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, !0, this.getEngine().isNDCHalfZRange), this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix), this._projectionMatrix;
  }
  _updateCameraRotationMatrix() {
  }
  _updateWebVRCameraRotationMatrix() {
  }
  _getWebVRProjectionMatrix() {
    return x.Identity();
  }
  _getWebVRViewMatrix() {
    return x.Identity();
  }
  setCameraRigParameter(e, t) {
    this._cameraRigParams || (this._cameraRigParams = {}), this._cameraRigParams[e] = t, e === "interaxialDistance" && (this._cameraRigParams.stereoHalfAngle = X.ToRadians(t / 0.0637));
  }
  createRigCamera(e, t) {
    return null;
  }
  _updateRigCameras() {
    for (let e = 0; e < this._rigCameras.length; e++)
      this._rigCameras[e].minZ = this.minZ, this._rigCameras[e].maxZ = this.maxZ, this._rigCameras[e].fov = this.fov, this._rigCameras[e].upVector.copyFrom(this.upVector);
    this.cameraRigMode === q.RIG_MODE_STEREOSCOPIC_ANAGLYPH && (this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport);
  }
  _setupInputs() {
  }
  serialize() {
    const e = ae.Serialize(this);
    return e.uniqueId = this.uniqueId, e.type = this.getClassName(), this.parent && this.parent._serializeAsParent(e), this.inputs && this.inputs.serialize(e), ae.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e;
  }
  clone(e, t = null) {
    const i = ae.Clone(q.GetConstructorFromName(this.getClassName(), e, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
    return i.name = e, i.parent = t, this.onClonedObservable.notifyObservers(i), i;
  }
  getDirection(e) {
    const t = p.Zero();
    return this.getDirectionToRef(e, t), t;
  }
  get absoluteRotation() {
    return this.getWorldMatrix().decompose(void 0, this._absoluteRotation), this._absoluteRotation;
  }
  getDirectionToRef(e, t) {
    p.TransformNormalToRef(e, this.getWorldMatrix(), t);
  }
  static GetConstructorFromName(e, t, i, s = 0, r = !0) {
    const n = Xe.Construct(e, t, i, {
      interaxial_distance: s,
      isStereoscopicSideBySide: r
    });
    return n || (() => q._CreateDefaultParsedCamera(t, i));
  }
  computeWorldMatrix() {
    return this.getWorldMatrix();
  }
  static Parse(e, t) {
    const i = e.type, s = q.GetConstructorFromName(i, e.name, t, e.interaxial_distance, e.isStereoscopicSideBySide), r = ae.Parse(s, e, t);
    if (e.parentId !== void 0 && (r._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (r._waitingParentInstanceIndex = e.parentInstanceIndex), r.inputs && (r.inputs.parse(e), r._setupInputs()), e.upVector && (r.upVector = p.FromArray(e.upVector)), r.setPosition && (r.position.copyFromFloats(0, 0, 0), r.setPosition(p.FromArray(e.position))), e.target && r.setTarget && r.setTarget(p.FromArray(e.target)), e.cameraRigMode) {
      const n = e.interaxial_distance ? { interaxialDistance: e.interaxial_distance } : {};
      r.setCameraRigMode(e.cameraRigMode, n);
    }
    if (e.animations) {
      for (let n = 0; n < e.animations.length; n++) {
        const a = e.animations[n], o = ci("BABYLON.Animation");
        o && r.animations.push(o.Parse(a));
      }
      Xe.ParseAnimationRanges(r, e, t);
    }
    return e.autoAnimate && t.beginAnimation(r, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.isEnabled !== void 0 && r.setEnabled(e.isEnabled), r;
  }
}
q._CreateDefaultParsedCamera = (c, e) => {
  throw Q("UniversalCamera");
};
q.PERSPECTIVE_CAMERA = 0;
q.ORTHOGRAPHIC_CAMERA = 1;
q.FOVMODE_VERTICAL_FIXED = 0;
q.FOVMODE_HORIZONTAL_FIXED = 1;
q.RIG_MODE_NONE = 0;
q.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
q.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
q.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
q.RIG_MODE_VR = 20;
q.RIG_MODE_WEBVR = 21;
q.RIG_MODE_CUSTOM = 22;
q.ForceAttachControlToAlwaysPreventDefault = !1;
T([
  Gt("position")
], q.prototype, "_position", void 0);
T([
  Gt("upVector")
], q.prototype, "_upVector", void 0);
T([
  R()
], q.prototype, "orthoLeft", null);
T([
  R()
], q.prototype, "orthoRight", null);
T([
  R()
], q.prototype, "orthoBottom", null);
T([
  R()
], q.prototype, "orthoTop", null);
T([
  R()
], q.prototype, "fov", void 0);
T([
  R()
], q.prototype, "projectionPlaneTilt", void 0);
T([
  R()
], q.prototype, "minZ", void 0);
T([
  R()
], q.prototype, "maxZ", void 0);
T([
  R()
], q.prototype, "inertia", void 0);
T([
  R()
], q.prototype, "mode", null);
T([
  R()
], q.prototype, "layerMask", void 0);
T([
  R()
], q.prototype, "fovMode", void 0);
T([
  R()
], q.prototype, "cameraRigMode", void 0);
T([
  R()
], q.prototype, "interaxialDistance", void 0);
T([
  R()
], q.prototype, "isStereoscopicSideBySide", void 0);
class J {
  constructor() {
    this._applyTo = Vn(this._applyToCoroutine.bind(this));
  }
  set(e, t) {
    switch (e.length || O.Warn(`Setting vertex data kind '${t}' with an empty array`), t) {
      case g.PositionKind:
        this.positions = e;
        break;
      case g.NormalKind:
        this.normals = e;
        break;
      case g.TangentKind:
        this.tangents = e;
        break;
      case g.UVKind:
        this.uvs = e;
        break;
      case g.UV2Kind:
        this.uvs2 = e;
        break;
      case g.UV3Kind:
        this.uvs3 = e;
        break;
      case g.UV4Kind:
        this.uvs4 = e;
        break;
      case g.UV5Kind:
        this.uvs5 = e;
        break;
      case g.UV6Kind:
        this.uvs6 = e;
        break;
      case g.ColorKind:
        this.colors = e;
        break;
      case g.MatricesIndicesKind:
        this.matricesIndices = e;
        break;
      case g.MatricesWeightsKind:
        this.matricesWeights = e;
        break;
      case g.MatricesIndicesExtraKind:
        this.matricesIndicesExtra = e;
        break;
      case g.MatricesWeightsExtraKind:
        this.matricesWeightsExtra = e;
        break;
    }
  }
  applyToMesh(e, t) {
    return this._applyTo(e, t, !1), this;
  }
  applyToGeometry(e, t) {
    return this._applyTo(e, t, !1), this;
  }
  updateMesh(e) {
    return this._update(e), this;
  }
  updateGeometry(e) {
    return this._update(e), this;
  }
  *_applyToCoroutine(e, t = !1, i) {
    return this.positions && (e.setVerticesData(g.PositionKind, this.positions, t), i && (yield)), this.normals && (e.setVerticesData(g.NormalKind, this.normals, t), i && (yield)), this.tangents && (e.setVerticesData(g.TangentKind, this.tangents, t), i && (yield)), this.uvs && (e.setVerticesData(g.UVKind, this.uvs, t), i && (yield)), this.uvs2 && (e.setVerticesData(g.UV2Kind, this.uvs2, t), i && (yield)), this.uvs3 && (e.setVerticesData(g.UV3Kind, this.uvs3, t), i && (yield)), this.uvs4 && (e.setVerticesData(g.UV4Kind, this.uvs4, t), i && (yield)), this.uvs5 && (e.setVerticesData(g.UV5Kind, this.uvs5, t), i && (yield)), this.uvs6 && (e.setVerticesData(g.UV6Kind, this.uvs6, t), i && (yield)), this.colors && (e.setVerticesData(g.ColorKind, this.colors, t), i && (yield)), this.matricesIndices && (e.setVerticesData(g.MatricesIndicesKind, this.matricesIndices, t), i && (yield)), this.matricesWeights && (e.setVerticesData(g.MatricesWeightsKind, this.matricesWeights, t), i && (yield)), this.matricesIndicesExtra && (e.setVerticesData(g.MatricesIndicesExtraKind, this.matricesIndicesExtra, t), i && (yield)), this.matricesWeightsExtra && (e.setVerticesData(g.MatricesWeightsExtraKind, this.matricesWeightsExtra, t), i && (yield)), this.indices ? (e.setIndices(this.indices, null, t), i && (yield)) : e.setIndices([], null), this;
  }
  _update(e, t, i) {
    return this.positions && e.updateVerticesData(g.PositionKind, this.positions, t, i), this.normals && e.updateVerticesData(g.NormalKind, this.normals, t, i), this.tangents && e.updateVerticesData(g.TangentKind, this.tangents, t, i), this.uvs && e.updateVerticesData(g.UVKind, this.uvs, t, i), this.uvs2 && e.updateVerticesData(g.UV2Kind, this.uvs2, t, i), this.uvs3 && e.updateVerticesData(g.UV3Kind, this.uvs3, t, i), this.uvs4 && e.updateVerticesData(g.UV4Kind, this.uvs4, t, i), this.uvs5 && e.updateVerticesData(g.UV5Kind, this.uvs5, t, i), this.uvs6 && e.updateVerticesData(g.UV6Kind, this.uvs6, t, i), this.colors && e.updateVerticesData(g.ColorKind, this.colors, t, i), this.matricesIndices && e.updateVerticesData(g.MatricesIndicesKind, this.matricesIndices, t, i), this.matricesWeights && e.updateVerticesData(g.MatricesWeightsKind, this.matricesWeights, t, i), this.matricesIndicesExtra && e.updateVerticesData(g.MatricesIndicesExtraKind, this.matricesIndicesExtra, t, i), this.matricesWeightsExtra && e.updateVerticesData(g.MatricesWeightsExtraKind, this.matricesWeightsExtra, t, i), this.indices && e.setIndices(this.indices, null), this;
  }
  static _TransformVector3Coordinates(e, t, i = 0, s = e.length) {
    const r = D.Vector3[0], n = D.Vector3[1];
    for (let a = i; a < i + s; a += 3)
      p.FromArrayToRef(e, a, r), p.TransformCoordinatesToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z;
  }
  static _TransformVector3Normals(e, t, i = 0, s = e.length) {
    const r = D.Vector3[0], n = D.Vector3[1];
    for (let a = i; a < i + s; a += 3)
      p.FromArrayToRef(e, a, r), p.TransformNormalToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z;
  }
  static _TransformVector4Normals(e, t, i = 0, s = e.length) {
    const r = D.Vector4[0], n = D.Vector4[1];
    for (let a = i; a < i + s; a += 4)
      Ae.FromArrayToRef(e, a, r), Ae.TransformNormalToRef(r, t, n), e[a] = n.x, e[a + 1] = n.y, e[a + 2] = n.z, e[a + 3] = n.w;
  }
  static _FlipFaces(e, t = 0, i = e.length) {
    for (let s = t; s < t + i; s += 3) {
      const r = e[s + 1];
      e[s + 1] = e[s + 2], e[s + 2] = r;
    }
  }
  transform(e) {
    const t = e.determinant() < 0;
    return this.positions && J._TransformVector3Coordinates(this.positions, e), this.normals && J._TransformVector3Normals(this.normals, e), this.tangents && J._TransformVector4Normals(this.tangents, e), t && this.indices && J._FlipFaces(this.indices), this;
  }
  merge(e, t = !1, i = !1) {
    const s = Array.isArray(e) ? e.map((r) => [r, void 0]) : [[e, void 0]];
    return Ks(this._mergeCoroutine(void 0, s, t, !1, i));
  }
  *_mergeCoroutine(e, t, i = !1, s, r) {
    var n, a, o, h;
    this._validate();
    const l = t.map((_) => _[0]);
    for (const _ of l)
      if (_._validate(), !this.normals != !_.normals || !this.tangents != !_.tangents || !this.uvs != !_.uvs || !this.uvs2 != !_.uvs2 || !this.uvs3 != !_.uvs3 || !this.uvs4 != !_.uvs4 || !this.uvs5 != !_.uvs5 || !this.uvs6 != !_.uvs6 || !this.colors != !_.colors || !this.matricesIndices != !_.matricesIndices || !this.matricesWeights != !_.matricesWeights || !this.matricesIndicesExtra != !_.matricesIndicesExtra || !this.matricesWeightsExtra != !_.matricesWeightsExtra)
        throw new Error("Cannot merge vertex data that do not have the same set of attributes");
    const u = l.reduce((_, E) => {
      var m, v;
      return _ + ((v = (m = E.indices) === null || m === void 0 ? void 0 : m.length) !== null && v !== void 0 ? v : 0);
    }, (a = (n = this.indices) === null || n === void 0 ? void 0 : n.length) !== null && a !== void 0 ? a : 0);
    let f = r || l.some((_) => _.indices === this.indices) ? (o = this.indices) === null || o === void 0 ? void 0 : o.slice() : this.indices;
    if (u > 0) {
      let _ = (h = f == null ? void 0 : f.length) !== null && h !== void 0 ? h : 0;
      if (f || (f = new Array(u)), f.length !== u) {
        if (Array.isArray(f))
          f.length = u;
        else {
          const m = i || f instanceof Uint32Array ? new Uint32Array(u) : new Uint16Array(u);
          m.set(f), f = m;
        }
        e && e.determinant() < 0 && J._FlipFaces(f, 0, _);
      }
      let E = this.positions ? this.positions.length / 3 : 0;
      for (const [m, v] of t)
        if (m.indices) {
          for (let S = 0; S < m.indices.length; S++)
            f[_ + S] = m.indices[S] + E;
          v && v.determinant() < 0 && J._FlipFaces(f, _, m.indices.length), E += m.positions.length / 3, _ += m.indices.length, s && (yield);
        }
    }
    return this.indices = f, this.positions = J._MergeElement(g.PositionKind, this.positions, e, t.map((_) => [_[0].positions, _[1]])), s && (yield), this.normals = J._MergeElement(g.NormalKind, this.normals, e, t.map((_) => [_[0].normals, _[1]])), s && (yield), this.tangents = J._MergeElement(g.TangentKind, this.tangents, e, t.map((_) => [_[0].tangents, _[1]])), s && (yield), this.uvs = J._MergeElement(g.UVKind, this.uvs, e, t.map((_) => [_[0].uvs, _[1]])), s && (yield), this.uvs2 = J._MergeElement(g.UV2Kind, this.uvs2, e, t.map((_) => [_[0].uvs2, _[1]])), s && (yield), this.uvs3 = J._MergeElement(g.UV3Kind, this.uvs3, e, t.map((_) => [_[0].uvs3, _[1]])), s && (yield), this.uvs4 = J._MergeElement(g.UV4Kind, this.uvs4, e, t.map((_) => [_[0].uvs4, _[1]])), s && (yield), this.uvs5 = J._MergeElement(g.UV5Kind, this.uvs5, e, t.map((_) => [_[0].uvs5, _[1]])), s && (yield), this.uvs6 = J._MergeElement(g.UV6Kind, this.uvs6, e, t.map((_) => [_[0].uvs6, _[1]])), s && (yield), this.colors = J._MergeElement(g.ColorKind, this.colors, e, t.map((_) => [_[0].colors, _[1]])), s && (yield), this.matricesIndices = J._MergeElement(g.MatricesIndicesKind, this.matricesIndices, e, t.map((_) => [_[0].matricesIndices, _[1]])), s && (yield), this.matricesWeights = J._MergeElement(g.MatricesWeightsKind, this.matricesWeights, e, t.map((_) => [_[0].matricesWeights, _[1]])), s && (yield), this.matricesIndicesExtra = J._MergeElement(g.MatricesIndicesExtraKind, this.matricesIndicesExtra, e, t.map((_) => [_[0].matricesIndicesExtra, _[1]])), s && (yield), this.matricesWeightsExtra = J._MergeElement(g.MatricesWeightsExtraKind, this.matricesWeightsExtra, e, t.map((_) => [_[0].matricesWeightsExtra, _[1]])), this;
  }
  static _MergeElement(e, t, i, s) {
    const r = s.filter((o) => o[0] !== null && o[0] !== void 0);
    if (!t && r.length == 0)
      return t;
    if (!t)
      return this._MergeElement(e, r[0][0], r[0][1], r.slice(1));
    const n = r.reduce((o, h) => o + h[0].length, t.length), a = e === g.PositionKind ? J._TransformVector3Coordinates : e === g.NormalKind ? J._TransformVector3Normals : e === g.TangentKind ? J._TransformVector4Normals : () => {
    };
    if (t instanceof Float32Array) {
      const o = new Float32Array(n);
      o.set(t), i && a(o, i, 0, t.length);
      let h = t.length;
      for (const [l, u] of r)
        o.set(l, h), u && a(o, u, h, l.length), h += l.length;
      return o;
    } else {
      const o = new Array(n);
      for (let l = 0; l < t.length; l++)
        o[l] = t[l];
      i && a(o, i, 0, t.length);
      let h = t.length;
      for (const [l, u] of r) {
        for (let d = 0; d < l.length; d++)
          o[h + d] = l[d];
        u && a(o, u, h, l.length), h += l.length;
      }
      return o;
    }
  }
  _validate() {
    if (!this.positions)
      throw new Wt("Positions are required", oi.MeshInvalidPositionsError);
    const e = (s, r) => {
      const n = g.DeduceStride(s);
      if (r.length % n !== 0)
        throw new Error("The " + s + "s array count must be a multiple of " + n);
      return r.length / n;
    }, t = e(g.PositionKind, this.positions), i = (s, r) => {
      const n = e(s, r);
      if (n !== t)
        throw new Error("The " + s + "s element count (" + n + ") does not match the positions count (" + t + ")");
    };
    this.normals && i(g.NormalKind, this.normals), this.tangents && i(g.TangentKind, this.tangents), this.uvs && i(g.UVKind, this.uvs), this.uvs2 && i(g.UV2Kind, this.uvs2), this.uvs3 && i(g.UV3Kind, this.uvs3), this.uvs4 && i(g.UV4Kind, this.uvs4), this.uvs5 && i(g.UV5Kind, this.uvs5), this.uvs6 && i(g.UV6Kind, this.uvs6), this.colors && i(g.ColorKind, this.colors), this.matricesIndices && i(g.MatricesIndicesKind, this.matricesIndices), this.matricesWeights && i(g.MatricesWeightsKind, this.matricesWeights), this.matricesIndicesExtra && i(g.MatricesIndicesExtraKind, this.matricesIndicesExtra), this.matricesWeightsExtra && i(g.MatricesWeightsExtraKind, this.matricesWeightsExtra);
  }
  serialize() {
    const e = {};
    return this.positions && (e.positions = this.positions), this.normals && (e.normals = this.normals), this.tangents && (e.tangents = this.tangents), this.uvs && (e.uvs = this.uvs), this.uvs2 && (e.uvs2 = this.uvs2), this.uvs3 && (e.uvs3 = this.uvs3), this.uvs4 && (e.uvs4 = this.uvs4), this.uvs5 && (e.uvs5 = this.uvs5), this.uvs6 && (e.uvs6 = this.uvs6), this.colors && (e.colors = this.colors), this.matricesIndices && (e.matricesIndices = this.matricesIndices, e.matricesIndices._isExpanded = !0), this.matricesWeights && (e.matricesWeights = this.matricesWeights), this.matricesIndicesExtra && (e.matricesIndicesExtra = this.matricesIndicesExtra, e.matricesIndicesExtra._isExpanded = !0), this.matricesWeightsExtra && (e.matricesWeightsExtra = this.matricesWeightsExtra), e.indices = this.indices, e;
  }
  static ExtractFromMesh(e, t, i) {
    return J._ExtractFrom(e, t, i);
  }
  static ExtractFromGeometry(e, t, i) {
    return J._ExtractFrom(e, t, i);
  }
  static _ExtractFrom(e, t, i) {
    const s = new J();
    return e.isVerticesDataPresent(g.PositionKind) && (s.positions = e.getVerticesData(g.PositionKind, t, i)), e.isVerticesDataPresent(g.NormalKind) && (s.normals = e.getVerticesData(g.NormalKind, t, i)), e.isVerticesDataPresent(g.TangentKind) && (s.tangents = e.getVerticesData(g.TangentKind, t, i)), e.isVerticesDataPresent(g.UVKind) && (s.uvs = e.getVerticesData(g.UVKind, t, i)), e.isVerticesDataPresent(g.UV2Kind) && (s.uvs2 = e.getVerticesData(g.UV2Kind, t, i)), e.isVerticesDataPresent(g.UV3Kind) && (s.uvs3 = e.getVerticesData(g.UV3Kind, t, i)), e.isVerticesDataPresent(g.UV4Kind) && (s.uvs4 = e.getVerticesData(g.UV4Kind, t, i)), e.isVerticesDataPresent(g.UV5Kind) && (s.uvs5 = e.getVerticesData(g.UV5Kind, t, i)), e.isVerticesDataPresent(g.UV6Kind) && (s.uvs6 = e.getVerticesData(g.UV6Kind, t, i)), e.isVerticesDataPresent(g.ColorKind) && (s.colors = e.getVerticesData(g.ColorKind, t, i)), e.isVerticesDataPresent(g.MatricesIndicesKind) && (s.matricesIndices = e.getVerticesData(g.MatricesIndicesKind, t, i)), e.isVerticesDataPresent(g.MatricesWeightsKind) && (s.matricesWeights = e.getVerticesData(g.MatricesWeightsKind, t, i)), e.isVerticesDataPresent(g.MatricesIndicesExtraKind) && (s.matricesIndicesExtra = e.getVerticesData(g.MatricesIndicesExtraKind, t, i)), e.isVerticesDataPresent(g.MatricesWeightsExtraKind) && (s.matricesWeightsExtra = e.getVerticesData(g.MatricesWeightsExtraKind, t, i)), s.indices = e.getIndices(t, i), s;
  }
  static CreateRibbon(e) {
    throw Q("ribbonBuilder");
  }
  static CreateBox(e) {
    throw Q("boxBuilder");
  }
  static CreateTiledBox(e) {
    throw Q("tiledBoxBuilder");
  }
  static CreateTiledPlane(e) {
    throw Q("tiledPlaneBuilder");
  }
  static CreateSphere(e) {
    throw Q("sphereBuilder");
  }
  static CreateCylinder(e) {
    throw Q("cylinderBuilder");
  }
  static CreateTorus(e) {
    throw Q("torusBuilder");
  }
  static CreateLineSystem(e) {
    throw Q("linesBuilder");
  }
  static CreateDashedLines(e) {
    throw Q("linesBuilder");
  }
  static CreateGround(e) {
    throw Q("groundBuilder");
  }
  static CreateTiledGround(e) {
    throw Q("groundBuilder");
  }
  static CreateGroundFromHeightMap(e) {
    throw Q("groundBuilder");
  }
  static CreatePlane(e) {
    throw Q("planeBuilder");
  }
  static CreateDisc(e) {
    throw Q("discBuilder");
  }
  static CreatePolygon(e, t, i, s, r, n, a) {
    throw Q("polygonBuilder");
  }
  static CreateIcoSphere(e) {
    throw Q("icoSphereBuilder");
  }
  static CreatePolyhedron(e) {
    throw Q("polyhedronBuilder");
  }
  static CreateCapsule(e = {
    orientation: p.Up(),
    subdivisions: 2,
    tessellation: 16,
    height: 1,
    radius: 0.25,
    capSubdivisions: 6
  }) {
    throw Q("capsuleBuilder");
  }
  static CreateTorusKnot(e) {
    throw Q("torusKnotBuilder");
  }
  static ComputeNormals(e, t, i, s) {
    let r = 0, n = 0, a = 0, o = 0, h = 0, l = 0, u = 0, d = 0, f = 0, _ = 0, E = 0, m = 0, v = 0, S = 0, y = 0, A = 0, C = 0, b = 0, M = 0, L = 0, k = !1, F = !1, ue = !1, ce = !1, ie = 1, ee = 0, Ce = null;
    s && (k = !!s.facetNormals, F = !!s.facetPositions, ue = !!s.facetPartitioning, ie = s.useRightHandedSystem === !0 ? -1 : 1, ee = s.ratio || 0, ce = !!s.depthSort, Ce = s.distanceTo, ce && Ce === void 0 && (Ce = p.Zero()));
    let Ie = 0, Be = 0, Ue = 0, ke = 0;
    for (ue && s && s.bbSize && (Ie = s.subDiv.X * ee / s.bbSize.x, Be = s.subDiv.Y * ee / s.bbSize.y, Ue = s.subDiv.Z * ee / s.bbSize.z, ke = s.subDiv.max * s.subDiv.max, s.facetPartitioning.length = 0), r = 0; r < e.length; r++)
      i[r] = 0;
    const ht = t.length / 3 | 0;
    for (r = 0; r < ht; r++) {
      if (m = t[r * 3] * 3, v = m + 1, S = m + 2, y = t[r * 3 + 1] * 3, A = y + 1, C = y + 2, b = t[r * 3 + 2] * 3, M = b + 1, L = b + 2, n = e[m] - e[y], a = e[v] - e[A], o = e[S] - e[C], h = e[b] - e[y], l = e[M] - e[A], u = e[L] - e[C], d = ie * (a * u - o * l), f = ie * (o * h - n * u), _ = ie * (n * l - a * h), E = Math.sqrt(d * d + f * f + _ * _), E = E === 0 ? 1 : E, d /= E, f /= E, _ /= E, k && s && (s.facetNormals[r].x = d, s.facetNormals[r].y = f, s.facetNormals[r].z = _), F && s && (s.facetPositions[r].x = (e[m] + e[y] + e[b]) / 3, s.facetPositions[r].y = (e[v] + e[A] + e[M]) / 3, s.facetPositions[r].z = (e[S] + e[C] + e[L]) / 3), ue && s) {
        const rt = Math.floor((s.facetPositions[r].x - s.bInfo.minimum.x * ee) * Ie), Mt = Math.floor((s.facetPositions[r].y - s.bInfo.minimum.y * ee) * Be), Kt = Math.floor((s.facetPositions[r].z - s.bInfo.minimum.z * ee) * Ue), zi = Math.floor((e[m] - s.bInfo.minimum.x * ee) * Ie), Gi = Math.floor((e[v] - s.bInfo.minimum.y * ee) * Be), Xi = Math.floor((e[S] - s.bInfo.minimum.z * ee) * Ue), _s = Math.floor((e[y] - s.bInfo.minimum.x * ee) * Ie), gs = Math.floor((e[A] - s.bInfo.minimum.y * ee) * Be), ps = Math.floor((e[C] - s.bInfo.minimum.z * ee) * Ue), ms = Math.floor((e[b] - s.bInfo.minimum.x * ee) * Ie), Es = Math.floor((e[M] - s.bInfo.minimum.y * ee) * Be), vs = Math.floor((e[L] - s.bInfo.minimum.z * ee) * Ue), Dt = zi + s.subDiv.max * Gi + ke * Xi, Ft = _s + s.subDiv.max * gs + ke * ps, wt = ms + s.subDiv.max * Es + ke * vs, Ot = rt + s.subDiv.max * Mt + ke * Kt;
        s.facetPartitioning[Ot] = s.facetPartitioning[Ot] ? s.facetPartitioning[Ot] : new Array(), s.facetPartitioning[Dt] = s.facetPartitioning[Dt] ? s.facetPartitioning[Dt] : new Array(), s.facetPartitioning[Ft] = s.facetPartitioning[Ft] ? s.facetPartitioning[Ft] : new Array(), s.facetPartitioning[wt] = s.facetPartitioning[wt] ? s.facetPartitioning[wt] : new Array(), s.facetPartitioning[Dt].push(r), Ft != Dt && s.facetPartitioning[Ft].push(r), wt == Ft || wt == Dt || s.facetPartitioning[wt].push(r), Ot == Dt || Ot == Ft || Ot == wt || s.facetPartitioning[Ot].push(r);
      }
      if (ce && s && s.facetPositions) {
        const rt = s.depthSortedFacets[r];
        rt.ind = r * 3, rt.sqDistance = p.DistanceSquared(s.facetPositions[r], Ce);
      }
      i[m] += d, i[v] += f, i[S] += _, i[y] += d, i[A] += f, i[C] += _, i[b] += d, i[M] += f, i[L] += _;
    }
    for (r = 0; r < i.length / 3; r++)
      d = i[r * 3], f = i[r * 3 + 1], _ = i[r * 3 + 2], E = Math.sqrt(d * d + f * f + _ * _), E = E === 0 ? 1 : E, d /= E, f /= E, _ /= E, i[r * 3] = d, i[r * 3 + 1] = f, i[r * 3 + 2] = _;
  }
  static _ComputeSides(e, t, i, s, r, n, a) {
    const o = i.length, h = s.length;
    let l, u;
    switch (e = e || J.DEFAULTSIDE, e) {
      case J.FRONTSIDE:
        break;
      case J.BACKSIDE:
        for (l = 0; l < o; l += 3) {
          const d = i[l];
          i[l] = i[l + 2], i[l + 2] = d;
        }
        for (u = 0; u < h; u++)
          s[u] = -s[u];
        break;
      case J.DOUBLESIDE: {
        const d = t.length, f = d / 3;
        for (let m = 0; m < d; m++)
          t[d + m] = t[m];
        for (l = 0; l < o; l += 3)
          i[l + o] = i[l + 2] + f, i[l + 1 + o] = i[l + 1] + f, i[l + 2 + o] = i[l] + f;
        for (u = 0; u < h; u++)
          s[h + u] = -s[u];
        const _ = r.length;
        let E = 0;
        for (E = 0; E < _; E++)
          r[E + _] = r[E];
        for (n = n || new Ae(0, 0, 1, 1), a = a || new Ae(0, 0, 1, 1), E = 0, l = 0; l < _ / 2; l++)
          r[E] = n.x + (n.z - n.x) * r[E], r[E + 1] = n.y + (n.w - n.y) * r[E + 1], r[E + _] = a.x + (a.z - a.x) * r[E + _], r[E + _ + 1] = a.y + (a.w - a.y) * r[E + _ + 1], E += 2;
        break;
      }
    }
  }
  static ImportVertexData(e, t) {
    const i = new J(), s = e.positions;
    s && i.set(s, g.PositionKind);
    const r = e.normals;
    r && i.set(r, g.NormalKind);
    const n = e.tangents;
    n && i.set(n, g.TangentKind);
    const a = e.uvs;
    a && i.set(a, g.UVKind);
    const o = e.uv2s;
    o && i.set(o, g.UV2Kind);
    const h = e.uv3s;
    h && i.set(h, g.UV3Kind);
    const l = e.uv4s;
    l && i.set(l, g.UV4Kind);
    const u = e.uv5s;
    u && i.set(u, g.UV5Kind);
    const d = e.uv6s;
    d && i.set(d, g.UV6Kind);
    const f = e.colors;
    f && i.set(ge.CheckColors4(f, s.length / 3), g.ColorKind);
    const _ = e.matricesIndices;
    _ && i.set(_, g.MatricesIndicesKind);
    const E = e.matricesWeights;
    E && i.set(E, g.MatricesWeightsKind);
    const m = e.indices;
    m && (i.indices = m), t.setAllVerticesData(i, e.updatable);
  }
}
J.FRONTSIDE = 0;
J.BACKSIDE = 1;
J.DOUBLESIDE = 2;
J.DEFAULTSIDE = 0;
T([
  $t.filter((...[c]) => !Array.isArray(c))
], J, "_TransformVector3Coordinates", null);
T([
  $t.filter((...[c]) => !Array.isArray(c))
], J, "_TransformVector3Normals", null);
T([
  $t.filter((...[c]) => !Array.isArray(c))
], J, "_TransformVector4Normals", null);
T([
  $t.filter((...[c]) => !Array.isArray(c))
], J, "_FlipFaces", null);
class Ns {
  constructor(e, t, i) {
    this.bu = e, this.bv = t, this.distance = i, this.faceId = 0, this.subMeshId = 0;
  }
}
class Ut {
  constructor(e, t, i) {
    this.vectors = Ye.BuildArray(8, p.Zero), this.center = p.Zero(), this.centerWorld = p.Zero(), this.extendSize = p.Zero(), this.extendSizeWorld = p.Zero(), this.directions = Ye.BuildArray(3, p.Zero), this.vectorsWorld = Ye.BuildArray(8, p.Zero), this.minimumWorld = p.Zero(), this.maximumWorld = p.Zero(), this.minimum = p.Zero(), this.maximum = p.Zero(), this._drawWrapperFront = null, this._drawWrapperBack = null, this.reConstruct(e, t, i);
  }
  reConstruct(e, t, i) {
    const s = e.x, r = e.y, n = e.z, a = t.x, o = t.y, h = t.z, l = this.vectors;
    this.minimum.copyFromFloats(s, r, n), this.maximum.copyFromFloats(a, o, h), l[0].copyFromFloats(s, r, n), l[1].copyFromFloats(a, o, h), l[2].copyFromFloats(a, r, n), l[3].copyFromFloats(s, o, n), l[4].copyFromFloats(s, r, h), l[5].copyFromFloats(a, o, n), l[6].copyFromFloats(s, o, h), l[7].copyFromFloats(a, r, h), t.addToRef(e, this.center).scaleInPlace(0.5), t.subtractToRef(e, this.extendSize).scaleInPlace(0.5), this._worldMatrix = i || x.IdentityReadOnly, this._update(this._worldMatrix);
  }
  scale(e) {
    const t = Ut._TmpVector3, i = this.maximum.subtractToRef(this.minimum, t[0]), s = i.length();
    i.normalizeFromLength(s);
    const r = s * e, n = i.scaleInPlace(r * 0.5), a = this.center.subtractToRef(n, t[1]), o = this.center.addToRef(n, t[2]);
    return this.reConstruct(a, o, this._worldMatrix), this;
  }
  getWorldMatrix() {
    return this._worldMatrix;
  }
  _update(e) {
    const t = this.minimumWorld, i = this.maximumWorld, s = this.directions, r = this.vectorsWorld, n = this.vectors;
    if (e.isIdentity()) {
      t.copyFrom(this.minimum), i.copyFrom(this.maximum);
      for (let a = 0; a < 8; ++a)
        r[a].copyFrom(n[a]);
      this.extendSizeWorld.copyFrom(this.extendSize), this.centerWorld.copyFrom(this.center);
    } else {
      t.setAll(Number.MAX_VALUE), i.setAll(-Number.MAX_VALUE);
      for (let a = 0; a < 8; ++a) {
        const o = r[a];
        p.TransformCoordinatesToRef(n[a], e, o), t.minimizeInPlace(o), i.maximizeInPlace(o);
      }
      i.subtractToRef(t, this.extendSizeWorld).scaleInPlace(0.5), i.addToRef(t, this.centerWorld).scaleInPlace(0.5);
    }
    p.FromArrayToRef(e.m, 0, s[0]), p.FromArrayToRef(e.m, 4, s[1]), p.FromArrayToRef(e.m, 8, s[2]), this._worldMatrix = e;
  }
  isInFrustum(e) {
    return Ut.IsInFrustum(this.vectorsWorld, e);
  }
  isCompletelyInFrustum(e) {
    return Ut.IsCompletelyInFrustum(this.vectorsWorld, e);
  }
  intersectsPoint(e) {
    const t = this.minimumWorld, i = this.maximumWorld, s = t.x, r = t.y, n = t.z, a = i.x, o = i.y, h = i.z, l = e.x, u = e.y, d = e.z, f = -Re;
    return !(a - l < f || f > l - s || o - u < f || f > u - r || h - d < f || f > d - n);
  }
  intersectsSphere(e) {
    return Ut.IntersectsSphere(this.minimumWorld, this.maximumWorld, e.centerWorld, e.radiusWorld);
  }
  intersectsMinMax(e, t) {
    const i = this.minimumWorld, s = this.maximumWorld, r = i.x, n = i.y, a = i.z, o = s.x, h = s.y, l = s.z, u = e.x, d = e.y, f = e.z, _ = t.x, E = t.y, m = t.z;
    return !(o < u || r > _ || h < d || n > E || l < f || a > m);
  }
  dispose() {
    var e, t;
    (e = this._drawWrapperFront) === null || e === void 0 || e.dispose(), (t = this._drawWrapperBack) === null || t === void 0 || t.dispose();
  }
  static Intersects(e, t) {
    return e.intersectsMinMax(t.minimumWorld, t.maximumWorld);
  }
  static IntersectsSphere(e, t, i, s) {
    const r = Ut._TmpVector3[0];
    return p.ClampToRef(i, e, t, r), p.DistanceSquared(i, r) <= s * s;
  }
  static IsCompletelyInFrustum(e, t) {
    for (let i = 0; i < 6; ++i) {
      const s = t[i];
      for (let r = 0; r < 8; ++r)
        if (s.dotCoordinate(e[r]) < 0)
          return !1;
    }
    return !0;
  }
  static IsInFrustum(e, t) {
    for (let i = 0; i < 6; ++i) {
      let s = !0;
      const r = t[i];
      for (let n = 0; n < 8; ++n)
        if (r.dotCoordinate(e[n]) >= 0) {
          s = !1;
          break;
        }
      if (s)
        return !1;
    }
    return !0;
  }
}
Ut._TmpVector3 = Ye.BuildArray(3, p.Zero);
class hi {
  constructor(e, t, i) {
    this.center = p.Zero(), this.centerWorld = p.Zero(), this.minimum = p.Zero(), this.maximum = p.Zero(), this.reConstruct(e, t, i);
  }
  reConstruct(e, t, i) {
    this.minimum.copyFrom(e), this.maximum.copyFrom(t);
    const s = p.Distance(e, t);
    t.addToRef(e, this.center).scaleInPlace(0.5), this.radius = s * 0.5, this._update(i || x.IdentityReadOnly);
  }
  scale(e) {
    const t = this.radius * e, i = hi._TmpVector3, s = i[0].setAll(t), r = this.center.subtractToRef(s, i[1]), n = this.center.addToRef(s, i[2]);
    return this.reConstruct(r, n, this._worldMatrix), this;
  }
  getWorldMatrix() {
    return this._worldMatrix;
  }
  _update(e) {
    if (e.isIdentity())
      this.centerWorld.copyFrom(this.center), this.radiusWorld = this.radius;
    else {
      p.TransformCoordinatesToRef(this.center, e, this.centerWorld);
      const t = hi._TmpVector3[0];
      p.TransformNormalFromFloatsToRef(1, 1, 1, e, t), this.radiusWorld = Math.max(Math.abs(t.x), Math.abs(t.y), Math.abs(t.z)) * this.radius;
    }
  }
  isInFrustum(e) {
    const t = this.centerWorld, i = this.radiusWorld;
    for (let s = 0; s < 6; s++)
      if (e[s].dotCoordinate(t) <= -i)
        return !1;
    return !0;
  }
  isCenterInFrustum(e) {
    const t = this.centerWorld;
    for (let i = 0; i < 6; i++)
      if (e[i].dotCoordinate(t) < 0)
        return !1;
    return !0;
  }
  intersectsPoint(e) {
    const t = p.DistanceSquared(this.centerWorld, e);
    return !(this.radiusWorld * this.radiusWorld < t);
  }
  static Intersects(e, t) {
    const i = p.DistanceSquared(e.centerWorld, t.centerWorld), s = e.radiusWorld + t.radiusWorld;
    return !(s * s < i);
  }
  static CreateFromCenterAndRadius(e, t, i) {
    this._TmpVector3[0].copyFrom(e), this._TmpVector3[1].copyFromFloats(0, 0, t), this._TmpVector3[2].copyFrom(e), this._TmpVector3[0].addInPlace(this._TmpVector3[1]), this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
    const s = new hi(this._TmpVector3[0], this._TmpVector3[2]);
    return i ? s._worldMatrix = i : s._worldMatrix = x.Identity(), s;
  }
}
hi._TmpVector3 = Ye.BuildArray(3, p.Zero);
const xs = { min: 0, max: 0 }, Ms = { min: 0, max: 0 }, ur = (c, e, t) => {
  const i = p.Dot(e.centerWorld, c), s = Math.abs(p.Dot(e.directions[0], c)) * e.extendSize.x, r = Math.abs(p.Dot(e.directions[1], c)) * e.extendSize.y, n = Math.abs(p.Dot(e.directions[2], c)) * e.extendSize.z, a = s + r + n;
  t.min = i - a, t.max = i + a;
}, tt = (c, e, t) => (ur(c, e, xs), ur(c, t, Ms), !(xs.min > Ms.max || Ms.min > xs.max));
class ft {
  constructor(e, t, i) {
    this._isLocked = !1, this.boundingBox = new Ut(e, t, i), this.boundingSphere = new hi(e, t, i);
  }
  reConstruct(e, t, i) {
    this.boundingBox.reConstruct(e, t, i), this.boundingSphere.reConstruct(e, t, i);
  }
  get minimum() {
    return this.boundingBox.minimum;
  }
  get maximum() {
    return this.boundingBox.maximum;
  }
  get isLocked() {
    return this._isLocked;
  }
  set isLocked(e) {
    this._isLocked = e;
  }
  update(e) {
    this._isLocked || (this.boundingBox._update(e), this.boundingSphere._update(e));
  }
  centerOn(e, t) {
    const i = ft._TmpVector3[0].copyFrom(e).subtractInPlace(t), s = ft._TmpVector3[1].copyFrom(e).addInPlace(t);
    return this.boundingBox.reConstruct(i, s, this.boundingBox.getWorldMatrix()), this.boundingSphere.reConstruct(i, s, this.boundingBox.getWorldMatrix()), this;
  }
  encapsulate(e) {
    const t = p.Minimize(this.minimum, e), i = p.Maximize(this.maximum, e);
    return this.reConstruct(t, i, this.boundingBox.getWorldMatrix()), this;
  }
  encapsulateBoundingInfo(e) {
    return this.encapsulate(e.boundingBox.centerWorld.subtract(e.boundingBox.extendSizeWorld)), this.encapsulate(e.boundingBox.centerWorld.add(e.boundingBox.extendSizeWorld)), this;
  }
  scale(e) {
    return this.boundingBox.scale(e), this.boundingSphere.scale(e), this;
  }
  isInFrustum(e, t = 0) {
    return (t === 2 || t === 3) && this.boundingSphere.isCenterInFrustum(e) ? !0 : this.boundingSphere.isInFrustum(e) ? t === 1 || t === 3 ? !0 : this.boundingBox.isInFrustum(e) : !1;
  }
  get diagonalLength() {
    const e = this.boundingBox;
    return e.maximumWorld.subtractToRef(e.minimumWorld, ft._TmpVector3[0]).length();
  }
  isCompletelyInFrustum(e) {
    return this.boundingBox.isCompletelyInFrustum(e);
  }
  _checkCollision(e) {
    return e._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
  }
  intersectsPoint(e) {
    return !(!this.boundingSphere.centerWorld || !this.boundingSphere.intersectsPoint(e) || !this.boundingBox.intersectsPoint(e));
  }
  intersects(e, t) {
    if (!hi.Intersects(this.boundingSphere, e.boundingSphere) || !Ut.Intersects(this.boundingBox, e.boundingBox))
      return !1;
    if (!t)
      return !0;
    const i = this.boundingBox, s = e.boundingBox;
    return !(!tt(i.directions[0], i, s) || !tt(i.directions[1], i, s) || !tt(i.directions[2], i, s) || !tt(s.directions[0], i, s) || !tt(s.directions[1], i, s) || !tt(s.directions[2], i, s) || !tt(p.Cross(i.directions[0], s.directions[0]), i, s) || !tt(p.Cross(i.directions[0], s.directions[1]), i, s) || !tt(p.Cross(i.directions[0], s.directions[2]), i, s) || !tt(p.Cross(i.directions[1], s.directions[0]), i, s) || !tt(p.Cross(i.directions[1], s.directions[1]), i, s) || !tt(p.Cross(i.directions[1], s.directions[2]), i, s) || !tt(p.Cross(i.directions[2], s.directions[0]), i, s) || !tt(p.Cross(i.directions[2], s.directions[1]), i, s) || !tt(p.Cross(i.directions[2], s.directions[2]), i, s));
  }
}
ft._TmpVector3 = Ye.BuildArray(2, p.Zero);
class hs {
  static extractMinAndMaxIndexed(e, t, i, s, r, n) {
    for (let a = i; a < i + s; a++) {
      const o = t[a] * 3, h = e[o], l = e[o + 1], u = e[o + 2];
      r.minimizeInPlaceFromFloats(h, l, u), n.maximizeInPlaceFromFloats(h, l, u);
    }
  }
  static extractMinAndMax(e, t, i, s, r, n) {
    for (let a = t, o = t * s; a < t + i; a++, o += s) {
      const h = e[o], l = e[o + 1], u = e[o + 2];
      r.minimizeInPlaceFromFloats(h, l, u), n.maximizeInPlaceFromFloats(h, l, u);
    }
  }
}
T([
  $t.filter((...[c, e]) => !Array.isArray(c) && !Array.isArray(e))
], hs, "extractMinAndMaxIndexed", null);
T([
  $t.filter((...[c]) => !Array.isArray(c))
], hs, "extractMinAndMax", null);
function zn(c, e, t, i, s = null) {
  const r = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new p(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  return hs.extractMinAndMaxIndexed(c, e, t, i, r, n), s && (r.x -= r.x * s.x + s.y, r.y -= r.y * s.x + s.y, r.z -= r.z * s.x + s.y, n.x += n.x * s.x + s.y, n.y += n.y * s.x + s.y, n.z += n.z * s.x + s.y), {
    minimum: r,
    maximum: n
  };
}
function Nr(c, e, t, i = null, s) {
  const r = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), n = new p(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  return s || (s = 3), hs.extractMinAndMax(c, e, t, s, r, n), i && (r.x -= r.x * i.x + i.y, r.y -= r.y * i.x + i.y, r.z -= r.z * i.x + i.y, n.x += n.x * i.x + i.y, n.y += n.y * i.x + i.y, n.z += n.z * i.x + i.y), {
    minimum: r,
    maximum: n
  };
}
class Et {
  constructor(e, t, i, s, r, n, a, o = !0, h = !0) {
    this.materialIndex = e, this.verticesStart = t, this.verticesCount = i, this.indexStart = s, this.indexCount = r, this._mainDrawWrapperOverride = null, this._linesIndexCount = 0, this._linesIndexBuffer = null, this._lastColliderWorldVertices = null, this._lastColliderTransformMatrix = null, this._wasDispatched = !1, this._renderId = 0, this._alphaIndex = 0, this._distanceToCamera = 0, this._currentMaterial = null, this._mesh = n, this._renderingMesh = a || n, h && n.subMeshes.push(this), this._engine = this._mesh.getScene().getEngine(), this.resetDrawCache(), this._trianglePlanes = [], this._id = n.subMeshes.length - 1, o && (this.refreshBoundingInfo(), n.computeWorldMatrix(!0));
  }
  get materialDefines() {
    var e;
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (e = this._getDrawWrapper()) === null || e === void 0 ? void 0 : e.defines;
  }
  set materialDefines(e) {
    var t;
    const i = (t = this._mainDrawWrapperOverride) !== null && t !== void 0 ? t : this._getDrawWrapper(void 0, !0);
    i.defines = e;
  }
  _getDrawWrapper(e, t = !1) {
    e = e != null ? e : this._engine.currentRenderPassId;
    let i = this._drawWrappers[e];
    return !i && t && (this._drawWrappers[e] = i = new Ri(this._mesh.getScene().getEngine())), i;
  }
  _removeDrawWrapper(e, t = !0) {
    var i;
    t && ((i = this._drawWrappers[e]) === null || i === void 0 || i.dispose()), this._drawWrappers[e] = void 0;
  }
  get effect() {
    var e, t;
    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (t = (e = this._getDrawWrapper()) === null || e === void 0 ? void 0 : e.effect) !== null && t !== void 0 ? t : null;
  }
  get _drawWrapper() {
    var e;
    return (e = this._mainDrawWrapperOverride) !== null && e !== void 0 ? e : this._getDrawWrapper(void 0, !0);
  }
  get _drawWrapperOverride() {
    return this._mainDrawWrapperOverride;
  }
  _setMainDrawWrapperOverride(e) {
    this._mainDrawWrapperOverride = e;
  }
  setEffect(e, t = null, i, s = !0) {
    const r = this._drawWrapper;
    r.setEffect(e, t, s), i !== void 0 && (r.materialContext = i), e || (r.defines = null, r.materialContext = void 0);
  }
  resetDrawCache(e) {
    if (this._drawWrappers)
      if (e !== void 0) {
        this._removeDrawWrapper(e);
        return;
      } else
        for (const t of this._drawWrappers)
          t == null || t.dispose();
    this._drawWrappers = [];
  }
  static AddToMesh(e, t, i, s, r, n, a, o = !0) {
    return new Et(e, t, i, s, r, n, a, o);
  }
  get IsGlobal() {
    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
  }
  getBoundingInfo() {
    return this.IsGlobal ? this._mesh.getBoundingInfo() : this._boundingInfo;
  }
  setBoundingInfo(e) {
    return this._boundingInfo = e, this;
  }
  getMesh() {
    return this._mesh;
  }
  getRenderingMesh() {
    return this._renderingMesh;
  }
  getReplacementMesh() {
    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
  }
  getEffectiveMesh() {
    const e = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
    return e || this._renderingMesh;
  }
  getMaterial(e = !0) {
    var t;
    const i = (t = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && t !== void 0 ? t : this._renderingMesh.material;
    if (i) {
      if (this._isMultiMaterial(i)) {
        const s = i.getSubMaterial(this.materialIndex);
        return this._currentMaterial !== s && (this._currentMaterial = s, this.resetDrawCache()), s;
      }
    } else
      return e ? this._mesh.getScene().defaultMaterial : null;
    return i;
  }
  _isMultiMaterial(e) {
    return e.getSubMaterial !== void 0;
  }
  refreshBoundingInfo(e = null) {
    if (this._lastColliderWorldVertices = null, this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry)
      return this;
    if (e || (e = this._renderingMesh.getVerticesData(g.PositionKind)), !e)
      return this._boundingInfo = this._mesh.getBoundingInfo(), this;
    const t = this._renderingMesh.getIndices();
    let i;
    if (this.indexStart === 0 && this.indexCount === t.length) {
      const s = this._renderingMesh.getBoundingInfo();
      i = { minimum: s.minimum.clone(), maximum: s.maximum.clone() };
    } else
      i = zn(e, t, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
    return this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new ft(i.minimum, i.maximum), this;
  }
  _checkCollision(e) {
    return this.getBoundingInfo()._checkCollision(e);
  }
  updateBoundingInfo(e) {
    let t = this.getBoundingInfo();
    return t || (this.refreshBoundingInfo(), t = this.getBoundingInfo()), t && t.update(e), this;
  }
  isInFrustum(e) {
    const t = this.getBoundingInfo();
    return t ? t.isInFrustum(e, this._mesh.cullingStrategy) : !1;
  }
  isCompletelyInFrustum(e) {
    const t = this.getBoundingInfo();
    return t ? t.isCompletelyInFrustum(e) : !1;
  }
  render(e) {
    return this._renderingMesh.render(this, e, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0), this;
  }
  _getLinesIndexBuffer(e, t) {
    if (!this._linesIndexBuffer) {
      const i = [];
      for (let s = this.indexStart; s < this.indexStart + this.indexCount; s += 3)
        i.push(e[s], e[s + 1], e[s + 1], e[s + 2], e[s + 2], e[s]);
      this._linesIndexBuffer = t.createIndexBuffer(i), this._linesIndexCount = i.length;
    }
    return this._linesIndexBuffer;
  }
  canIntersects(e) {
    const t = this.getBoundingInfo();
    return t ? e.intersectsBox(t.boundingBox) : !1;
  }
  intersects(e, t, i, s, r) {
    const n = this.getMaterial();
    if (!n)
      return null;
    let a = 3, o = !1;
    switch (n.fillMode) {
      case 3:
      case 5:
      case 6:
      case 8:
        return null;
      case 7:
        a = 1, o = !0;
        break;
    }
    return n.fillMode === 4 ? i.length ? this._intersectLines(e, t, i, this._mesh.intersectionThreshold, s) : this._intersectUnIndexedLines(e, t, i, this._mesh.intersectionThreshold, s) : !i.length && this._mesh._unIndexed ? this._intersectUnIndexedTriangles(e, t, i, s, r) : this._intersectTriangles(e, t, i, a, o, s, r);
  }
  _intersectLines(e, t, i, s, r) {
    let n = null;
    for (let a = this.indexStart; a < this.indexStart + this.indexCount; a += 2) {
      const o = t[i[a]], h = t[i[a + 1]], l = e.intersectionSegment(o, h, s);
      if (!(l < 0) && (r || !n || l < n.distance) && (n = new Ns(null, null, l), n.faceId = a / 2, r))
        break;
    }
    return n;
  }
  _intersectUnIndexedLines(e, t, i, s, r) {
    let n = null;
    for (let a = this.verticesStart; a < this.verticesStart + this.verticesCount; a += 2) {
      const o = t[a], h = t[a + 1], l = e.intersectionSegment(o, h, s);
      if (!(l < 0) && (r || !n || l < n.distance) && (n = new Ns(null, null, l), n.faceId = a / 2, r))
        break;
    }
    return n;
  }
  _intersectTriangles(e, t, i, s, r, n, a) {
    let o = null, h = -1;
    for (let l = this.indexStart; l < this.indexStart + this.indexCount - (3 - s); l += s) {
      h++;
      const u = i[l], d = i[l + 1], f = i[l + 2];
      if (r && f === 4294967295) {
        l += 2;
        continue;
      }
      const _ = t[u], E = t[d], m = t[f];
      if (!_ || !E || !m || a && !a(_, E, m, e, u, d, f))
        continue;
      const v = e.intersectsTriangle(_, E, m);
      if (v) {
        if (v.distance < 0)
          continue;
        if ((n || !o || v.distance < o.distance) && (o = v, o.faceId = h, n))
          break;
      }
    }
    return o;
  }
  _intersectUnIndexedTriangles(e, t, i, s, r) {
    let n = null;
    for (let a = this.verticesStart; a < this.verticesStart + this.verticesCount; a += 3) {
      const o = t[a], h = t[a + 1], l = t[a + 2];
      if (r && !r(o, h, l, e, -1, -1, -1))
        continue;
      const u = e.intersectsTriangle(o, h, l);
      if (u) {
        if (u.distance < 0)
          continue;
        if ((s || !n || u.distance < n.distance) && (n = u, n.faceId = a / 3, s))
          break;
      }
    }
    return n;
  }
  _rebuild() {
    this._linesIndexBuffer && (this._linesIndexBuffer = null);
  }
  clone(e, t) {
    const i = new Et(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, e, t, !1);
    if (!this.IsGlobal) {
      const s = this.getBoundingInfo();
      if (!s)
        return i;
      i._boundingInfo = new ft(s.minimum, s.maximum);
    }
    return i;
  }
  dispose() {
    this._linesIndexBuffer && (this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer), this._linesIndexBuffer = null);
    const e = this._mesh.subMeshes.indexOf(this);
    this._mesh.subMeshes.splice(e, 1), this.resetDrawCache();
  }
  getClassName() {
    return "SubMesh";
  }
  static CreateFromIndices(e, t, i, s, r, n = !0) {
    let a = Number.MAX_VALUE, o = -Number.MAX_VALUE;
    const l = (r || s).getIndices();
    for (let u = t; u < t + i; u++) {
      const d = l[u];
      d < a && (a = d), d > o && (o = d);
    }
    return new Et(e, a, o - a + 1, t, i, s, r, n);
  }
}
class we {
  static get ForceFullSceneLoadingForIncremental() {
    return we._ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(e) {
    we._ForceFullSceneLoadingForIncremental = e;
  }
  static get ShowLoadingScreen() {
    return we._ShowLoadingScreen;
  }
  static set ShowLoadingScreen(e) {
    we._ShowLoadingScreen = e;
  }
  static get loggingLevel() {
    return we._LoggingLevel;
  }
  static set loggingLevel(e) {
    we._LoggingLevel = e;
  }
  static get CleanBoneMatrixWeights() {
    return we._CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(e) {
    we._CleanBoneMatrixWeights = e;
  }
}
we._ForceFullSceneLoadingForIncremental = !1;
we._ShowLoadingScreen = !0;
we._CleanBoneMatrixWeights = !1;
we._LoggingLevel = 0;
class ut {
}
ut.UseOpenGLOrientationForUV = !1;
class at {
  constructor(e, t, i, s = !1, r = null) {
    this.delayLoadState = 0, this._totalVertices = 0, this._isDisposed = !1, this._indexBufferIsUpdatable = !1, this._positionsCache = [], this._parentContainer = null, this.useBoundingInfoFromGeometry = !1, this._scene = t || fe.LastCreatedScene, this._scene && (this.id = e, this.uniqueId = this._scene.getUniqueId(), this._engine = this._scene.getEngine(), this._meshes = [], this._vertexBuffers = {}, this._indices = [], this._updatable = s, i ? this.setAllVerticesData(i, s) : this._totalVertices = 0, this._engine.getCaps().vertexArrayObject && (this._vertexArrayObjects = {}), r && (this.applyToMesh(r), r.computeWorldMatrix(!0)));
  }
  get boundingBias() {
    return this._boundingBias;
  }
  set boundingBias(e) {
    this._boundingBias ? this._boundingBias.copyFrom(e) : this._boundingBias = e.clone(), this._updateBoundingInfo(!0, null);
  }
  static CreateGeometryForMesh(e) {
    const t = new at(at.RandomId(), e.getScene());
    return t.applyToMesh(e), t;
  }
  get meshes() {
    return this._meshes;
  }
  get extend() {
    return this._extend;
  }
  getScene() {
    return this._scene;
  }
  getEngine() {
    return this._engine;
  }
  isReady() {
    return this.delayLoadState === 1 || this.delayLoadState === 0;
  }
  get doNotSerialize() {
    for (let e = 0; e < this._meshes.length; e++)
      if (!this._meshes[e].doNotSerialize)
        return !1;
    return !0;
  }
  _rebuild() {
    this._vertexArrayObjects && (this._vertexArrayObjects = {}), this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable));
    for (const e in this._vertexBuffers)
      this._vertexBuffers[e]._rebuild();
  }
  setAllVerticesData(e, t) {
    e.applyToGeometry(this, t), this._notifyUpdate();
  }
  setVerticesData(e, t, i = !1, s) {
    i && Array.isArray(t) && (t = new Float32Array(t));
    const r = new g(this._engine, t, e, i, this._meshes.length === 0, s);
    this.setVerticesBuffer(r);
  }
  removeVerticesData(e) {
    this._vertexBuffers[e] && (this._vertexBuffers[e].dispose(), delete this._vertexBuffers[e]), this._vertexArrayObjects && this._disposeVertexArrayObjects();
  }
  setVerticesBuffer(e, t = null, i = !0) {
    const s = e.getKind();
    this._vertexBuffers[s] && i && this._vertexBuffers[s].dispose(), e._buffer && e._buffer._increaseReferences(), this._vertexBuffers[s] = e;
    const r = this._meshes, n = r.length;
    if (s === g.PositionKind) {
      const a = e.getData();
      t != null ? this._totalVertices = t : a != null && (this._totalVertices = a.length / (e.type === g.BYTE ? e.byteStride : e.byteStride / 4)), this._updateExtend(a), this._resetPointsArrayCache();
      for (let o = 0; o < n; o++) {
        const h = r[o];
        h.buildBoundingInfo(this._extend.minimum, this._extend.maximum), h._createGlobalSubMesh(h.isUnIndexed), h.computeWorldMatrix(!0), h.synchronizeInstances();
      }
    }
    this._notifyUpdate(s);
  }
  updateVerticesDataDirectly(e, t, i, s = !1) {
    const r = this.getVertexBuffer(e);
    !r || (r.updateDirectly(t, i, s), this._notifyUpdate(e));
  }
  updateVerticesData(e, t, i = !1) {
    const s = this.getVertexBuffer(e);
    !s || (s.update(t), e === g.PositionKind && this._updateBoundingInfo(i, t), this._notifyUpdate(e));
  }
  _updateBoundingInfo(e, t) {
    if (e && this._updateExtend(t), this._resetPointsArrayCache(), e) {
      const i = this._meshes;
      for (const s of i) {
        s.hasBoundingInfo ? s.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum) : s.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
        const r = s.subMeshes;
        for (const n of r)
          n.refreshBoundingInfo();
      }
    }
  }
  _bind(e, t, i, s) {
    if (!e)
      return;
    t === void 0 && (t = this._indexBuffer);
    const r = this.getVertexBuffers();
    if (!r)
      return;
    if (t != this._indexBuffer || !this._vertexArrayObjects && !s) {
      this._engine.bindBuffers(r, t, e, i);
      return;
    }
    const n = s || this._vertexArrayObjects;
    n[e.key] || (n[e.key] = this._engine.recordVertexArrayObject(r, t, e, i)), this._engine.bindVertexArrayObject(n[e.key], t);
  }
  getTotalVertices() {
    return this.isReady() ? this._totalVertices : 0;
  }
  getVerticesData(e, t, i) {
    const s = this.getVertexBuffer(e);
    return s ? s.getFloatData(this._totalVertices, i || t && this._meshes.length !== 1) : null;
  }
  isVertexBufferUpdatable(e) {
    const t = this._vertexBuffers[e];
    return t ? t.isUpdatable() : !1;
  }
  getVertexBuffer(e) {
    return this.isReady() ? this._vertexBuffers[e] : null;
  }
  getVertexBuffers() {
    return this.isReady() ? this._vertexBuffers : null;
  }
  isVerticesDataPresent(e) {
    return this._vertexBuffers ? this._vertexBuffers[e] !== void 0 : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }
  getVerticesDataKinds() {
    const e = [];
    let t;
    if (!this._vertexBuffers && this._delayInfo)
      for (t in this._delayInfo)
        e.push(t);
    else
      for (t in this._vertexBuffers)
        e.push(t);
    return e;
  }
  updateIndices(e, t, i = !1) {
    if (!!this._indexBuffer)
      if (!this._indexBufferIsUpdatable)
        this.setIndices(e, null, !0);
      else {
        const s = e.length !== this._indices.length;
        if (i || (this._indices = e.slice()), this._engine.updateDynamicIndexBuffer(this._indexBuffer, e, t), s)
          for (const r of this._meshes)
            r._createGlobalSubMesh(!0);
      }
  }
  setIndices(e, t = null, i = !1) {
    this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indices = e, this._indexBufferIsUpdatable = i, this._meshes.length !== 0 && this._indices && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, i)), t != null && (this._totalVertices = t);
    for (const s of this._meshes)
      s._createGlobalSubMesh(!0), s.synchronizeInstances();
    this._notifyUpdate();
  }
  getTotalIndices() {
    return this.isReady() ? this._indices.length : 0;
  }
  getIndices(e, t) {
    if (!this.isReady())
      return null;
    const i = this._indices;
    return !t && (!e || this._meshes.length === 1) ? i : i.slice();
  }
  getIndexBuffer() {
    return this.isReady() ? this._indexBuffer : null;
  }
  _releaseVertexArrayObject(e = null) {
    !e || !this._vertexArrayObjects || this._vertexArrayObjects[e.key] && (this._engine.releaseVertexArrayObject(this._vertexArrayObjects[e.key]), delete this._vertexArrayObjects[e.key]);
  }
  releaseForMesh(e, t) {
    const i = this._meshes, s = i.indexOf(e);
    s !== -1 && (i.splice(s, 1), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject(), e._geometry = null, i.length === 0 && t && this.dispose());
  }
  applyToMesh(e) {
    if (e._geometry === this)
      return;
    const t = e._geometry;
    t && t.releaseForMesh(e), this._vertexArrayObjects && e._invalidateInstanceVertexArrayObject();
    const i = this._meshes;
    e._geometry = this, e._internalAbstractMeshDataInfo._positions = null, this._scene.pushGeometry(this), i.push(e), this.isReady() ? this._applyToMesh(e) : this._boundingInfo && e.setBoundingInfo(this._boundingInfo);
  }
  _updateExtend(e = null) {
    if (this.useBoundingInfoFromGeometry && this._boundingInfo)
      this._extend = {
        minimum: this._boundingInfo.minimum.clone(),
        maximum: this._boundingInfo.maximum.clone()
      };
    else {
      if (!e && (e = this.getVerticesData(g.PositionKind), !e))
        return;
      this._extend = Nr(e, 0, this._totalVertices, this.boundingBias, 3);
    }
  }
  _applyToMesh(e) {
    const t = this._meshes.length;
    for (const i in this._vertexBuffers)
      t === 1 && this._vertexBuffers[i].create(), i === g.PositionKind && (this._extend || this._updateExtend(), e.buildBoundingInfo(this._extend.minimum, this._extend.maximum), e._createGlobalSubMesh(e.isUnIndexed), e._updateBoundingInfo());
    t === 1 && this._indices && this._indices.length > 0 && (this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable)), e._syncGeometryWithMorphTargetManager(), e.synchronizeInstances();
  }
  _notifyUpdate(e) {
    this.onGeometryUpdated && this.onGeometryUpdated(this, e), this._vertexArrayObjects && this._disposeVertexArrayObjects();
    for (const t of this._meshes)
      t._markSubMeshesAsAttributesDirty();
  }
  load(e, t) {
    if (this.delayLoadState !== 2) {
      if (this.isReady()) {
        t && t();
        return;
      }
      this.delayLoadState = 2, this._queueLoad(e, t);
    }
  }
  _queueLoad(e, t) {
    !this.delayLoadingFile || (e.addPendingData(this), e._loadFile(this.delayLoadingFile, (i) => {
      if (!this._delayLoadingFunction)
        return;
      this._delayLoadingFunction(JSON.parse(i), this), this.delayLoadState = 1, this._delayInfo = [], e.removePendingData(this);
      const s = this._meshes, r = s.length;
      for (let n = 0; n < r; n++)
        this._applyToMesh(s[n]);
      t && t();
    }, void 0, !0));
  }
  toLeftHanded() {
    const e = this.getIndices(!1);
    if (e != null && e.length > 0) {
      for (let s = 0; s < e.length; s += 3) {
        const r = e[s + 0];
        e[s + 0] = e[s + 2], e[s + 2] = r;
      }
      this.setIndices(e);
    }
    const t = this.getVerticesData(g.PositionKind, !1);
    if (t != null && t.length > 0) {
      for (let s = 0; s < t.length; s += 3)
        t[s + 2] = -t[s + 2];
      this.setVerticesData(g.PositionKind, t, !1);
    }
    const i = this.getVerticesData(g.NormalKind, !1);
    if (i != null && i.length > 0) {
      for (let s = 0; s < i.length; s += 3)
        i[s + 2] = -i[s + 2];
      this.setVerticesData(g.NormalKind, i, !1);
    }
  }
  _resetPointsArrayCache() {
    this._positions = null;
  }
  _generatePointsArray() {
    if (this._positions)
      return !0;
    const e = this.getVerticesData(g.PositionKind);
    if (!e || e.length === 0)
      return !1;
    for (let t = this._positionsCache.length * 3, i = this._positionsCache.length; t < e.length; t += 3, ++i)
      this._positionsCache[i] = p.FromArray(e, t);
    for (let t = 0, i = 0; t < e.length; t += 3, ++i)
      this._positionsCache[i].set(e[0 + t], e[1 + t], e[2 + t]);
    return this._positionsCache.length = e.length / 3, this._positions = this._positionsCache, !0;
  }
  isDisposed() {
    return this._isDisposed;
  }
  _disposeVertexArrayObjects() {
    if (this._vertexArrayObjects) {
      for (const i in this._vertexArrayObjects)
        this._engine.releaseVertexArrayObject(this._vertexArrayObjects[i]);
      this._vertexArrayObjects = {};
      const e = this._meshes, t = e.length;
      for (let i = 0; i < t; i++)
        e[i]._invalidateInstanceVertexArrayObject();
    }
  }
  dispose() {
    const e = this._meshes, t = e.length;
    let i;
    for (i = 0; i < t; i++)
      this.releaseForMesh(e[i]);
    this._meshes.length = 0, this._disposeVertexArrayObjects();
    for (const s in this._vertexBuffers)
      this._vertexBuffers[s].dispose();
    if (this._vertexBuffers = {}, this._totalVertices = 0, this._indexBuffer && this._engine._releaseBuffer(this._indexBuffer), this._indexBuffer = null, this._indices = [], this.delayLoadState = 0, this.delayLoadingFile = null, this._delayLoadingFunction = null, this._delayInfo = [], this._boundingInfo = null, this._scene.removeGeometry(this), this._parentContainer) {
      const s = this._parentContainer.geometries.indexOf(this);
      s > -1 && this._parentContainer.geometries.splice(s, 1), this._parentContainer = null;
    }
    this._isDisposed = !0;
  }
  copy(e) {
    const t = new J();
    t.indices = [];
    const i = this.getIndices();
    if (i)
      for (let o = 0; o < i.length; o++)
        t.indices.push(i[o]);
    let s = !1, r = !1, n;
    for (n in this._vertexBuffers) {
      const o = this.getVerticesData(n);
      if (o && (o instanceof Float32Array ? t.set(new Float32Array(o), n) : t.set(o.slice(0), n), !r)) {
        const h = this.getVertexBuffer(n);
        h && (s = h.isUpdatable(), r = !s);
      }
    }
    const a = new at(e, this._scene, t, s);
    a.delayLoadState = this.delayLoadState, a.delayLoadingFile = this.delayLoadingFile, a._delayLoadingFunction = this._delayLoadingFunction;
    for (n in this._delayInfo)
      a._delayInfo = a._delayInfo || [], a._delayInfo.push(n);
    return a._boundingInfo = new ft(this._extend.minimum, this._extend.maximum), a;
  }
  serialize() {
    const e = {};
    return e.id = this.id, e.uniqueId = this.uniqueId, e.updatable = this._updatable, pe && pe.HasTags(this) && (e.tags = pe.GetTags(this)), e;
  }
  _toNumberArray(e) {
    return Array.isArray(e) ? e : Array.prototype.slice.call(e);
  }
  clearCachedData() {
    this._indices = [], this._resetPointsArrayCache();
    for (const e in this._vertexBuffers)
      !Object.prototype.hasOwnProperty.call(this._vertexBuffers, e) || (this._vertexBuffers[e]._buffer._data = null);
  }
  serializeVerticeData() {
    const e = this.serialize();
    return this.isVerticesDataPresent(g.PositionKind) && (e.positions = this._toNumberArray(this.getVerticesData(g.PositionKind)), this.isVertexBufferUpdatable(g.PositionKind) && (e.positions._updatable = !0)), this.isVerticesDataPresent(g.NormalKind) && (e.normals = this._toNumberArray(this.getVerticesData(g.NormalKind)), this.isVertexBufferUpdatable(g.NormalKind) && (e.normals._updatable = !0)), this.isVerticesDataPresent(g.TangentKind) && (e.tangents = this._toNumberArray(this.getVerticesData(g.TangentKind)), this.isVertexBufferUpdatable(g.TangentKind) && (e.tangents._updatable = !0)), this.isVerticesDataPresent(g.UVKind) && (e.uvs = this._toNumberArray(this.getVerticesData(g.UVKind)), this.isVertexBufferUpdatable(g.UVKind) && (e.uvs._updatable = !0)), this.isVerticesDataPresent(g.UV2Kind) && (e.uv2s = this._toNumberArray(this.getVerticesData(g.UV2Kind)), this.isVertexBufferUpdatable(g.UV2Kind) && (e.uv2s._updatable = !0)), this.isVerticesDataPresent(g.UV3Kind) && (e.uv3s = this._toNumberArray(this.getVerticesData(g.UV3Kind)), this.isVertexBufferUpdatable(g.UV3Kind) && (e.uv3s._updatable = !0)), this.isVerticesDataPresent(g.UV4Kind) && (e.uv4s = this._toNumberArray(this.getVerticesData(g.UV4Kind)), this.isVertexBufferUpdatable(g.UV4Kind) && (e.uv4s._updatable = !0)), this.isVerticesDataPresent(g.UV5Kind) && (e.uv5s = this._toNumberArray(this.getVerticesData(g.UV5Kind)), this.isVertexBufferUpdatable(g.UV5Kind) && (e.uv5s._updatable = !0)), this.isVerticesDataPresent(g.UV6Kind) && (e.uv6s = this._toNumberArray(this.getVerticesData(g.UV6Kind)), this.isVertexBufferUpdatable(g.UV6Kind) && (e.uv6s._updatable = !0)), this.isVerticesDataPresent(g.ColorKind) && (e.colors = this._toNumberArray(this.getVerticesData(g.ColorKind)), this.isVertexBufferUpdatable(g.ColorKind) && (e.colors._updatable = !0)), this.isVerticesDataPresent(g.MatricesIndicesKind) && (e.matricesIndices = this._toNumberArray(this.getVerticesData(g.MatricesIndicesKind)), e.matricesIndices._isExpanded = !0, this.isVertexBufferUpdatable(g.MatricesIndicesKind) && (e.matricesIndices._updatable = !0)), this.isVerticesDataPresent(g.MatricesWeightsKind) && (e.matricesWeights = this._toNumberArray(this.getVerticesData(g.MatricesWeightsKind)), this.isVertexBufferUpdatable(g.MatricesWeightsKind) && (e.matricesWeights._updatable = !0)), e.indices = this._toNumberArray(this.getIndices()), e;
  }
  static ExtractFromMesh(e, t) {
    const i = e._geometry;
    return i ? i.copy(t) : null;
  }
  static RandomId() {
    return X.RandomId();
  }
  static _GetGeometryByLoadedUniqueId(e, t) {
    for (let i = 0; i < t.geometries.length; i++)
      if (t.geometries[i]._loadedUniqueId === e)
        return t.geometries[i];
    return null;
  }
  static _ImportGeometry(e, t) {
    const i = t.getScene(), s = e.geometryUniqueId, r = e.geometryId;
    if (s || r) {
      const n = s ? this._GetGeometryByLoadedUniqueId(s, i) : i.getGeometryById(r);
      n && n.applyToMesh(t);
    } else if (e instanceof ArrayBuffer) {
      const n = t._binaryInfo;
      if (n.positionsAttrDesc && n.positionsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.positionsAttrDesc.offset, n.positionsAttrDesc.count);
        t.setVerticesData(g.PositionKind, a, !1);
      }
      if (n.normalsAttrDesc && n.normalsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.normalsAttrDesc.offset, n.normalsAttrDesc.count);
        t.setVerticesData(g.NormalKind, a, !1);
      }
      if (n.tangetsAttrDesc && n.tangetsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.tangetsAttrDesc.offset, n.tangetsAttrDesc.count);
        t.setVerticesData(g.TangentKind, a, !1);
      }
      if (n.uvsAttrDesc && n.uvsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvsAttrDesc.offset, n.uvsAttrDesc.count);
        if (ut.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(g.UVKind, a, !1);
      }
      if (n.uvs2AttrDesc && n.uvs2AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs2AttrDesc.offset, n.uvs2AttrDesc.count);
        if (ut.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(g.UV2Kind, a, !1);
      }
      if (n.uvs3AttrDesc && n.uvs3AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs3AttrDesc.offset, n.uvs3AttrDesc.count);
        if (ut.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(g.UV3Kind, a, !1);
      }
      if (n.uvs4AttrDesc && n.uvs4AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs4AttrDesc.offset, n.uvs4AttrDesc.count);
        if (ut.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(g.UV4Kind, a, !1);
      }
      if (n.uvs5AttrDesc && n.uvs5AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs5AttrDesc.offset, n.uvs5AttrDesc.count);
        if (ut.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(g.UV5Kind, a, !1);
      }
      if (n.uvs6AttrDesc && n.uvs6AttrDesc.count > 0) {
        const a = new Float32Array(e, n.uvs6AttrDesc.offset, n.uvs6AttrDesc.count);
        if (ut.UseOpenGLOrientationForUV)
          for (let o = 1; o < a.length; o += 2)
            a[o] = 1 - a[o];
        t.setVerticesData(g.UV6Kind, a, !1);
      }
      if (n.colorsAttrDesc && n.colorsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.colorsAttrDesc.offset, n.colorsAttrDesc.count);
        t.setVerticesData(g.ColorKind, a, !1, n.colorsAttrDesc.stride);
      }
      if (n.matricesIndicesAttrDesc && n.matricesIndicesAttrDesc.count > 0) {
        const a = new Int32Array(e, n.matricesIndicesAttrDesc.offset, n.matricesIndicesAttrDesc.count), o = [];
        for (let h = 0; h < a.length; h++) {
          const l = a[h];
          o.push(l & 255), o.push((l & 65280) >> 8), o.push((l & 16711680) >> 16), o.push(l >> 24 & 255);
        }
        t.setVerticesData(g.MatricesIndicesKind, o, !1);
      }
      if (n.matricesIndicesExtraAttrDesc && n.matricesIndicesExtraAttrDesc.count > 0) {
        const a = new Int32Array(e, n.matricesIndicesExtraAttrDesc.offset, n.matricesIndicesExtraAttrDesc.count), o = [];
        for (let h = 0; h < a.length; h++) {
          const l = a[h];
          o.push(l & 255), o.push((l & 65280) >> 8), o.push((l & 16711680) >> 16), o.push(l >> 24 & 255);
        }
        t.setVerticesData(g.MatricesIndicesExtraKind, o, !1);
      }
      if (n.matricesWeightsAttrDesc && n.matricesWeightsAttrDesc.count > 0) {
        const a = new Float32Array(e, n.matricesWeightsAttrDesc.offset, n.matricesWeightsAttrDesc.count);
        t.setVerticesData(g.MatricesWeightsKind, a, !1);
      }
      if (n.indicesAttrDesc && n.indicesAttrDesc.count > 0) {
        const a = new Int32Array(e, n.indicesAttrDesc.offset, n.indicesAttrDesc.count);
        t.setIndices(a, null);
      }
      if (n.subMeshesAttrDesc && n.subMeshesAttrDesc.count > 0) {
        const a = new Int32Array(e, n.subMeshesAttrDesc.offset, n.subMeshesAttrDesc.count * 5);
        t.subMeshes = [];
        for (let o = 0; o < n.subMeshesAttrDesc.count; o++) {
          const h = a[o * 5 + 0], l = a[o * 5 + 1], u = a[o * 5 + 2], d = a[o * 5 + 3], f = a[o * 5 + 4];
          Et.AddToMesh(h, l, u, d, f, t);
        }
      }
    } else if (e.positions && e.normals && e.indices) {
      if (t.setVerticesData(g.PositionKind, e.positions, e.positions._updatable), t.setVerticesData(g.NormalKind, e.normals, e.normals._updatable), e.tangents && t.setVerticesData(g.TangentKind, e.tangents, e.tangents._updatable), e.uvs && t.setVerticesData(g.UVKind, e.uvs, e.uvs._updatable), e.uvs2 && t.setVerticesData(g.UV2Kind, e.uvs2, e.uvs2._updatable), e.uvs3 && t.setVerticesData(g.UV3Kind, e.uvs3, e.uvs3._updatable), e.uvs4 && t.setVerticesData(g.UV4Kind, e.uvs4, e.uvs4._updatable), e.uvs5 && t.setVerticesData(g.UV5Kind, e.uvs5, e.uvs5._updatable), e.uvs6 && t.setVerticesData(g.UV6Kind, e.uvs6, e.uvs6._updatable), e.colors && t.setVerticesData(g.ColorKind, ge.CheckColors4(e.colors, e.positions.length / 3), e.colors._updatable), e.matricesIndices)
        if (e.matricesIndices._isExpanded)
          delete e.matricesIndices._isExpanded, t.setVerticesData(g.MatricesIndicesKind, e.matricesIndices, e.matricesIndices._updatable);
        else {
          const n = [];
          for (let a = 0; a < e.matricesIndices.length; a++) {
            const o = e.matricesIndices[a];
            n.push(o & 255), n.push((o & 65280) >> 8), n.push((o & 16711680) >> 16), n.push(o >> 24 & 255);
          }
          t.setVerticesData(g.MatricesIndicesKind, n, e.matricesIndices._updatable);
        }
      if (e.matricesIndicesExtra)
        if (e.matricesIndicesExtra._isExpanded)
          delete e.matricesIndices._isExpanded, t.setVerticesData(g.MatricesIndicesExtraKind, e.matricesIndicesExtra, e.matricesIndicesExtra._updatable);
        else {
          const n = [];
          for (let a = 0; a < e.matricesIndicesExtra.length; a++) {
            const o = e.matricesIndicesExtra[a];
            n.push(o & 255), n.push((o & 65280) >> 8), n.push((o & 16711680) >> 16), n.push(o >> 24 & 255);
          }
          t.setVerticesData(g.MatricesIndicesExtraKind, n, e.matricesIndicesExtra._updatable);
        }
      e.matricesWeights && (at._CleanMatricesWeights(e, t), t.setVerticesData(g.MatricesWeightsKind, e.matricesWeights, e.matricesWeights._updatable)), e.matricesWeightsExtra && t.setVerticesData(g.MatricesWeightsExtraKind, e.matricesWeightsExtra, e.matricesWeights._updatable), t.setIndices(e.indices, null);
    }
    if (e.subMeshes) {
      t.subMeshes = [];
      for (let n = 0; n < e.subMeshes.length; n++) {
        const a = e.subMeshes[n];
        Et.AddToMesh(a.materialIndex, a.verticesStart, a.verticesCount, a.indexStart, a.indexCount, t);
      }
    }
    t._shouldGenerateFlatShading && (t.convertToFlatShadedMesh(), t._shouldGenerateFlatShading = !1), t.computeWorldMatrix(!0), i.onMeshImportedObservable.notifyObservers(t);
  }
  static _CleanMatricesWeights(e, t) {
    if (!we.CleanBoneMatrixWeights)
      return;
    let s = 0;
    if (e.skeletonId > -1) {
      const u = t.getScene().getLastSkeletonById(e.skeletonId);
      if (!u)
        return;
      s = u.bones.length;
    } else
      return;
    const r = t.getVerticesData(g.MatricesIndicesKind), n = t.getVerticesData(g.MatricesIndicesExtraKind), a = e.matricesWeights, o = e.matricesWeightsExtra, h = e.numBoneInfluencer, l = a.length;
    for (let u = 0; u < l; u += 4) {
      let d = 0, f = -1;
      for (let _ = 0; _ < 4; _++) {
        const E = a[u + _];
        d += E, E < 1e-3 && f < 0 && (f = _);
      }
      if (o)
        for (let _ = 0; _ < 4; _++) {
          const E = o[u + _];
          d += E, E < 1e-3 && f < 0 && (f = _ + 4);
        }
      if ((f < 0 || f > h - 1) && (f = h - 1), d > 1e-3) {
        const _ = 1 / d;
        for (let E = 0; E < 4; E++)
          a[u + E] *= _;
        if (o)
          for (let E = 0; E < 4; E++)
            o[u + E] *= _;
      } else
        f >= 4 ? (o[u + f - 4] = 1 - d, n[u + f - 4] = s) : (a[u + f] = 1 - d, r[u + f] = s);
    }
    t.setVerticesData(g.MatricesIndicesKind, r), e.matricesWeightsExtra && t.setVerticesData(g.MatricesIndicesExtraKind, n);
  }
  static Parse(e, t, i) {
    const s = new at(e.id, t, void 0, e.updatable);
    return s._loadedUniqueId = e.uniqueId, pe && pe.AddTagsTo(s, e.tags), e.delayLoadingFile ? (s.delayLoadState = 4, s.delayLoadingFile = i + e.delayLoadingFile, s._boundingInfo = new ft(p.FromArray(e.boundingBoxMinimum), p.FromArray(e.boundingBoxMaximum)), s._delayInfo = [], e.hasUVs && s._delayInfo.push(g.UVKind), e.hasUVs2 && s._delayInfo.push(g.UV2Kind), e.hasUVs3 && s._delayInfo.push(g.UV3Kind), e.hasUVs4 && s._delayInfo.push(g.UV4Kind), e.hasUVs5 && s._delayInfo.push(g.UV5Kind), e.hasUVs6 && s._delayInfo.push(g.UV6Kind), e.hasColors && s._delayInfo.push(g.ColorKind), e.hasMatricesIndices && s._delayInfo.push(g.MatricesIndicesKind), e.hasMatricesWeights && s._delayInfo.push(g.MatricesWeightsKind), s._delayLoadingFunction = J.ImportVertexData) : J.ImportVertexData(e, s), t.pushGeometry(s, !0), s;
  }
}
var Lt;
(function(c) {
  c[c.LOCAL = 0] = "LOCAL", c[c.WORLD = 1] = "WORLD", c[c.BONE = 2] = "BONE";
})(Lt || (Lt = {}));
class ui {
}
ui.X = new p(1, 0, 0);
ui.Y = new p(0, 1, 0);
ui.Z = new p(0, 0, 1);
var dr;
(function(c) {
  c[c.X = 0] = "X", c[c.Y = 1] = "Y", c[c.Z = 2] = "Z";
})(dr || (dr = {}));
class $ extends Xe {
  constructor(e, t = null, i = !0) {
    super(e, t), this._forward = new p(0, 0, 1), this._up = new p(0, 1, 0), this._right = new p(1, 0, 0), this._position = p.Zero(), this._rotation = p.Zero(), this._rotationQuaternion = null, this._scaling = p.One(), this._transformToBoneReferal = null, this._isAbsoluteSynced = !1, this._billboardMode = $.BILLBOARDMODE_NONE, this._preserveParentRotationForBillboard = !1, this.scalingDeterminant = 1, this._infiniteDistance = !1, this.ignoreNonUniformScaling = !1, this.reIntegrateRotationIntoRotationQuaternion = !1, this._poseMatrix = null, this._localMatrix = x.Zero(), this._usePivotMatrix = !1, this._absolutePosition = p.Zero(), this._absoluteScaling = p.Zero(), this._absoluteRotationQuaternion = Y.Identity(), this._pivotMatrix = x.Identity(), this._postMultiplyPivotMatrix = !1, this._isWorldMatrixFrozen = !1, this._indexInSceneTransformNodesArray = -1, this.onAfterWorldMatrixUpdateObservable = new w(), this._nonUniformScaling = !1, i && this.getScene().addTransformNode(this);
  }
  get billboardMode() {
    return this._billboardMode;
  }
  set billboardMode(e) {
    this._billboardMode !== e && (this._billboardMode = e);
  }
  get preserveParentRotationForBillboard() {
    return this._preserveParentRotationForBillboard;
  }
  set preserveParentRotationForBillboard(e) {
    e !== this._preserveParentRotationForBillboard && (this._preserveParentRotationForBillboard = e);
  }
  get infiniteDistance() {
    return this._infiniteDistance;
  }
  set infiniteDistance(e) {
    this._infiniteDistance !== e && (this._infiniteDistance = e);
  }
  getClassName() {
    return "TransformNode";
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._position = e, this._isDirty = !0;
  }
  isUsingPivotMatrix() {
    return this._usePivotMatrix;
  }
  get rotation() {
    return this._rotation;
  }
  set rotation(e) {
    this._rotation = e, this._rotationQuaternion = null, this._isDirty = !0;
  }
  get scaling() {
    return this._scaling;
  }
  set scaling(e) {
    this._scaling = e, this._isDirty = !0;
  }
  get rotationQuaternion() {
    return this._rotationQuaternion;
  }
  set rotationQuaternion(e) {
    this._rotationQuaternion = e, e && this._rotation.setAll(0), this._isDirty = !0;
  }
  get forward() {
    return p.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward), this._forward.normalize();
  }
  get up() {
    return p.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up), this._up.normalize();
  }
  get right() {
    return p.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right), this._right.normalize();
  }
  updatePoseMatrix(e) {
    return this._poseMatrix ? (this._poseMatrix.copyFrom(e), this) : (this._poseMatrix = e.clone(), this);
  }
  getPoseMatrix() {
    return this._poseMatrix || (this._poseMatrix = x.Identity()), this._poseMatrix;
  }
  _isSynchronized() {
    const e = this._cache;
    return !(this._billboardMode !== e.billboardMode || this._billboardMode !== $.BILLBOARDMODE_NONE || e.pivotMatrixUpdated || this._infiniteDistance || this._position._isDirty || this._scaling._isDirty || this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty);
  }
  _initCache() {
    super._initCache();
    const e = this._cache;
    e.localMatrixUpdated = !1, e.billboardMode = -1, e.infiniteDistance = !1;
  }
  get absolutePosition() {
    return this.getAbsolutePosition();
  }
  get absoluteScaling() {
    return this._syncAbsoluteScalingAndRotation(), this._absoluteScaling;
  }
  get absoluteRotationQuaternion() {
    return this._syncAbsoluteScalingAndRotation(), this._absoluteRotationQuaternion;
  }
  setPreTransformMatrix(e) {
    return this.setPivotMatrix(e, !1);
  }
  setPivotMatrix(e, t = !0) {
    return this._pivotMatrix.copyFrom(e), this._usePivotMatrix = !this._pivotMatrix.isIdentity(), this._cache.pivotMatrixUpdated = !0, this._postMultiplyPivotMatrix = t, this._postMultiplyPivotMatrix && (this._pivotMatrixInverse ? this._pivotMatrix.invertToRef(this._pivotMatrixInverse) : this._pivotMatrixInverse = x.Invert(this._pivotMatrix)), this;
  }
  getPivotMatrix() {
    return this._pivotMatrix;
  }
  instantiateHierarchy(e = null, t, i) {
    const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0);
    s && i && i(this, s);
    for (const r of this.getChildTransformNodes(!0))
      r.instantiateHierarchy(s, t, i);
    return s;
  }
  freezeWorldMatrix(e = null, t = !1) {
    return e ? t ? (this._rotation.setAll(0), this._rotationQuaternion = this._rotationQuaternion || Y.Identity(), e.decompose(this._scaling, this._rotationQuaternion, this._position), this.computeWorldMatrix(!0)) : (this._worldMatrix = e, this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._afterComputeWorldMatrix()) : (this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0)), this._isDirty = !1, this._isWorldMatrixFrozen = !0, this;
  }
  unfreezeWorldMatrix() {
    return this._isWorldMatrixFrozen = !1, this.computeWorldMatrix(!0), this;
  }
  get isWorldMatrixFrozen() {
    return this._isWorldMatrixFrozen;
  }
  getAbsolutePosition() {
    return this.computeWorldMatrix(), this._absolutePosition;
  }
  setAbsolutePosition(e) {
    if (!e)
      return this;
    let t, i, s;
    if (e.x === void 0) {
      if (arguments.length < 3)
        return this;
      t = arguments[0], i = arguments[1], s = arguments[2];
    } else
      t = e.x, i = e.y, s = e.z;
    if (this.parent) {
      const r = D.Matrix[0];
      this.parent.getWorldMatrix().invertToRef(r), p.TransformCoordinatesFromFloatsToRef(t, i, s, r, this.position);
    } else
      this.position.x = t, this.position.y = i, this.position.z = s;
    return this._absolutePosition.copyFrom(e), this;
  }
  setPositionWithLocalVector(e) {
    return this.computeWorldMatrix(), this.position = p.TransformNormal(e, this._localMatrix), this;
  }
  getPositionExpressedInLocalSpace() {
    this.computeWorldMatrix();
    const e = D.Matrix[0];
    return this._localMatrix.invertToRef(e), p.TransformNormal(this.position, e);
  }
  locallyTranslate(e) {
    return this.computeWorldMatrix(!0), this.position = p.TransformCoordinates(e, this._localMatrix), this;
  }
  lookAt(e, t = 0, i = 0, s = 0, r = Lt.LOCAL) {
    const n = $._LookAtVectorCache, a = r === Lt.LOCAL ? this.position : this.getAbsolutePosition();
    if (e.subtractToRef(a, n), this.setDirection(n, t, i, s), r === Lt.WORLD && this.parent)
      if (this.rotationQuaternion) {
        const o = D.Matrix[0];
        this.rotationQuaternion.toRotationMatrix(o);
        const h = D.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(h), h.invert(), o.multiplyToRef(h, o), this.rotationQuaternion.fromRotationMatrix(o);
      } else {
        const o = D.Quaternion[0];
        Y.FromEulerVectorToRef(this.rotation, o);
        const h = D.Matrix[0];
        o.toRotationMatrix(h);
        const l = D.Matrix[1];
        this.parent.getWorldMatrix().getRotationMatrixToRef(l), l.invert(), h.multiplyToRef(l, h), o.fromRotationMatrix(h), o.toEulerAnglesToRef(this.rotation);
      }
    return this;
  }
  getDirection(e) {
    const t = p.Zero();
    return this.getDirectionToRef(e, t), t;
  }
  getDirectionToRef(e, t) {
    return p.TransformNormalToRef(e, this.getWorldMatrix(), t), this;
  }
  setDirection(e, t = 0, i = 0, s = 0) {
    const r = -Math.atan2(e.z, e.x) + Math.PI / 2, n = Math.sqrt(e.x * e.x + e.z * e.z), a = -Math.atan2(e.y, n);
    return this.rotationQuaternion ? Y.RotationYawPitchRollToRef(r + t, a + i, s, this.rotationQuaternion) : (this.rotation.x = a + i, this.rotation.y = r + t, this.rotation.z = s), this;
  }
  setPivotPoint(e, t = Lt.LOCAL) {
    this.getScene().getRenderId() == 0 && this.computeWorldMatrix(!0);
    const i = this.getWorldMatrix();
    if (t == Lt.WORLD) {
      const s = D.Matrix[0];
      i.invertToRef(s), e = p.TransformCoordinates(e, s);
    }
    return this.setPivotMatrix(x.Translation(-e.x, -e.y, -e.z), !0);
  }
  getPivotPoint() {
    const e = p.Zero();
    return this.getPivotPointToRef(e), e;
  }
  getPivotPointToRef(e) {
    return e.x = -this._pivotMatrix.m[12], e.y = -this._pivotMatrix.m[13], e.z = -this._pivotMatrix.m[14], this;
  }
  getAbsolutePivotPoint() {
    const e = p.Zero();
    return this.getAbsolutePivotPointToRef(e), e;
  }
  getAbsolutePivotPointToRef(e) {
    return this.getPivotPointToRef(e), p.TransformCoordinatesToRef(e, this.getWorldMatrix(), e), this;
  }
  markAsDirty(e) {
    if (this._isDirty)
      return this;
    if (this._children)
      for (const t of this._children)
        t.markAsDirty(e);
    return super.markAsDirty(e);
  }
  setParent(e, t = !1, i = !1) {
    if (!e && !this.parent)
      return this;
    const s = D.Quaternion[0], r = D.Vector3[0], n = D.Vector3[1], a = D.Matrix[1];
    x.IdentityToRef(a);
    const o = D.Matrix[0];
    this.computeWorldMatrix(!0);
    let h = this.rotationQuaternion;
    return h || (h = $._TmpRotation, Y.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, h)), x.ComposeToRef(this.scaling, h, this.position, o), this.parent && o.multiplyToRef(this.parent.computeWorldMatrix(!0), o), e && (e.computeWorldMatrix(!0).invertToRef(a), o.multiplyToRef(a, o)), o.decompose(n, s, r, t ? this : void 0), this.rotationQuaternion ? this.rotationQuaternion.copyFrom(s) : s.toEulerAnglesToRef(this.rotation), this.scaling.copyFrom(n), this.position.copyFrom(r), this.parent = e, i && this.setPivotMatrix(x.Identity()), this;
  }
  get nonUniformScaling() {
    return this._nonUniformScaling;
  }
  _updateNonUniformScalingState(e) {
    return this._nonUniformScaling === e ? !1 : (this._nonUniformScaling = e, !0);
  }
  attachToBone(e, t) {
    return this._currentParentWhenAttachingToBone = this.parent, this._transformToBoneReferal = t, this.parent = e, e.getSkeleton().prepare(), e.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this;
  }
  detachFromBone(e = !1) {
    return this.parent ? (this.parent.getWorldMatrix().determinant() < 0 && (this.scalingDeterminant *= -1), this._transformToBoneReferal = null, e ? this.parent = this._currentParentWhenAttachingToBone : this.parent = null, this) : (e && (this.parent = this._currentParentWhenAttachingToBone), this);
  }
  rotate(e, t, i) {
    e.normalize(), this.rotationQuaternion || (this.rotationQuaternion = this.rotation.toQuaternion(), this.rotation.setAll(0));
    let s;
    if (!i || i === Lt.LOCAL)
      s = Y.RotationAxisToRef(e, t, $._RotationAxisCache), this.rotationQuaternion.multiplyToRef(s, this.rotationQuaternion);
    else {
      if (this.parent) {
        const r = D.Matrix[0];
        this.parent.getWorldMatrix().invertToRef(r), e = p.TransformNormal(e, r);
      }
      s = Y.RotationAxisToRef(e, t, $._RotationAxisCache), s.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
    }
    return this;
  }
  rotateAround(e, t, i) {
    t.normalize(), this.rotationQuaternion || (this.rotationQuaternion = Y.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z), this.rotation.setAll(0));
    const s = D.Vector3[0], r = D.Vector3[1], n = D.Vector3[2], a = D.Quaternion[0], o = D.Matrix[0], h = D.Matrix[1], l = D.Matrix[2], u = D.Matrix[3];
    return e.subtractToRef(this.position, s), x.TranslationToRef(s.x, s.y, s.z, o), x.TranslationToRef(-s.x, -s.y, -s.z, h), x.RotationAxisToRef(t, i, l), h.multiplyToRef(l, u), u.multiplyToRef(o, u), u.decompose(r, a, n), this.position.addInPlace(n), a.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion), this;
  }
  translate(e, t, i) {
    const s = e.scale(t);
    if (!i || i === Lt.LOCAL) {
      const r = this.getPositionExpressedInLocalSpace().add(s);
      this.setPositionWithLocalVector(r);
    } else
      this.setAbsolutePosition(this.getAbsolutePosition().add(s));
    return this;
  }
  addRotation(e, t, i) {
    let s;
    this.rotationQuaternion ? s = this.rotationQuaternion : (s = D.Quaternion[1], Y.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, s));
    const r = D.Quaternion[0];
    return Y.RotationYawPitchRollToRef(t, e, i, r), s.multiplyInPlace(r), this.rotationQuaternion || s.toEulerAnglesToRef(this.rotation), this;
  }
  _getEffectiveParent() {
    return this.parent;
  }
  computeWorldMatrix(e) {
    if (this._isWorldMatrixFrozen && !this._isDirty)
      return this._worldMatrix;
    const t = this.getScene().getRenderId();
    if (!this._isDirty && !e && (this._currentRenderId === t || this.isSynchronized()))
      return this._currentRenderId = t, this._worldMatrix;
    const i = this.getScene().activeCamera, s = (this._billboardMode & $.BILLBOARDMODE_USE_POSITION) !== 0, r = this._billboardMode !== $.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
    this._updateCache();
    const n = this._cache;
    n.pivotMatrixUpdated = !1, n.billboardMode = this.billboardMode, n.infiniteDistance = this.infiniteDistance, n.parent = this._parentNode, this._currentRenderId = t, this._childUpdateId += 1, this._isDirty = !1, this._position._isDirty = !1, this._rotation._isDirty = !1, this._scaling._isDirty = !1;
    const a = this._getEffectiveParent(), o = $._TmpScaling;
    let h = this._position;
    if (this._infiniteDistance && !this.parent && i) {
      const u = i.getWorldMatrix(), d = new p(u.m[12], u.m[13], u.m[14]);
      h = $._TmpTranslation, h.copyFromFloats(this._position.x + d.x, this._position.y + d.y, this._position.z + d.z);
    }
    o.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
    let l;
    if (this._rotationQuaternion ? (this._rotationQuaternion._isDirty = !1, l = this._rotationQuaternion, this.reIntegrateRotationIntoRotationQuaternion && this.rotation.lengthSquared() && (this._rotationQuaternion.multiplyInPlace(Y.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z)), this._rotation.copyFromFloats(0, 0, 0))) : (l = $._TmpRotation, Y.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, l)), this._usePivotMatrix) {
      const u = D.Matrix[1];
      x.ScalingToRef(o.x, o.y, o.z, u);
      const d = D.Matrix[0];
      l.toRotationMatrix(d), this._pivotMatrix.multiplyToRef(u, D.Matrix[4]), D.Matrix[4].multiplyToRef(d, this._localMatrix), this._postMultiplyPivotMatrix && this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix), this._localMatrix.addTranslationFromFloats(h.x, h.y, h.z);
    } else
      x.ComposeToRef(o, l, h, this._localMatrix);
    if (a && a.getWorldMatrix) {
      if (e && a.computeWorldMatrix(e), r) {
        this._transformToBoneReferal ? a.getWorldMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), D.Matrix[7]) : D.Matrix[7].copyFrom(a.getWorldMatrix());
        const u = D.Vector3[5], d = D.Vector3[6], f = D.Quaternion[0];
        D.Matrix[7].decompose(d, f, u), x.ScalingToRef(d.x, d.y, d.z, D.Matrix[7]), D.Matrix[7].setTranslation(u), $.BillboardUseParentOrientation && (this._position.applyRotationQuaternionToRef(f, u), this._localMatrix.setTranslation(u)), this._localMatrix.multiplyToRef(D.Matrix[7], this._worldMatrix);
      } else
        this._transformToBoneReferal ? (this._localMatrix.multiplyToRef(a.getWorldMatrix(), D.Matrix[6]), D.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix)) : this._localMatrix.multiplyToRef(a.getWorldMatrix(), this._worldMatrix);
      this._markSyncedWithParent();
    } else
      this._worldMatrix.copyFrom(this._localMatrix);
    if (r && i && this.billboardMode && !s) {
      const u = D.Vector3[0];
      if (this._worldMatrix.getTranslationToRef(u), D.Matrix[1].copyFrom(i.getViewMatrix()), D.Matrix[1].setTranslationFromFloats(0, 0, 0), D.Matrix[1].invertToRef(D.Matrix[0]), (this.billboardMode & $.BILLBOARDMODE_ALL) !== $.BILLBOARDMODE_ALL) {
        D.Matrix[0].decompose(void 0, D.Quaternion[0], void 0);
        const d = D.Vector3[1];
        D.Quaternion[0].toEulerAnglesToRef(d), (this.billboardMode & $.BILLBOARDMODE_X) !== $.BILLBOARDMODE_X && (d.x = 0), (this.billboardMode & $.BILLBOARDMODE_Y) !== $.BILLBOARDMODE_Y && (d.y = 0), (this.billboardMode & $.BILLBOARDMODE_Z) !== $.BILLBOARDMODE_Z && (d.z = 0), x.RotationYawPitchRollToRef(d.y, d.x, d.z, D.Matrix[0]);
      }
      this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]);
    } else if (r && i && this.billboardMode && s) {
      const u = D.Vector3[0];
      this._worldMatrix.getTranslationToRef(u);
      const d = i.globalPosition;
      this._worldMatrix.invertToRef(D.Matrix[1]);
      const f = D.Vector3[1];
      p.TransformCoordinatesToRef(d, D.Matrix[1], f), f.normalize();
      const _ = -Math.atan2(f.z, f.x) + Math.PI / 2, E = Math.sqrt(f.x * f.x + f.z * f.z), m = -Math.atan2(f.y, E);
      if (Y.RotationYawPitchRollToRef(_, m, 0, D.Quaternion[0]), (this.billboardMode & $.BILLBOARDMODE_ALL) !== $.BILLBOARDMODE_ALL) {
        const v = D.Vector3[1];
        D.Quaternion[0].toEulerAnglesToRef(v), (this.billboardMode & $.BILLBOARDMODE_X) !== $.BILLBOARDMODE_X && (v.x = 0), (this.billboardMode & $.BILLBOARDMODE_Y) !== $.BILLBOARDMODE_Y && (v.y = 0), (this.billboardMode & $.BILLBOARDMODE_Z) !== $.BILLBOARDMODE_Z && (v.z = 0), x.RotationYawPitchRollToRef(v.y, v.x, v.z, D.Matrix[0]);
      } else
        x.FromQuaternionToRef(D.Quaternion[0], D.Matrix[0]);
      this._worldMatrix.setTranslationFromFloats(0, 0, 0), this._worldMatrix.multiplyToRef(D.Matrix[0], this._worldMatrix), this._worldMatrix.setTranslation(D.Vector3[0]);
    }
    return this.ignoreNonUniformScaling ? this._updateNonUniformScalingState(!1) : this._scaling.isNonUniformWithinEpsilon(1e-6) ? this._updateNonUniformScalingState(!0) : a && a._nonUniformScaling ? this._updateNonUniformScalingState(a._nonUniformScaling) : this._updateNonUniformScalingState(!1), this._afterComputeWorldMatrix(), this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]), this._isAbsoluteSynced = !1, this.onAfterWorldMatrixUpdateObservable.notifyObservers(this), this._poseMatrix || (this._poseMatrix = x.Invert(this._worldMatrix)), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix;
  }
  resetLocalMatrix(e = !0) {
    if (this.computeWorldMatrix(), e) {
      const t = this.getChildren();
      for (let i = 0; i < t.length; ++i) {
        const s = t[i];
        if (s) {
          s.computeWorldMatrix();
          const r = D.Matrix[0];
          s._localMatrix.multiplyToRef(this._localMatrix, r);
          const n = D.Quaternion[0];
          r.decompose(s.scaling, n, s.position), s.rotationQuaternion ? s.rotationQuaternion.copyFrom(n) : n.toEulerAnglesToRef(s.rotation);
        }
      }
    }
    this.scaling.copyFromFloats(1, 1, 1), this.position.copyFromFloats(0, 0, 0), this.rotation.copyFromFloats(0, 0, 0), this.rotationQuaternion && (this.rotationQuaternion = Y.Identity()), this._worldMatrix = x.Identity();
  }
  _afterComputeWorldMatrix() {
  }
  registerAfterWorldMatrixUpdate(e) {
    return this.onAfterWorldMatrixUpdateObservable.add(e), this;
  }
  unregisterAfterWorldMatrixUpdate(e) {
    return this.onAfterWorldMatrixUpdateObservable.removeCallback(e), this;
  }
  getPositionInCameraSpace(e = null) {
    return e || (e = this.getScene().activeCamera), p.TransformCoordinates(this.getAbsolutePosition(), e.getViewMatrix());
  }
  getDistanceToCamera(e = null) {
    return e || (e = this.getScene().activeCamera), this.getAbsolutePosition().subtract(e.globalPosition).length();
  }
  clone(e, t, i) {
    const s = ae.Clone(() => new $(e, this.getScene()), this);
    if (s.name = e, s.id = e, t && (s.parent = t), !i) {
      const r = this.getDescendants(!0);
      for (let n = 0; n < r.length; n++) {
        const a = r[n];
        a.clone && a.clone(e + "." + a.name, s);
      }
    }
    return s;
  }
  serialize(e) {
    const t = ae.Serialize(this, e);
    return t.type = this.getClassName(), t.uniqueId = this.uniqueId, this.parent && this.parent._serializeAsParent(t), t.localMatrix = this.getPivotMatrix().asArray(), t.isEnabled = this.isEnabled(), t;
  }
  static Parse(e, t, i) {
    const s = ae.Parse(() => new $(e.name, t), e, t, i);
    return e.localMatrix ? s.setPreTransformMatrix(x.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(x.FromArray(e.pivotMatrix)), s.setEnabled(e.isEnabled), s._waitingParsedUniqueId = e.uniqueId, e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), s;
  }
  getChildTransformNodes(e, t) {
    const i = [];
    return this._getDescendants(i, e, (s) => (!t || t(s)) && s instanceof $), i;
  }
  dispose(e, t = !1) {
    if (this.getScene().stopAnimation(this), this.getScene().removeTransformNode(this), this._parentContainer) {
      const i = this._parentContainer.transformNodes.indexOf(this);
      i > -1 && this._parentContainer.transformNodes.splice(i, 1), this._parentContainer = null;
    }
    if (this.onAfterWorldMatrixUpdateObservable.clear(), e) {
      const i = this.getChildTransformNodes(!0);
      for (const s of i)
        s.parent = null, s.computeWorldMatrix(!0);
    }
    super.dispose(e, t);
  }
  normalizeToUnitCube(e = !0, t = !1, i) {
    let s = null, r = null;
    t && (this.rotationQuaternion ? (r = this.rotationQuaternion.clone(), this.rotationQuaternion.copyFromFloats(0, 0, 0, 1)) : this.rotation && (s = this.rotation.clone(), this.rotation.copyFromFloats(0, 0, 0)));
    const n = this.getHierarchyBoundingVectors(e, i), a = n.max.subtract(n.min), o = Math.max(a.x, a.y, a.z);
    if (o === 0)
      return this;
    const h = 1 / o;
    return this.scaling.scaleInPlace(h), t && (this.rotationQuaternion && r ? this.rotationQuaternion.copyFrom(r) : this.rotation && s && this.rotation.copyFrom(s)), this;
  }
  _syncAbsoluteScalingAndRotation() {
    this._isAbsoluteSynced || (this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion), this._isAbsoluteSynced = !0);
  }
}
$.BILLBOARDMODE_NONE = 0;
$.BILLBOARDMODE_X = 1;
$.BILLBOARDMODE_Y = 2;
$.BILLBOARDMODE_Z = 4;
$.BILLBOARDMODE_ALL = 7;
$.BILLBOARDMODE_USE_POSITION = 128;
$.BillboardUseParentOrientation = !1;
$._TmpRotation = Y.Zero();
$._TmpScaling = p.Zero();
$._TmpTranslation = p.Zero();
$._LookAtVectorCache = new p(0, 0, 0);
$._RotationAxisCache = new Y();
T([
  Gt("position")
], $.prototype, "_position", void 0);
T([
  Gt("rotation")
], $.prototype, "_rotation", void 0);
T([
  Dn("rotationQuaternion")
], $.prototype, "_rotationQuaternion", void 0);
T([
  Gt("scaling")
], $.prototype, "_scaling", void 0);
T([
  R("billboardMode")
], $.prototype, "_billboardMode", void 0);
T([
  R()
], $.prototype, "scalingDeterminant", void 0);
T([
  R("infiniteDistance")
], $.prototype, "_infiniteDistance", void 0);
T([
  R()
], $.prototype, "ignoreNonUniformScaling", void 0);
T([
  R()
], $.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
class Gn {
  constructor() {
    this._checkCollisions = !1, this._collisionMask = -1, this._collisionGroup = -1, this._surroundingMeshes = null, this._collider = null, this._oldPositionForCollisions = new p(0, 0, 0), this._diffPositionForCollisions = new p(0, 0, 0), this._collisionResponse = !0;
  }
}
class Xn {
  constructor() {
    this.facetNb = 0, this.partitioningSubdivisions = 10, this.partitioningBBoxRatio = 1.01, this.facetDataEnabled = !1, this.facetParameters = {}, this.bbSize = p.Zero(), this.subDiv = {
      max: 1,
      X: 1,
      Y: 1,
      Z: 1
    }, this.facetDepthSort = !1, this.facetDepthSortEnabled = !1;
  }
}
class Hn {
  constructor() {
    this._hasVertexAlpha = !1, this._useVertexColors = !0, this._numBoneInfluencers = 4, this._applyFog = !0, this._receiveShadows = !1, this._facetData = new Xn(), this._visibility = 1, this._skeleton = null, this._layerMask = 268435455, this._computeBonesUsingShaders = !0, this._isActive = !1, this._onlyForInstances = !1, this._isActiveIntermediate = !1, this._onlyForInstancesIntermediate = !1, this._actAsRegularMesh = !1, this._currentLOD = null, this._currentLODIsUpToDate = !1, this._collisionRetryCount = 3, this._morphTargetManager = null, this._renderingGroupId = 0, this._bakedVertexAnimationManager = null, this._material = null, this._positions = null, this._pointerOverDisableMeshTesting = !1, this._meshCollisionData = new Gn(), this._enableDistantPicking = !1;
  }
}
class ot extends $ {
  constructor(e, t = null) {
    switch (super(e, t, !1), this._internalAbstractMeshDataInfo = new Hn(), this._waitingMaterialId = null, this.cullingStrategy = ot.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY, this.onCollideObservable = new w(), this.onCollisionPositionChangeObservable = new w(), this.onMaterialChangedObservable = new w(), this.definedFacingForward = !0, this._occlusionQuery = null, this._renderingGroup = null, this.alphaIndex = Number.MAX_VALUE, this.isVisible = !0, this.isPickable = !0, this.isNearPickable = !1, this.isNearGrabbable = !1, this.showSubMeshesBoundingBox = !1, this.isBlocker = !1, this.enablePointerMoveEvents = !1, this.outlineColor = se.Red(), this.outlineWidth = 0.02, this.overlayColor = se.Red(), this.overlayAlpha = 0.5, this.useOctreeForRenderingSelection = !0, this.useOctreeForPicking = !0, this.useOctreeForCollisions = !0, this.alwaysSelectAsActiveMesh = !1, this.doNotSyncBoundingInfo = !1, this.actionManager = null, this.ellipsoid = new p(0.5, 1, 0.5), this.ellipsoidOffset = new p(0, 0, 0), this.edgesWidth = 1, this.edgesColor = new ge(1, 0, 0, 1), this._edgesRenderer = null, this._masterMesh = null, this._boundingInfo = null, this._boundingInfoIsDirty = !0, this._renderId = 0, this._intersectionsInProgress = new Array(), this._unIndexed = !1, this._lightSources = new Array(), this._waitingData = {
      lods: null,
      actions: null,
      freezeWorldMatrix: null
    }, this._bonesTransformMatrices = null, this._transformMatrixTexture = null, this.onRebuildObservable = new w(), this._onCollisionPositionChange = (i, s, r = null) => {
      s.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > I.CollisionsEpsilon && this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions), r && this.onCollideObservable.notifyObservers(r), this.onCollisionPositionChangeObservable.notifyObservers(this.position);
    }, t = this.getScene(), t.addMesh(this), this._resyncLightSources(), this._uniformBuffer = new V(this.getScene().getEngine(), void 0, void 0, e, !this.getScene().getEngine().isWebGPU), this._buildUniformLayout(), t.performancePriority) {
      case Ct.Aggressive:
        this.doNotSyncBoundingInfo = !0;
      case Ct.Intermediate:
        this.alwaysSelectAsActiveMesh = !0, this.isPickable = !1;
        break;
    }
  }
  static get BILLBOARDMODE_NONE() {
    return $.BILLBOARDMODE_NONE;
  }
  static get BILLBOARDMODE_X() {
    return $.BILLBOARDMODE_X;
  }
  static get BILLBOARDMODE_Y() {
    return $.BILLBOARDMODE_Y;
  }
  static get BILLBOARDMODE_Z() {
    return $.BILLBOARDMODE_Z;
  }
  static get BILLBOARDMODE_ALL() {
    return $.BILLBOARDMODE_ALL;
  }
  static get BILLBOARDMODE_USE_POSITION() {
    return $.BILLBOARDMODE_USE_POSITION;
  }
  get facetNb() {
    return this._internalAbstractMeshDataInfo._facetData.facetNb;
  }
  get partitioningSubdivisions() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
  }
  set partitioningSubdivisions(e) {
    this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = e;
  }
  get partitioningBBoxRatio() {
    return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
  }
  set partitioningBBoxRatio(e) {
    this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = e;
  }
  get mustDepthSortFacets() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
  }
  set mustDepthSortFacets(e) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSort = e;
  }
  get facetDepthSortFrom() {
    return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
  }
  set facetDepthSortFrom(e) {
    this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = e;
  }
  get collisionRetryCount() {
    return this._internalAbstractMeshDataInfo._collisionRetryCount;
  }
  set collisionRetryCount(e) {
    this._internalAbstractMeshDataInfo._collisionRetryCount = e;
  }
  get isFacetDataEnabled() {
    return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
  }
  get morphTargetManager() {
    return this._internalAbstractMeshDataInfo._morphTargetManager;
  }
  set morphTargetManager(e) {
    this._internalAbstractMeshDataInfo._morphTargetManager !== e && (this._internalAbstractMeshDataInfo._morphTargetManager = e, this._syncGeometryWithMorphTargetManager());
  }
  get bakedVertexAnimationManager() {
    return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
  }
  set bakedVertexAnimationManager(e) {
    this._internalAbstractMeshDataInfo._bakedVertexAnimationManager !== e && (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = e, this._markSubMeshesAsAttributesDirty());
  }
  _syncGeometryWithMorphTargetManager() {
  }
  _updateNonUniformScalingState(e) {
    return super._updateNonUniformScalingState(e) ? (this._markSubMeshesAsMiscDirty(), !0) : !1;
  }
  set onCollide(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver && this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(e);
  }
  set onCollisionPositionChange(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver && this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver), this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(e);
  }
  get visibility() {
    return this._internalAbstractMeshDataInfo._visibility;
  }
  set visibility(e) {
    if (this._internalAbstractMeshDataInfo._visibility === e)
      return;
    const t = this._internalAbstractMeshDataInfo._visibility;
    this._internalAbstractMeshDataInfo._visibility = e, (t === 1 && e !== 1 || t !== 1 && e === 1) && this._markSubMeshesAsMiscDirty();
  }
  get pointerOverDisableMeshTesting() {
    return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;
  }
  set pointerOverDisableMeshTesting(e) {
    this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = e;
  }
  get renderingGroupId() {
    return this._internalAbstractMeshDataInfo._renderingGroupId;
  }
  set renderingGroupId(e) {
    this._internalAbstractMeshDataInfo._renderingGroupId = e;
  }
  get material() {
    return this._internalAbstractMeshDataInfo._material;
  }
  set material(e) {
    this._internalAbstractMeshDataInfo._material !== e && (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this._internalAbstractMeshDataInfo._material = e, e && e.meshMap && (e.meshMap[this.uniqueId] = this), this.onMaterialChangedObservable.hasObservers() && this.onMaterialChangedObservable.notifyObservers(this), this.subMeshes && (this.resetDrawCache(), this._unBindEffect()));
  }
  getMaterialForRenderPass(e) {
    var t;
    return (t = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || t === void 0 ? void 0 : t[e];
  }
  setMaterialForRenderPass(e, t) {
    this.resetDrawCache(e), this._internalAbstractMeshDataInfo._materialForRenderPass || (this._internalAbstractMeshDataInfo._materialForRenderPass = []), this._internalAbstractMeshDataInfo._materialForRenderPass[e] = t;
  }
  get receiveShadows() {
    return this._internalAbstractMeshDataInfo._receiveShadows;
  }
  set receiveShadows(e) {
    this._internalAbstractMeshDataInfo._receiveShadows !== e && (this._internalAbstractMeshDataInfo._receiveShadows = e, this._markSubMeshesAsLightDirty());
  }
  get hasVertexAlpha() {
    return this._internalAbstractMeshDataInfo._hasVertexAlpha;
  }
  set hasVertexAlpha(e) {
    this._internalAbstractMeshDataInfo._hasVertexAlpha !== e && (this._internalAbstractMeshDataInfo._hasVertexAlpha = e, this._markSubMeshesAsAttributesDirty(), this._markSubMeshesAsMiscDirty());
  }
  get useVertexColors() {
    return this._internalAbstractMeshDataInfo._useVertexColors;
  }
  set useVertexColors(e) {
    this._internalAbstractMeshDataInfo._useVertexColors !== e && (this._internalAbstractMeshDataInfo._useVertexColors = e, this._markSubMeshesAsAttributesDirty());
  }
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(e) {
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty());
  }
  get numBoneInfluencers() {
    return this._internalAbstractMeshDataInfo._numBoneInfluencers;
  }
  set numBoneInfluencers(e) {
    this._internalAbstractMeshDataInfo._numBoneInfluencers !== e && (this._internalAbstractMeshDataInfo._numBoneInfluencers = e, this._markSubMeshesAsAttributesDirty());
  }
  get applyFog() {
    return this._internalAbstractMeshDataInfo._applyFog;
  }
  set applyFog(e) {
    this._internalAbstractMeshDataInfo._applyFog !== e && (this._internalAbstractMeshDataInfo._applyFog = e, this._markSubMeshesAsMiscDirty());
  }
  get enableDistantPicking() {
    return this._internalAbstractMeshDataInfo._enableDistantPicking;
  }
  set enableDistantPicking(e) {
    this._internalAbstractMeshDataInfo._enableDistantPicking = e;
  }
  get layerMask() {
    return this._internalAbstractMeshDataInfo._layerMask;
  }
  set layerMask(e) {
    e !== this._internalAbstractMeshDataInfo._layerMask && (this._internalAbstractMeshDataInfo._layerMask = e, this._resyncLightSources());
  }
  get collisionMask() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
  }
  set collisionMask(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = isNaN(e) ? -1 : e;
  }
  get collisionResponse() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
  }
  set collisionResponse(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = e;
  }
  get collisionGroup() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
  }
  set collisionGroup(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = isNaN(e) ? -1 : e;
  }
  get surroundingMeshes() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
  }
  set surroundingMeshes(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = e;
  }
  get lightSources() {
    return this._lightSources;
  }
  get _positions() {
    return null;
  }
  set skeleton(e) {
    const t = this._internalAbstractMeshDataInfo._skeleton;
    t && t.needInitialSkinMatrix && t._unregisterMeshWithPoseMatrix(this), e && e.needInitialSkinMatrix && e._registerMeshWithPoseMatrix(this), this._internalAbstractMeshDataInfo._skeleton = e, this._internalAbstractMeshDataInfo._skeleton || (this._bonesTransformMatrices = null), this._markSubMeshesAsAttributesDirty();
  }
  get skeleton() {
    return this._internalAbstractMeshDataInfo._skeleton;
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("world", 16), this._uniformBuffer.addUniform("visibility", 1), this._uniformBuffer.create();
  }
  transferToEffect(e) {
    const t = this._uniformBuffer;
    t.updateMatrix("world", e), t.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility), t.update();
  }
  getMeshUniformBuffer() {
    return this._uniformBuffer;
  }
  getClassName() {
    return "AbstractMesh";
  }
  toString(e) {
    let t = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
    t += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
    const i = this._internalAbstractMeshDataInfo._skeleton;
    return i && (t += ", skeleton: " + i.name), e && (t += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode], t += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO")), t;
  }
  _getEffectiveParent() {
    return this._masterMesh && this.billboardMode !== $.BILLBOARDMODE_NONE ? this._masterMesh : super._getEffectiveParent();
  }
  _getActionManagerForTrigger(e, t = !0) {
    if (this.actionManager && (t || this.actionManager.isRecursive))
      if (e) {
        if (this.actionManager.hasSpecificTrigger(e))
          return this.actionManager;
      } else
        return this.actionManager;
    return this.parent ? this.parent._getActionManagerForTrigger(e, !1) : null;
  }
  _rebuild(e = !1) {
    if (this.onRebuildObservable.notifyObservers(this), this._occlusionQuery !== null && (this._occlusionQuery = null), !!this.subMeshes)
      for (const t of this.subMeshes)
        t._rebuild();
  }
  _resyncLightSources() {
    this._lightSources.length = 0;
    for (const e of this.getScene().lights)
      !e.isEnabled() || e.canAffectMesh(this) && this._lightSources.push(e);
    this._markSubMeshesAsLightDirty();
  }
  _resyncLightSource(e) {
    const t = e.isEnabled() && e.canAffectMesh(this), i = this._lightSources.indexOf(e);
    let s = !1;
    if (i === -1) {
      if (!t)
        return;
      this._lightSources.push(e);
    } else {
      if (t)
        return;
      s = !0, this._lightSources.splice(i, 1);
    }
    this._markSubMeshesAsLightDirty(s);
  }
  _unBindEffect() {
    for (const e of this.subMeshes)
      e.setEffect(null);
  }
  _removeLightSource(e, t) {
    const i = this._lightSources.indexOf(e);
    i !== -1 && (this._lightSources.splice(i, 1), this._markSubMeshesAsLightDirty(t));
  }
  _markSubMeshesAsDirty(e) {
    if (!!this.subMeshes)
      for (const t of this.subMeshes)
        for (let i = 0; i < t._drawWrappers.length; ++i) {
          const s = t._drawWrappers[i];
          !s || !s.defines || !s.defines.markAllAsDirty || e(s.defines);
        }
  }
  _markSubMeshesAsLightDirty(e = !1) {
    this._markSubMeshesAsDirty((t) => t.markAsLightDirty(e));
  }
  _markSubMeshesAsAttributesDirty() {
    this._markSubMeshesAsDirty((e) => e.markAsAttributesDirty());
  }
  _markSubMeshesAsMiscDirty() {
    this._markSubMeshesAsDirty((e) => e.markAsMiscDirty());
  }
  markAsDirty(e) {
    return this._currentRenderId = Number.MAX_VALUE, this._isDirty = !0, this;
  }
  resetDrawCache(e) {
    if (!!this.subMeshes)
      for (const t of this.subMeshes)
        t.resetDrawCache(e);
  }
  get isBlocked() {
    return !1;
  }
  getLOD(e) {
    return this;
  }
  getTotalVertices() {
    return 0;
  }
  getTotalIndices() {
    return 0;
  }
  getIndices() {
    return null;
  }
  getVerticesData(e) {
    return null;
  }
  setVerticesData(e, t, i, s) {
    return this;
  }
  updateVerticesData(e, t, i, s) {
    return this;
  }
  setIndices(e, t) {
    return this;
  }
  isVerticesDataPresent(e) {
    return !1;
  }
  getBoundingInfo() {
    return this._masterMesh ? this._masterMesh.getBoundingInfo() : (this._boundingInfoIsDirty && (this._boundingInfoIsDirty = !1, this._updateBoundingInfo()), this._boundingInfo);
  }
  setBoundingInfo(e) {
    return this._boundingInfo = e, this;
  }
  get hasBoundingInfo() {
    return this._boundingInfo !== null;
  }
  buildBoundingInfo(e, t, i) {
    return this._boundingInfo = new ft(e, t, i), this._boundingInfo;
  }
  normalizeToUnitCube(e = !0, t = !1, i) {
    return super.normalizeToUnitCube(e, t, i);
  }
  get useBones() {
    return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(g.MatricesIndicesKind) && this.isVerticesDataPresent(g.MatricesWeightsKind);
  }
  _preActivate() {
  }
  _preActivateForIntermediateRendering(e) {
  }
  _activate(e, t) {
    return this._renderId = e, !0;
  }
  _postActivate() {
  }
  _freeze() {
  }
  _unFreeze() {
  }
  getWorldMatrix() {
    return this._masterMesh && this.billboardMode === $.BILLBOARDMODE_NONE ? this._masterMesh.getWorldMatrix() : super.getWorldMatrix();
  }
  _getWorldMatrixDeterminant() {
    return this._masterMesh ? this._masterMesh._getWorldMatrixDeterminant() : super._getWorldMatrixDeterminant();
  }
  get isAnInstance() {
    return !1;
  }
  get hasInstances() {
    return !1;
  }
  get hasThinInstances() {
    return !1;
  }
  movePOV(e, t, i) {
    return this.position.addInPlace(this.calcMovePOV(e, t, i)), this;
  }
  calcMovePOV(e, t, i) {
    const s = new x();
    (this.rotationQuaternion ? this.rotationQuaternion : Y.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z)).toRotationMatrix(s);
    const n = p.Zero(), a = this.definedFacingForward ? -1 : 1;
    return p.TransformCoordinatesFromFloatsToRef(e * a, t, i * a, s, n), n;
  }
  rotatePOV(e, t, i) {
    return this.rotation.addInPlace(this.calcRotatePOV(e, t, i)), this;
  }
  calcRotatePOV(e, t, i) {
    const s = this.definedFacingForward ? 1 : -1;
    return new p(e * s, t, i * s);
  }
  refreshBoundingInfo(e = !1, t = !1) {
    return this._boundingInfo && this._boundingInfo.isLocked ? this : (this._refreshBoundingInfo(this._getPositionData(e, t), null), this);
  }
  _refreshBoundingInfo(e, t) {
    if (e) {
      const i = Nr(e, 0, this.getTotalVertices(), t);
      this._boundingInfo ? this._boundingInfo.reConstruct(i.minimum, i.maximum) : this._boundingInfo = new ft(i.minimum, i.maximum);
    }
    if (this.subMeshes)
      for (let i = 0; i < this.subMeshes.length; i++)
        this.subMeshes[i].refreshBoundingInfo(e);
    this._updateBoundingInfo();
  }
  _getData(e = !1, t = !1, i, s = g.PositionKind) {
    if (i = i != null ? i : this.getVerticesData(s).slice(), i && t && this.morphTargetManager) {
      let r = 0, n = 0;
      for (let a = 0; a < i.length; a++) {
        for (let o = 0; o < this.morphTargetManager.numTargets; o++) {
          const h = this.morphTargetManager.getTarget(o), l = h.influence;
          if (l > 0) {
            const u = h.getPositions();
            u && (i[a] += (u[a] - i[a]) * l);
          }
        }
        if (r++, s === g.PositionKind && this._positions && r === 3) {
          r = 0;
          const o = n * 3;
          this._positions[n++].copyFromFloats(i[o], i[o + 1], i[o + 2]);
        }
      }
    }
    if (i && e && this.skeleton) {
      const r = this.getVerticesData(g.MatricesIndicesKind), n = this.getVerticesData(g.MatricesWeightsKind);
      if (n && r) {
        const a = this.numBoneInfluencers > 4, o = a ? this.getVerticesData(g.MatricesIndicesExtraKind) : null, h = a ? this.getVerticesData(g.MatricesWeightsExtraKind) : null, l = this.skeleton.getTransformMatrices(this), u = D.Vector3[0], d = D.Matrix[0], f = D.Matrix[1];
        let _ = 0;
        for (let E = 0; E < i.length; E += 3, _ += 4) {
          d.reset();
          let m, v;
          for (m = 0; m < 4; m++)
            v = n[_ + m], v > 0 && (x.FromFloat32ArrayToRefScaled(l, Math.floor(r[_ + m] * 16), v, f), d.addToSelf(f));
          if (a)
            for (m = 0; m < 4; m++)
              v = h[_ + m], v > 0 && (x.FromFloat32ArrayToRefScaled(l, Math.floor(o[_ + m] * 16), v, f), d.addToSelf(f));
          s === g.NormalKind ? p.TransformNormalFromFloatsToRef(i[E], i[E + 1], i[E + 2], d, u) : p.TransformCoordinatesFromFloatsToRef(i[E], i[E + 1], i[E + 2], d, u), u.toArray(i, E), s === g.PositionKind && this._positions && this._positions[E / 3].copyFrom(u);
        }
      }
    }
    return i;
  }
  getNormalsData(e = !1, t = !1) {
    return this._getData(e, t, null, g.NormalKind);
  }
  getPositionData(e = !1, t = !1, i) {
    return this._getData(e, t, i, g.PositionKind);
  }
  _getPositionData(e, t) {
    var i;
    let s = this.getVerticesData(g.PositionKind);
    if (this._internalAbstractMeshDataInfo._positions && (this._internalAbstractMeshDataInfo._positions = null), s && (e && this.skeleton || t && this.morphTargetManager)) {
      if (s = s.slice(), this._generatePointsArray(), this._positions) {
        const r = this._positions;
        this._internalAbstractMeshDataInfo._positions = new Array(r.length);
        for (let n = 0; n < r.length; n++)
          this._internalAbstractMeshDataInfo._positions[n] = ((i = r[n]) === null || i === void 0 ? void 0 : i.clone()) || new p();
      }
      return this.getPositionData(e, t, s);
    }
    return s;
  }
  _updateBoundingInfo() {
    return this._boundingInfo ? this._boundingInfo.update(this.worldMatrixFromCache) : this._boundingInfo = new ft(p.Zero(), p.Zero(), this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;
  }
  _updateSubMeshesBoundingInfo(e) {
    if (!this.subMeshes)
      return this;
    const t = this.subMeshes.length;
    for (let i = 0; i < t; i++) {
      const s = this.subMeshes[i];
      (t > 1 || !s.IsGlobal) && s.updateBoundingInfo(e);
    }
    return this;
  }
  _afterComputeWorldMatrix() {
    this.doNotSyncBoundingInfo || (this._boundingInfoIsDirty = !0);
  }
  isInFrustum(e) {
    return this.getBoundingInfo().isInFrustum(e, this.cullingStrategy);
  }
  isCompletelyInFrustum(e) {
    return this.getBoundingInfo().isCompletelyInFrustum(e);
  }
  intersectsMesh(e, t = !1, i) {
    const s = this.getBoundingInfo(), r = e.getBoundingInfo();
    if (s.intersects(r, t))
      return !0;
    if (i) {
      for (const n of this.getChildMeshes())
        if (n.intersectsMesh(e, t, !0))
          return !0;
    }
    return !1;
  }
  intersectsPoint(e) {
    return this.getBoundingInfo().intersectsPoint(e);
  }
  get checkCollisions() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
  }
  set checkCollisions(e) {
    this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = e;
  }
  get collider() {
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
  }
  moveWithCollisions(e) {
    this.getAbsolutePosition().addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
    const i = this.getScene().collisionCoordinator;
    return this._internalAbstractMeshDataInfo._meshCollisionData._collider || (this._internalAbstractMeshDataInfo._meshCollisionData._collider = i.createCollider()), this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid, i.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, e, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId), this;
  }
  _collideForSubMesh(e, t, i) {
    var s;
    if (this._generatePointsArray(), !this._positions)
      return this;
    if (!e._lastColliderWorldVertices || !e._lastColliderTransformMatrix.equals(t)) {
      e._lastColliderTransformMatrix = t.clone(), e._lastColliderWorldVertices = [], e._trianglePlanes = [];
      const r = e.verticesStart, n = e.verticesStart + e.verticesCount;
      for (let a = r; a < n; a++)
        e._lastColliderWorldVertices.push(p.TransformCoordinates(this._positions[a], t));
    }
    return i._collide(e._trianglePlanes, e._lastColliderWorldVertices, this.getIndices(), e.indexStart, e.indexStart + e.indexCount, e.verticesStart, !!e.getMaterial(), this, this._shouldConvertRHS(), ((s = e.getMaterial()) === null || s === void 0 ? void 0 : s.fillMode) === 7), this;
  }
  _processCollisionsForSubMeshes(e, t) {
    const i = this._scene.getCollidingSubMeshCandidates(this, e), s = i.length;
    for (let r = 0; r < s; r++) {
      const n = i.data[r];
      s > 1 && !n._checkCollision(e) || this._collideForSubMesh(n, t, e);
    }
    return this;
  }
  _shouldConvertRHS() {
    return !1;
  }
  _checkCollision(e) {
    if (!this.getBoundingInfo()._checkCollision(e))
      return this;
    const t = D.Matrix[0], i = D.Matrix[1];
    return x.ScalingToRef(1 / e._radius.x, 1 / e._radius.y, 1 / e._radius.z, t), this.worldMatrixFromCache.multiplyToRef(t, i), this._processCollisionsForSubMeshes(e, i), this;
  }
  _generatePointsArray() {
    return !1;
  }
  intersects(e, t, i, s = !1, r, n = !1) {
    const a = new zt(), o = this.getClassName() === "InstancedLinesMesh" || this.getClassName() === "LinesMesh" ? this.intersectionThreshold : 0, h = this.getBoundingInfo();
    if (!this.subMeshes || !n && (!e.intersectsSphere(h.boundingSphere, o) || !e.intersectsBox(h.boundingBox, o)))
      return a;
    if (s)
      return a.hit = !n, a.pickedMesh = n ? null : this, a.distance = n ? 0 : p.Distance(e.origin, h.boundingSphere.center), a.subMeshId = 0, a;
    if (!this._generatePointsArray())
      return a;
    let l = null;
    const u = this._scene.getIntersectingSubMeshCandidates(this, e), d = u.length;
    let f = !1;
    for (let _ = 0; _ < d; _++) {
      const m = u.data[_].getMaterial();
      if (!!m && (m.fillMode == 7 || m.fillMode == 0 || m.fillMode == 1 || m.fillMode == 2 || m.fillMode == 4)) {
        f = !0;
        break;
      }
    }
    if (!f)
      return a.hit = !0, a.pickedMesh = this, a.distance = p.Distance(e.origin, h.boundingSphere.center), a.subMeshId = -1, a;
    for (let _ = 0; _ < d; _++) {
      const E = u.data[_];
      if (d > 1 && !E.canIntersects(e))
        continue;
      const m = E.intersects(e, this._positions, this.getIndices(), t, i);
      if (m && (t || !l || m.distance < l.distance) && (l = m, l.subMeshId = _, t))
        break;
    }
    if (l) {
      const _ = r != null ? r : this.getWorldMatrix(), E = D.Vector3[0], m = D.Vector3[1];
      p.TransformCoordinatesToRef(e.origin, _, E), e.direction.scaleToRef(l.distance, m);
      const S = p.TransformNormal(m, _).addInPlace(E);
      return a.hit = !0, a.distance = p.Distance(E, S), a.pickedPoint = S, a.pickedMesh = this, a.bu = l.bu || 0, a.bv = l.bv || 0, a.subMeshFaceId = l.faceId, a.faceId = l.faceId + u.data[l.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3), a.subMeshId = l.subMeshId, a;
    }
    return a;
  }
  clone(e, t, i) {
    return null;
  }
  releaseSubMeshes() {
    if (this.subMeshes)
      for (; this.subMeshes.length; )
        this.subMeshes[0].dispose();
    else
      this.subMeshes = new Array();
    return this;
  }
  dispose(e, t = !1) {
    let i;
    for (this._scene.useMaterialMeshMap && this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap && (this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0), this.getScene().freeActiveMeshes(), this.getScene().freeRenderingGroups(), this.actionManager !== void 0 && this.actionManager !== null && (this.actionManager.dispose(), this.actionManager = null), this._internalAbstractMeshDataInfo._skeleton = null, this._transformMatrixTexture && (this._transformMatrixTexture.dispose(), this._transformMatrixTexture = null), i = 0; i < this._intersectionsInProgress.length; i++) {
      const n = this._intersectionsInProgress[i], a = n._intersectionsInProgress.indexOf(this);
      n._intersectionsInProgress.splice(a, 1);
    }
    this._intersectionsInProgress.length = 0, this.getScene().lights.forEach((n) => {
      let a = n.includedOnlyMeshes.indexOf(this);
      a !== -1 && n.includedOnlyMeshes.splice(a, 1), a = n.excludedMeshes.indexOf(this), a !== -1 && n.excludedMeshes.splice(a, 1);
      const o = n.getShadowGenerators();
      if (o) {
        const h = o.values();
        for (let l = h.next(); l.done !== !0; l = h.next()) {
          const d = l.value.getShadowMap();
          d && d.renderList && (a = d.renderList.indexOf(this), a !== -1 && d.renderList.splice(a, 1));
        }
      }
    }), (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") && this.releaseSubMeshes();
    const r = this.getScene().getEngine();
    if (this._occlusionQuery !== null && (this.isOcclusionQueryInProgress = !1, r.deleteQuery(this._occlusionQuery), this._occlusionQuery = null), r.wipeCaches(), this.getScene().removeMesh(this), this._parentContainer) {
      const n = this._parentContainer.meshes.indexOf(this);
      n > -1 && this._parentContainer.meshes.splice(n, 1), this._parentContainer = null;
    }
    if (t && this.material && (this.material.getClassName() === "MultiMaterial" ? this.material.dispose(!1, !0, !0) : this.material.dispose(!1, !0)), !e)
      for (i = 0; i < this.getScene().particleSystems.length; i++)
        this.getScene().particleSystems[i].emitter === this && (this.getScene().particleSystems[i].dispose(), i--);
    this._internalAbstractMeshDataInfo._facetData.facetDataEnabled && this.disableFacetData(), this._uniformBuffer.dispose(), this.onAfterWorldMatrixUpdateObservable.clear(), this.onCollideObservable.clear(), this.onCollisionPositionChangeObservable.clear(), this.onRebuildObservable.clear(), super.dispose(e, t);
  }
  addChild(e, t = !1) {
    return e.setParent(this, t), this;
  }
  removeChild(e, t = !1) {
    return e.setParent(null, t), this;
  }
  _initFacetData() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    e.facetNormals || (e.facetNormals = new Array()), e.facetPositions || (e.facetPositions = new Array()), e.facetPartitioning || (e.facetPartitioning = new Array()), e.facetNb = this.getIndices().length / 3 | 0, e.partitioningSubdivisions = e.partitioningSubdivisions ? e.partitioningSubdivisions : 10, e.partitioningBBoxRatio = e.partitioningBBoxRatio ? e.partitioningBBoxRatio : 1.01;
    for (let t = 0; t < e.facetNb; t++)
      e.facetNormals[t] = p.Zero(), e.facetPositions[t] = p.Zero();
    return e.facetDataEnabled = !0, this;
  }
  updateFacetData() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    e.facetDataEnabled || this._initFacetData();
    const t = this.getVerticesData(g.PositionKind), i = this.getIndices(), s = this.getVerticesData(g.NormalKind), r = this.getBoundingInfo();
    if (e.facetDepthSort && !e.facetDepthSortEnabled) {
      if (e.facetDepthSortEnabled = !0, i instanceof Uint16Array)
        e.depthSortedIndices = new Uint16Array(i);
      else if (i instanceof Uint32Array)
        e.depthSortedIndices = new Uint32Array(i);
      else {
        let a = !1;
        for (let o = 0; o < i.length; o++)
          if (i[o] > 65535) {
            a = !0;
            break;
          }
        a ? e.depthSortedIndices = new Uint32Array(i) : e.depthSortedIndices = new Uint16Array(i);
      }
      if (e.facetDepthSortFunction = function(a, o) {
        return o.sqDistance - a.sqDistance;
      }, !e.facetDepthSortFrom) {
        const a = this.getScene().activeCamera;
        e.facetDepthSortFrom = a ? a.position : p.Zero();
      }
      e.depthSortedFacets = [];
      for (let a = 0; a < e.facetNb; a++) {
        const o = { ind: a * 3, sqDistance: 0 };
        e.depthSortedFacets.push(o);
      }
      e.invertedMatrix = x.Identity(), e.facetDepthSortOrigin = p.Zero();
    }
    e.bbSize.x = r.maximum.x - r.minimum.x > Re ? r.maximum.x - r.minimum.x : Re, e.bbSize.y = r.maximum.y - r.minimum.y > Re ? r.maximum.y - r.minimum.y : Re, e.bbSize.z = r.maximum.z - r.minimum.z > Re ? r.maximum.z - r.minimum.z : Re;
    let n = e.bbSize.x > e.bbSize.y ? e.bbSize.x : e.bbSize.y;
    if (n = n > e.bbSize.z ? n : e.bbSize.z, e.subDiv.max = e.partitioningSubdivisions, e.subDiv.X = Math.floor(e.subDiv.max * e.bbSize.x / n), e.subDiv.Y = Math.floor(e.subDiv.max * e.bbSize.y / n), e.subDiv.Z = Math.floor(e.subDiv.max * e.bbSize.z / n), e.subDiv.X = e.subDiv.X < 1 ? 1 : e.subDiv.X, e.subDiv.Y = e.subDiv.Y < 1 ? 1 : e.subDiv.Y, e.subDiv.Z = e.subDiv.Z < 1 ? 1 : e.subDiv.Z, e.facetParameters.facetNormals = this.getFacetLocalNormals(), e.facetParameters.facetPositions = this.getFacetLocalPositions(), e.facetParameters.facetPartitioning = this.getFacetLocalPartitioning(), e.facetParameters.bInfo = r, e.facetParameters.bbSize = e.bbSize, e.facetParameters.subDiv = e.subDiv, e.facetParameters.ratio = this.partitioningBBoxRatio, e.facetParameters.depthSort = e.facetDepthSort, e.facetDepthSort && e.facetDepthSortEnabled && (this.computeWorldMatrix(!0), this._worldMatrix.invertToRef(e.invertedMatrix), p.TransformCoordinatesToRef(e.facetDepthSortFrom, e.invertedMatrix, e.facetDepthSortOrigin), e.facetParameters.distanceTo = e.facetDepthSortOrigin), e.facetParameters.depthSortedFacets = e.depthSortedFacets, s && J.ComputeNormals(t, i, s, e.facetParameters), e.facetDepthSort && e.facetDepthSortEnabled) {
      e.depthSortedFacets.sort(e.facetDepthSortFunction);
      const a = e.depthSortedIndices.length / 3 | 0;
      for (let o = 0; o < a; o++) {
        const h = e.depthSortedFacets[o].ind;
        e.depthSortedIndices[o * 3] = i[h], e.depthSortedIndices[o * 3 + 1] = i[h + 1], e.depthSortedIndices[o * 3 + 2] = i[h + 2];
      }
      this.updateIndices(e.depthSortedIndices, void 0, !0);
    }
    return this;
  }
  getFacetLocalNormals() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetNormals || this.updateFacetData(), e.facetNormals;
  }
  getFacetLocalPositions() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetPositions || this.updateFacetData(), e.facetPositions;
  }
  getFacetLocalPartitioning() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetPartitioning || this.updateFacetData(), e.facetPartitioning;
  }
  getFacetPosition(e) {
    const t = p.Zero();
    return this.getFacetPositionToRef(e, t), t;
  }
  getFacetPositionToRef(e, t) {
    const i = this.getFacetLocalPositions()[e], s = this.getWorldMatrix();
    return p.TransformCoordinatesToRef(i, s, t), this;
  }
  getFacetNormal(e) {
    const t = p.Zero();
    return this.getFacetNormalToRef(e, t), t;
  }
  getFacetNormalToRef(e, t) {
    const i = this.getFacetLocalNormals()[e];
    return p.TransformNormalToRef(i, this.getWorldMatrix(), t), this;
  }
  getFacetsAtLocalCoordinates(e, t, i) {
    const s = this.getBoundingInfo(), r = this._internalAbstractMeshDataInfo._facetData, n = Math.floor((e - s.minimum.x * r.partitioningBBoxRatio) * r.subDiv.X * r.partitioningBBoxRatio / r.bbSize.x), a = Math.floor((t - s.minimum.y * r.partitioningBBoxRatio) * r.subDiv.Y * r.partitioningBBoxRatio / r.bbSize.y), o = Math.floor((i - s.minimum.z * r.partitioningBBoxRatio) * r.subDiv.Z * r.partitioningBBoxRatio / r.bbSize.z);
    return n < 0 || n > r.subDiv.max || a < 0 || a > r.subDiv.max || o < 0 || o > r.subDiv.max ? null : r.facetPartitioning[n + r.subDiv.max * a + r.subDiv.max * r.subDiv.max * o];
  }
  getClosestFacetAtCoordinates(e, t, i, s, r = !1, n = !0) {
    const a = this.getWorldMatrix(), o = D.Matrix[5];
    a.invertToRef(o);
    const h = D.Vector3[8];
    p.TransformCoordinatesFromFloatsToRef(e, t, i, o, h);
    const l = this.getClosestFacetAtLocalCoordinates(h.x, h.y, h.z, s, r, n);
    return s && p.TransformCoordinatesFromFloatsToRef(s.x, s.y, s.z, a, s), l;
  }
  getClosestFacetAtLocalCoordinates(e, t, i, s, r = !1, n = !0) {
    let a = null, o = 0, h = 0, l = 0, u = 0, d = 0, f = 0, _ = 0, E = 0;
    const m = this.getFacetLocalPositions(), v = this.getFacetLocalNormals(), S = this.getFacetsAtLocalCoordinates(e, t, i);
    if (!S)
      return null;
    let y = Number.MAX_VALUE, A = y, C, b, M;
    for (let L = 0; L < S.length; L++)
      C = S[L], b = v[C], M = m[C], u = (e - M.x) * b.x + (t - M.y) * b.y + (i - M.z) * b.z, (!r || r && n && u >= 0 || r && !n && u <= 0) && (u = b.x * M.x + b.y * M.y + b.z * M.z, d = -(b.x * e + b.y * t + b.z * i - u) / (b.x * b.x + b.y * b.y + b.z * b.z), f = e + b.x * d, _ = t + b.y * d, E = i + b.z * d, o = f - e, h = _ - t, l = E - i, A = o * o + h * h + l * l, A < y && (y = A, a = C, s && (s.x = f, s.y = _, s.z = E)));
    return a;
  }
  getFacetDataParameters() {
    return this._internalAbstractMeshDataInfo._facetData.facetParameters;
  }
  disableFacetData() {
    const e = this._internalAbstractMeshDataInfo._facetData;
    return e.facetDataEnabled && (e.facetDataEnabled = !1, e.facetPositions = new Array(), e.facetNormals = new Array(), e.facetPartitioning = new Array(), e.facetParameters = null, e.depthSortedIndices = new Uint32Array(0)), this;
  }
  updateIndices(e, t, i = !1) {
    return this;
  }
  createNormals(e) {
    const t = this.getVerticesData(g.PositionKind), i = this.getIndices();
    let s;
    return this.isVerticesDataPresent(g.NormalKind) ? s = this.getVerticesData(g.NormalKind) : s = [], J.ComputeNormals(t, i, s, { useRightHandedSystem: this.getScene().useRightHandedSystem }), this.setVerticesData(g.NormalKind, s, e), this;
  }
  alignWithNormal(e, t) {
    t || (t = ui.Y);
    const i = D.Vector3[0], s = D.Vector3[1];
    return p.CrossToRef(t, e, s), p.CrossToRef(e, s, i), this.rotationQuaternion ? Y.RotationQuaternionFromAxisToRef(i, e, s, this.rotationQuaternion) : p.RotationFromAxisToRef(i, e, s, this.rotation), this;
  }
  _checkOcclusionQuery() {
    return !1;
  }
  disableEdgesRendering() {
    throw Q("EdgesRenderer");
  }
  enableEdgesRendering(e, t, i) {
    throw Q("EdgesRenderer");
  }
  getConnectedParticleSystems() {
    return this._scene.particleSystems.filter((e) => e.emitter === this);
  }
}
ot.OCCLUSION_TYPE_NONE = 0;
ot.OCCLUSION_TYPE_OPTIMISTIC = 1;
ot.OCCLUSION_TYPE_STRICT = 2;
ot.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
ot.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
ot.CULLINGSTRATEGY_STANDARD = 0;
ot.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
ot.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
ot.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
st("BABYLON.AbstractMesh", ot);
function ls(c) {
  c.indexOf("vClipPlane") === -1 && c.push("vClipPlane"), c.indexOf("vClipPlane2") === -1 && c.push("vClipPlane2"), c.indexOf("vClipPlane3") === -1 && c.push("vClipPlane3"), c.indexOf("vClipPlane4") === -1 && c.push("vClipPlane4"), c.indexOf("vClipPlane5") === -1 && c.push("vClipPlane5"), c.indexOf("vClipPlane6") === -1 && c.push("vClipPlane6");
}
function Ys(c, e, t) {
  var i, s, r, n, a, o;
  let h = !1, l = (i = c.clipPlane) !== null && i !== void 0 ? i : e.clipPlane;
  return h = pi(l, t, "CLIPPLANE") || h, l = (s = c.clipPlane2) !== null && s !== void 0 ? s : e.clipPlane2, h = pi(l, t, "CLIPPLANE2") || h, l = (r = c.clipPlane3) !== null && r !== void 0 ? r : e.clipPlane3, h = pi(l, t, "CLIPPLANE3") || h, l = (n = c.clipPlane4) !== null && n !== void 0 ? n : e.clipPlane4, h = pi(l, t, "CLIPPLANE4") || h, l = (a = c.clipPlane5) !== null && a !== void 0 ? a : e.clipPlane5, h = pi(l, t, "CLIPPLANE5") || h, l = (o = c.clipPlane6) !== null && o !== void 0 ? o : e.clipPlane6, h = pi(l, t, "CLIPPLANE6") || h, h;
}
function cs(c, e, t) {
  var i, s, r, n, a, o;
  let h = (i = e.clipPlane) !== null && i !== void 0 ? i : t.clipPlane;
  gi(c, "vClipPlane", h), h = (s = e.clipPlane2) !== null && s !== void 0 ? s : t.clipPlane2, gi(c, "vClipPlane2", h), h = (r = e.clipPlane3) !== null && r !== void 0 ? r : t.clipPlane3, gi(c, "vClipPlane3", h), h = (n = e.clipPlane4) !== null && n !== void 0 ? n : t.clipPlane4, gi(c, "vClipPlane4", h), h = (a = e.clipPlane5) !== null && a !== void 0 ? a : t.clipPlane5, gi(c, "vClipPlane5", h), h = (o = e.clipPlane6) !== null && o !== void 0 ? o : t.clipPlane6, gi(c, "vClipPlane6", h);
}
function gi(c, e, t) {
  t && c.setFloat4(e, t.normal.x, t.normal.y, t.normal.z, t.d);
}
function pi(c, e, t) {
  let i = !0;
  if (c)
    if (Array.isArray(e)) {
      const s = "#define " + t;
      i = e.indexOf(s) !== -1, i || e.push(s);
    } else
      i = e[t], e[t] = !0;
  return !i;
}
class te {
  static BindSceneUniformBuffer(e, t) {
    t.bindToEffect(e, "Scene");
  }
  static PrepareDefinesForMergedUV(e, t, i) {
    t._needUVs = !0, t[i] = !0, e.optimizeUVAllocation && e.getTextureMatrix().isIdentityAs3x2() ? (t[i + "DIRECTUV"] = e.coordinatesIndex + 1, t["MAINUV" + (e.coordinatesIndex + 1)] = !0) : t[i + "DIRECTUV"] = 0;
  }
  static BindTextureMatrix(e, t, i) {
    const s = e.getTextureMatrix();
    t.updateMatrix(i + "Matrix", s);
  }
  static GetFogState(e, t) {
    return t.fogEnabled && e.applyFog && t.fogMode !== re.FOGMODE_NONE;
  }
  static PrepareDefinesForMisc(e, t, i, s, r, n, a) {
    a._areMiscDirty && (a.LOGARITHMICDEPTH = i, a.POINTSIZE = s, a.FOG = r && this.GetFogState(e, t), a.NONUNIFORMSCALING = e.nonUniformScaling, a.ALPHATEST = n);
  }
  static PrepareDefinesForCamera(e, t) {
    let i = !1;
    if (e.activeCamera) {
      const s = t.CAMERA_ORTHOGRAPHIC ? 1 : 0, r = t.CAMERA_PERSPECTIVE ? 1 : 0, n = e.activeCamera.mode === q.ORTHOGRAPHIC_CAMERA ? 1 : 0, a = e.activeCamera.mode === q.PERSPECTIVE_CAMERA ? 1 : 0;
      (s ^ n || r ^ a) && (t.CAMERA_ORTHOGRAPHIC = n === 1, t.CAMERA_PERSPECTIVE = a === 1, i = !0);
    }
    return i;
  }
  static PrepareDefinesForFrameBoundValues(e, t, i, s, r, n = null, a = !1) {
    let o = te.PrepareDefinesForCamera(e, s);
    n !== !1 && (o = Ys(i, e, s)), s.DEPTHPREPASS !== !t.getColorWrite() && (s.DEPTHPREPASS = !s.DEPTHPREPASS, o = !0), s.INSTANCES !== r && (s.INSTANCES = r, o = !0), s.THIN_INSTANCES !== a && (s.THIN_INSTANCES = a, o = !0), o && s.markAsUnprocessed();
  }
  static PrepareDefinesForBones(e, t) {
    if (e.useBones && e.computeBonesUsingShaders && e.skeleton) {
      t.NUM_BONE_INFLUENCERS = e.numBoneInfluencers;
      const i = t.BONETEXTURE !== void 0;
      if (e.skeleton.isUsingTextureForMatrices && i)
        t.BONETEXTURE = !0;
      else {
        t.BonesPerMesh = e.skeleton.bones.length + 1, t.BONETEXTURE = i ? !1 : void 0;
        const s = e.getScene().prePassRenderer;
        if (s && s.enabled) {
          const r = s.excludedSkinnedMesh.indexOf(e) === -1;
          t.BONES_VELOCITY_ENABLED = r;
        }
      }
    } else
      t.NUM_BONE_INFLUENCERS = 0, t.BonesPerMesh = 0, t.BONETEXTURE !== void 0 && (t.BONETEXTURE = !1);
  }
  static PrepareDefinesForMorphTargets(e, t) {
    const i = e.morphTargetManager;
    i ? (t.MORPHTARGETS_UV = i.supportsUVs && t.UV1, t.MORPHTARGETS_TANGENT = i.supportsTangents && t.TANGENT, t.MORPHTARGETS_NORMAL = i.supportsNormals && t.NORMAL, t.MORPHTARGETS = i.numInfluencers > 0, t.NUM_MORPH_INFLUENCERS = i.numInfluencers, t.MORPHTARGETS_TEXTURE = i.isUsingTextureForTargets) : (t.MORPHTARGETS_UV = !1, t.MORPHTARGETS_TANGENT = !1, t.MORPHTARGETS_NORMAL = !1, t.MORPHTARGETS = !1, t.NUM_MORPH_INFLUENCERS = 0);
  }
  static PrepareDefinesForBakedVertexAnimation(e, t) {
    const i = e.bakedVertexAnimationManager;
    t.BAKED_VERTEX_ANIMATION_TEXTURE = !!(i && i.isEnabled);
  }
  static PrepareDefinesForAttributes(e, t, i, s, r = !1, n = !0, a = !0) {
    if (!t._areAttributesDirty && t._needNormals === t._normals && t._needUVs === t._uvs)
      return !1;
    t._normals = t._needNormals, t._uvs = t._needUVs, t.NORMAL = t._needNormals && e.isVerticesDataPresent(g.NormalKind), t._needNormals && e.isVerticesDataPresent(g.TangentKind) && (t.TANGENT = !0);
    for (let o = 1; o <= 6; ++o)
      t["UV" + o] = t._needUVs ? e.isVerticesDataPresent(`uv${o === 1 ? "" : o}`) : !1;
    if (i) {
      const o = e.useVertexColors && e.isVerticesDataPresent(g.ColorKind);
      t.VERTEXCOLOR = o, t.VERTEXALPHA = e.hasVertexAlpha && o && n;
    }
    return e.isVerticesDataPresent(g.ColorInstanceKind) && (e.hasInstances || e.hasThinInstances) && (t.INSTANCESCOLOR = !0), s && this.PrepareDefinesForBones(e, t), r && this.PrepareDefinesForMorphTargets(e, t), a && this.PrepareDefinesForBakedVertexAnimation(e, t), !0;
  }
  static PrepareDefinesForMultiview(e, t) {
    if (e.activeCamera) {
      const i = t.MULTIVIEW;
      t.MULTIVIEW = e.activeCamera.outputRenderTarget !== null && e.activeCamera.outputRenderTarget.getViewCount() > 1, t.MULTIVIEW != i && t.markAsUnprocessed();
    }
  }
  static PrepareDefinesForOIT(e, t, i) {
    const s = t.ORDER_INDEPENDENT_TRANSPARENCY, r = t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
    t.ORDER_INDEPENDENT_TRANSPARENCY = e.useOrderIndependentTransparency && i, t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !e.getEngine().getCaps().textureFloatLinearFiltering, (s !== t.ORDER_INDEPENDENT_TRANSPARENCY || r !== t.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) && t.markAsUnprocessed();
  }
  static PrepareDefinesForPrePass(e, t, i) {
    const s = t.PREPASS;
    if (!t._arePrePassDirty)
      return;
    const r = [
      {
        type: 1,
        define: "PREPASS_POSITION",
        index: "PREPASS_POSITION_INDEX"
      },
      {
        type: 2,
        define: "PREPASS_VELOCITY",
        index: "PREPASS_VELOCITY_INDEX"
      },
      {
        type: 3,
        define: "PREPASS_REFLECTIVITY",
        index: "PREPASS_REFLECTIVITY_INDEX"
      },
      {
        type: 0,
        define: "PREPASS_IRRADIANCE",
        index: "PREPASS_IRRADIANCE_INDEX"
      },
      {
        type: 7,
        define: "PREPASS_ALBEDO_SQRT",
        index: "PREPASS_ALBEDO_SQRT_INDEX"
      },
      {
        type: 5,
        define: "PREPASS_DEPTH",
        index: "PREPASS_DEPTH_INDEX"
      },
      {
        type: 6,
        define: "PREPASS_NORMAL",
        index: "PREPASS_NORMAL_INDEX"
      }
    ];
    if (e.prePassRenderer && e.prePassRenderer.enabled && i) {
      t.PREPASS = !0, t.SCENE_MRT_COUNT = e.prePassRenderer.mrtCount;
      for (let n = 0; n < r.length; n++) {
        const a = e.prePassRenderer.getIndex(r[n].type);
        a !== -1 ? (t[r[n].define] = !0, t[r[n].index] = a) : t[r[n].define] = !1;
      }
    } else {
      t.PREPASS = !1;
      for (let n = 0; n < r.length; n++)
        t[r[n].define] = !1;
    }
    t.PREPASS != s && (t.markAsUnprocessed(), t.markAsImageProcessingDirty());
  }
  static PrepareDefinesForLight(e, t, i, s, r, n, a) {
    var o;
    switch (a.needNormals = !0, r["LIGHT" + s] === void 0 && (a.needRebuild = !0), r["LIGHT" + s] = !0, r["SPOTLIGHT" + s] = !1, r["HEMILIGHT" + s] = !1, r["POINTLIGHT" + s] = !1, r["DIRLIGHT" + s] = !1, i.prepareLightSpecificDefines(r, s), r["LIGHT_FALLOFF_PHYSICAL" + s] = !1, r["LIGHT_FALLOFF_GLTF" + s] = !1, r["LIGHT_FALLOFF_STANDARD" + s] = !1, i.falloffType) {
      case Ee.FALLOFF_GLTF:
        r["LIGHT_FALLOFF_GLTF" + s] = !0;
        break;
      case Ee.FALLOFF_PHYSICAL:
        r["LIGHT_FALLOFF_PHYSICAL" + s] = !0;
        break;
      case Ee.FALLOFF_STANDARD:
        r["LIGHT_FALLOFF_STANDARD" + s] = !0;
        break;
    }
    if (n && !i.specular.equalsFloats(0, 0, 0) && (a.specularEnabled = !0), r["SHADOW" + s] = !1, r["SHADOWCSM" + s] = !1, r["SHADOWCSMDEBUG" + s] = !1, r["SHADOWCSMNUM_CASCADES" + s] = !1, r["SHADOWCSMUSESHADOWMAXZ" + s] = !1, r["SHADOWCSMNOBLEND" + s] = !1, r["SHADOWCSM_RIGHTHANDED" + s] = !1, r["SHADOWPCF" + s] = !1, r["SHADOWPCSS" + s] = !1, r["SHADOWPOISSON" + s] = !1, r["SHADOWESM" + s] = !1, r["SHADOWCLOSEESM" + s] = !1, r["SHADOWCUBE" + s] = !1, r["SHADOWLOWQUALITY" + s] = !1, r["SHADOWMEDIUMQUALITY" + s] = !1, t && t.receiveShadows && e.shadowsEnabled && i.shadowEnabled) {
      const h = (o = i.getShadowGenerator(e.activeCamera)) !== null && o !== void 0 ? o : i.getShadowGenerator();
      if (h) {
        const l = h.getShadowMap();
        l && l.renderList && l.renderList.length > 0 && (a.shadowEnabled = !0, h.prepareDefines(r, s));
      }
    }
    i.lightmapMode != Ee.LIGHTMAP_DEFAULT ? (a.lightmapMode = !0, r["LIGHTMAPEXCLUDED" + s] = !0, r["LIGHTMAPNOSPECULAR" + s] = i.lightmapMode == Ee.LIGHTMAP_SHADOWSONLY) : (r["LIGHTMAPEXCLUDED" + s] = !1, r["LIGHTMAPNOSPECULAR" + s] = !1);
  }
  static PrepareDefinesForLights(e, t, i, s, r = 4, n = !1) {
    if (!i._areLightsDirty)
      return i._needNormals;
    let a = 0;
    const o = {
      needNormals: i._needNormals,
      needRebuild: !1,
      lightmapMode: !1,
      shadowEnabled: !1,
      specularEnabled: !1
    };
    if (e.lightsEnabled && !n) {
      for (const l of t.lightSources)
        if (this.PrepareDefinesForLight(e, t, l, a, i, s, o), a++, a === r)
          break;
    }
    i.SPECULARTERM = o.specularEnabled, i.SHADOWS = o.shadowEnabled;
    for (let l = a; l < r; l++)
      i["LIGHT" + l] !== void 0 && (i["LIGHT" + l] = !1, i["HEMILIGHT" + l] = !1, i["POINTLIGHT" + l] = !1, i["DIRLIGHT" + l] = !1, i["SPOTLIGHT" + l] = !1, i["SHADOW" + l] = !1, i["SHADOWCSM" + l] = !1, i["SHADOWCSMDEBUG" + l] = !1, i["SHADOWCSMNUM_CASCADES" + l] = !1, i["SHADOWCSMUSESHADOWMAXZ" + l] = !1, i["SHADOWCSMNOBLEND" + l] = !1, i["SHADOWCSM_RIGHTHANDED" + l] = !1, i["SHADOWPCF" + l] = !1, i["SHADOWPCSS" + l] = !1, i["SHADOWPOISSON" + l] = !1, i["SHADOWESM" + l] = !1, i["SHADOWCLOSEESM" + l] = !1, i["SHADOWCUBE" + l] = !1, i["SHADOWLOWQUALITY" + l] = !1, i["SHADOWMEDIUMQUALITY" + l] = !1);
    const h = e.getEngine().getCaps();
    return i.SHADOWFLOAT === void 0 && (o.needRebuild = !0), i.SHADOWFLOAT = o.shadowEnabled && (h.textureFloatRender && h.textureFloatLinearFiltering || h.textureHalfFloatRender && h.textureHalfFloatLinearFiltering), i.LIGHTMAPEXCLUDED = o.lightmapMode, o.needRebuild && i.rebuild(), o.needNormals;
  }
  static PrepareUniformsAndSamplersForLight(e, t, i, s, r = null, n = !1) {
    r && r.push("Light" + e), !n && (t.push("vLightData" + e, "vLightDiffuse" + e, "vLightSpecular" + e, "vLightDirection" + e, "vLightFalloff" + e, "vLightGround" + e, "lightMatrix" + e, "shadowsInfo" + e, "depthValues" + e), i.push("shadowSampler" + e), i.push("depthSampler" + e), t.push("viewFrustumZ" + e, "cascadeBlendFactor" + e, "lightSizeUVCorrection" + e, "depthCorrection" + e, "penumbraDarkness" + e, "frustumLengths" + e), s && (i.push("projectionLightSampler" + e), t.push("textureProjectionMatrix" + e)));
  }
  static PrepareUniformsAndSamplersList(e, t, i, s = 4) {
    let r, n = null;
    if (e.uniformsNames) {
      const a = e;
      r = a.uniformsNames, n = a.uniformBuffersNames, t = a.samplers, i = a.defines, s = a.maxSimultaneousLights || 0;
    } else
      r = e, t || (t = []);
    for (let a = 0; a < s && i["LIGHT" + a]; a++)
      this.PrepareUniformsAndSamplersForLight(a, r, t, i["PROJECTEDLIGHTTEXTURE" + a], n);
    i.NUM_MORPH_INFLUENCERS && r.push("morphTargetInfluences"), i.BAKED_VERTEX_ANIMATION_TEXTURE && (r.push("bakedVertexAnimationSettings"), r.push("bakedVertexAnimationTextureSizeInverted"), r.push("bakedVertexAnimationTime"), t.push("bakedVertexAnimationTexture"));
  }
  static HandleFallbacksForShadows(e, t, i = 4, s = 0) {
    let r = 0;
    for (let n = 0; n < i && e["LIGHT" + n]; n++)
      n > 0 && (r = s + n, t.addFallback(r, "LIGHT" + n)), e.SHADOWS || (e["SHADOW" + n] && t.addFallback(s, "SHADOW" + n), e["SHADOWPCF" + n] && t.addFallback(s, "SHADOWPCF" + n), e["SHADOWPCSS" + n] && t.addFallback(s, "SHADOWPCSS" + n), e["SHADOWPOISSON" + n] && t.addFallback(s, "SHADOWPOISSON" + n), e["SHADOWESM" + n] && t.addFallback(s, "SHADOWESM" + n), e["SHADOWCLOSEESM" + n] && t.addFallback(s, "SHADOWCLOSEESM" + n));
    return r++;
  }
  static PrepareAttributesForMorphTargetsInfluencers(e, t, i) {
    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = i, this.PrepareAttributesForMorphTargets(e, t, this._TmpMorphInfluencers);
  }
  static PrepareAttributesForMorphTargets(e, t, i) {
    const s = i.NUM_MORPH_INFLUENCERS;
    if (s > 0 && fe.LastCreatedEngine) {
      const r = fe.LastCreatedEngine.getCaps().maxVertexAttribs, n = t.morphTargetManager;
      if (n != null && n.isUsingTextureForTargets)
        return;
      const a = n && n.supportsNormals && i.NORMAL, o = n && n.supportsTangents && i.TANGENT, h = n && n.supportsUVs && i.UV1;
      for (let l = 0; l < s; l++)
        e.push(g.PositionKind + l), a && e.push(g.NormalKind + l), o && e.push(g.TangentKind + l), h && e.push(g.UVKind + "_" + l), e.length > r && O.Error("Cannot add more vertex attributes for mesh " + t.name);
    }
  }
  static PrepareAttributesForBakedVertexAnimation(e, t, i) {
    i.BAKED_VERTEX_ANIMATION_TEXTURE && i.INSTANCES && e.push("bakedVertexAnimationSettingsInstanced");
  }
  static PrepareAttributesForBones(e, t, i, s) {
    i.NUM_BONE_INFLUENCERS > 0 && (s.addCPUSkinningFallback(0, t), e.push(g.MatricesIndicesKind), e.push(g.MatricesWeightsKind), i.NUM_BONE_INFLUENCERS > 4 && (e.push(g.MatricesIndicesExtraKind), e.push(g.MatricesWeightsExtraKind)));
  }
  static PrepareAttributesForInstances(e, t) {
    (t.INSTANCES || t.THIN_INSTANCES) && this.PushAttributesForInstances(e, !!t.PREPASS_VELOCITY), t.INSTANCESCOLOR && e.push(g.ColorInstanceKind);
  }
  static PushAttributesForInstances(e, t = !1) {
    e.push("world0"), e.push("world1"), e.push("world2"), e.push("world3"), t && (e.push("previousWorld0"), e.push("previousWorld1"), e.push("previousWorld2"), e.push("previousWorld3"));
  }
  static BindLightProperties(e, t, i) {
    e.transferToEffect(t, i + "");
  }
  static BindLight(e, t, i, s, r, n = !0) {
    e._bindLight(t, i, s, r, n);
  }
  static BindLights(e, t, i, s, r = 4) {
    const n = Math.min(t.lightSources.length, r);
    for (let a = 0; a < n; a++) {
      const o = t.lightSources[a];
      this.BindLight(o, a, e, i, typeof s == "boolean" ? s : s.SPECULARTERM, t.receiveShadows);
    }
  }
  static BindFogParameters(e, t, i, s = !1) {
    e.fogEnabled && t.applyFog && e.fogMode !== re.FOGMODE_NONE && (i.setFloat4("vFogInfos", e.fogMode, e.fogStart, e.fogEnd, e.fogDensity), s ? (e.fogColor.toLinearSpaceToRef(this._TempFogColor), i.setColor3("vFogColor", this._TempFogColor)) : i.setColor3("vFogColor", e.fogColor));
  }
  static BindBonesParameters(e, t, i) {
    if (!(!t || !e) && (e.computeBonesUsingShaders && t._bonesComputationForcedToCPU && (e.computeBonesUsingShaders = !1), e.useBones && e.computeBonesUsingShaders && e.skeleton)) {
      const s = e.skeleton;
      if (s.isUsingTextureForMatrices && t.getUniformIndex("boneTextureWidth") > -1) {
        const r = s.getTransformMatrixTexture(e);
        t.setTexture("boneSampler", r), t.setFloat("boneTextureWidth", 4 * (s.bones.length + 1));
      } else {
        const r = s.getTransformMatrices(e);
        r && (t.setMatrices("mBones", r), i && e.getScene().prePassRenderer && e.getScene().prePassRenderer.getIndex(2) && (i.previousBones[e.uniqueId] || (i.previousBones[e.uniqueId] = r.slice()), t.setMatrices("mPreviousBones", i.previousBones[e.uniqueId]), te._CopyBonesTransformationMatrices(r, i.previousBones[e.uniqueId])));
      }
    }
  }
  static _CopyBonesTransformationMatrices(e, t) {
    return t.set(e), t;
  }
  static BindMorphTargetParameters(e, t) {
    const i = e.morphTargetManager;
    !e || !i || t.setFloatArray("morphTargetInfluences", i.influences);
  }
  static BindLogDepth(e, t, i) {
    if (!e || e.LOGARITHMICDEPTH || e.indexOf && e.indexOf("LOGARITHMICDEPTH") >= 0) {
      const s = i.activeCamera;
      s.mode === q.ORTHOGRAPHIC_CAMERA && O.Error("Logarithmic depth is not compatible with orthographic cameras!", 20), t.setFloat("logarithmicDepthConstant", 2 / (Math.log(s.maxZ + 1) / Math.LN2));
    }
  }
}
te._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };
te._TempFogColor = se.Black();
class Xt {
  constructor() {
    this.reset();
  }
  reset() {
    this.enabled = !1, this.mask = 255, this.func = 519, this.funcRef = 1, this.funcMask = 255, this.opStencilFail = 7680, this.opDepthFail = 7680, this.opStencilDepthPass = 7681;
  }
  get func() {
    return this._func;
  }
  set func(e) {
    this._func = e;
  }
  get funcRef() {
    return this._funcRef;
  }
  set funcRef(e) {
    this._funcRef = e;
  }
  get funcMask() {
    return this._funcMask;
  }
  set funcMask(e) {
    this._funcMask = e;
  }
  get opStencilFail() {
    return this._opStencilFail;
  }
  set opStencilFail(e) {
    this._opStencilFail = e;
  }
  get opDepthFail() {
    return this._opDepthFail;
  }
  set opDepthFail(e) {
    this._opDepthFail = e;
  }
  get opStencilDepthPass() {
    return this._opStencilDepthPass;
  }
  set opStencilDepthPass(e) {
    this._opStencilDepthPass = e;
  }
  get mask() {
    return this._mask;
  }
  set mask(e) {
    this._mask = e;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled = e;
  }
  getClassName() {
    return "MaterialStencilState";
  }
  copyTo(e) {
    ae.Clone(() => e, this);
  }
  serialize() {
    return ae.Serialize(this);
  }
  parse(e, t, i) {
    ae.Parse(() => this, e, t, i);
  }
}
T([
  R()
], Xt.prototype, "func", null);
T([
  R()
], Xt.prototype, "funcRef", null);
T([
  R()
], Xt.prototype, "funcMask", null);
T([
  R()
], Xt.prototype, "opStencilFail", null);
T([
  R()
], Xt.prototype, "opDepthFail", null);
T([
  R()
], Xt.prototype, "opStencilDepthPass", null);
T([
  R()
], Xt.prototype, "mask", null);
T([
  R()
], Xt.prototype, "enabled", null);
var je;
(function(c) {
  c[c.Created = 1] = "Created", c[c.Disposed = 2] = "Disposed", c[c.GetDefineNames = 4] = "GetDefineNames", c[c.PrepareUniformBuffer = 8] = "PrepareUniformBuffer", c[c.IsReadyForSubMesh = 16] = "IsReadyForSubMesh", c[c.PrepareDefines = 32] = "PrepareDefines", c[c.BindForSubMesh = 64] = "BindForSubMesh", c[c.PrepareEffect = 128] = "PrepareEffect", c[c.GetAnimatables = 256] = "GetAnimatables", c[c.GetActiveTextures = 512] = "GetActiveTextures", c[c.HasTexture = 1024] = "HasTexture", c[c.FillRenderTargetTextures = 2048] = "FillRenderTargetTextures", c[c.HasRenderTargetTextures = 4096] = "HasRenderTargetTextures", c[c.HardBindForSubMesh = 8192] = "HardBindForSubMesh";
})(je || (je = {}));
class P {
  constructor(e, t, i) {
    this.shadowDepthWrapper = null, this.allowShaderHotSwapping = !0, this.metadata = null, this.reservedDataStore = null, this.checkReadyOnEveryCall = !1, this.checkReadyOnlyOnce = !1, this.state = "", this._alpha = 1, this._backFaceCulling = !0, this._cullBackFaces = !0, this._blockDirtyMechanism = !1, this.onCompiled = null, this.onError = null, this.getRenderTargetTextures = null, this.doNotSerialize = !1, this._storeEffectOnSubMeshes = !1, this.animations = null, this.onDisposeObservable = new w(), this._onDisposeObserver = null, this._onUnBindObservable = null, this._onBindObserver = null, this._alphaMode = 2, this._needDepthPrePass = !1, this.disableDepthWrite = !1, this.disableColorWrite = !1, this.forceDepthWrite = !1, this.depthFunction = 0, this.separateCullingPass = !1, this._fogEnabled = !0, this.pointSize = 1, this.zOffset = 0, this.zOffsetUnits = 0, this.stencil = new Xt(), this._useUBO = !1, this._fillMode = P.TriangleFillMode, this._cachedDepthWriteState = !1, this._cachedColorWriteState = !1, this._cachedDepthFunctionState = 0, this._indexInSceneMaterialArray = -1, this.meshMap = null, this._parentContainer = null, this._uniformBufferLayoutBuilt = !1, this._eventInfo = {}, this._callbackPluginEventGeneric = () => {
    }, this._callbackPluginEventIsReadyForSubMesh = () => {
    }, this._callbackPluginEventPrepareDefines = () => {
    }, this._callbackPluginEventPrepareDefinesBeforeAttributes = () => {
    }, this._callbackPluginEventHardBindForSubMesh = () => {
    }, this._callbackPluginEventBindForSubMesh = () => {
    }, this._callbackPluginEventHasRenderTargetTextures = () => {
    }, this._callbackPluginEventFillRenderTargetTextures = () => {
    }, this._forceAlphaTest = !1, this._transparencyMode = null, this.name = e;
    const s = t || fe.LastCreatedScene;
    !s || (this._scene = s, this._dirtyCallbacks = {}, this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this), this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this), this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this), this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this), this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this), this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this), this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this), this.id = e || X.RandomId(), this.uniqueId = this._scene.getUniqueId(), this._materialContext = this._scene.getEngine().createMaterialContext(), this._drawWrapper = new Ri(this._scene.getEngine(), !1), this._drawWrapper.materialContext = this._materialContext, this._scene.useRightHandedSystem ? this.sideOrientation = P.ClockWiseSideOrientation : this.sideOrientation = P.CounterClockWiseSideOrientation, this._uniformBuffer = new V(this._scene.getEngine(), void 0, void 0, e), this._useUBO = this.getScene().getEngine().supportsUniformBuffers, i || this._scene.addMaterial(this), this._scene.useMaterialMeshMap && (this.meshMap = {}), P.OnEventObservable.notifyObservers(this, je.Created));
  }
  get canRenderToMRT() {
    return !1;
  }
  set alpha(e) {
    if (this._alpha === e)
      return;
    const t = this._alpha;
    this._alpha = e, (t === 1 || e === 1) && this.markAsDirty(P.MiscDirtyFlag);
  }
  get alpha() {
    return this._alpha;
  }
  set backFaceCulling(e) {
    this._backFaceCulling !== e && (this._backFaceCulling = e, this.markAsDirty(P.TextureDirtyFlag));
  }
  get backFaceCulling() {
    return this._backFaceCulling;
  }
  set cullBackFaces(e) {
    this._cullBackFaces !== e && (this._cullBackFaces = e, this.markAsDirty(P.TextureDirtyFlag));
  }
  get cullBackFaces() {
    return this._cullBackFaces;
  }
  get blockDirtyMechanism() {
    return this._blockDirtyMechanism;
  }
  set blockDirtyMechanism(e) {
    this._blockDirtyMechanism !== e && (this._blockDirtyMechanism = e, e || this.markDirty());
  }
  atomicMaterialsUpdate(e) {
    this.blockDirtyMechanism = !0;
    try {
      e(this);
    } finally {
      this.blockDirtyMechanism = !1;
    }
  }
  get hasRenderTargetTextures() {
    return this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._eventInfo.hasRenderTargetTextures;
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  get onBindObservable() {
    return this._onBindObservable || (this._onBindObservable = new w()), this._onBindObservable;
  }
  set onBind(e) {
    this._onBindObserver && this.onBindObservable.remove(this._onBindObserver), this._onBindObserver = this.onBindObservable.add(e);
  }
  get onUnBindObservable() {
    return this._onUnBindObservable || (this._onUnBindObservable = new w()), this._onUnBindObservable;
  }
  get onEffectCreatedObservable() {
    return this._onEffectCreatedObservable || (this._onEffectCreatedObservable = new w()), this._onEffectCreatedObservable;
  }
  set alphaMode(e) {
    this._alphaMode !== e && (this._alphaMode = e, this.markAsDirty(P.TextureDirtyFlag));
  }
  get alphaMode() {
    return this._alphaMode;
  }
  set needDepthPrePass(e) {
    this._needDepthPrePass !== e && (this._needDepthPrePass = e, this._needDepthPrePass && (this.checkReadyOnEveryCall = !0));
  }
  get needDepthPrePass() {
    return this._needDepthPrePass;
  }
  get isPrePassCapable() {
    return !1;
  }
  set fogEnabled(e) {
    this._fogEnabled !== e && (this._fogEnabled = e, this.markAsDirty(P.MiscDirtyFlag));
  }
  get fogEnabled() {
    return this._fogEnabled;
  }
  get wireframe() {
    switch (this._fillMode) {
      case P.WireFrameFillMode:
      case P.LineListDrawMode:
      case P.LineLoopDrawMode:
      case P.LineStripDrawMode:
        return !0;
    }
    return this._scene.forceWireframe;
  }
  set wireframe(e) {
    this.fillMode = e ? P.WireFrameFillMode : P.TriangleFillMode;
  }
  get pointsCloud() {
    switch (this._fillMode) {
      case P.PointFillMode:
      case P.PointListDrawMode:
        return !0;
    }
    return this._scene.forcePointsCloud;
  }
  set pointsCloud(e) {
    this.fillMode = e ? P.PointFillMode : P.TriangleFillMode;
  }
  get fillMode() {
    return this._fillMode;
  }
  set fillMode(e) {
    this._fillMode !== e && (this._fillMode = e, this.markAsDirty(P.MiscDirtyFlag));
  }
  _getDrawWrapper() {
    return this._drawWrapper;
  }
  _setDrawWrapper(e) {
    this._drawWrapper = e;
  }
  toString(e) {
    return "Name: " + this.name;
  }
  getClassName() {
    return "Material";
  }
  get _isMaterial() {
    return !0;
  }
  get isFrozen() {
    return this.checkReadyOnlyOnce;
  }
  freeze() {
    this.markDirty(), this.checkReadyOnlyOnce = !0;
  }
  unfreeze() {
    this.markDirty(), this.checkReadyOnlyOnce = !1;
  }
  isReady(e, t) {
    return !0;
  }
  isReadyForSubMesh(e, t, i) {
    const s = t.materialDefines;
    return s ? (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = s, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), this._eventInfo.isReadyForSubMesh) : !1;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  getScene() {
    return this._scene;
  }
  get transparencyMode() {
    return this._transparencyMode;
  }
  set transparencyMode(e) {
    this._transparencyMode !== e && (this._transparencyMode = e, this._forceAlphaTest = e === P.MATERIAL_ALPHATESTANDBLEND, this._markAllSubMeshesAsTexturesAndMiscDirty());
  }
  get _disableAlphaBlending() {
    return this._transparencyMode === P.MATERIAL_OPAQUE || this._transparencyMode === P.MATERIAL_ALPHATEST;
  }
  needAlphaBlending() {
    return this._disableAlphaBlending ? !1 : this.alpha < 1;
  }
  needAlphaBlendingForMesh(e) {
    return e.visibility < 1 ? !0 : this._disableAlphaBlending ? !1 : e.hasVertexAlpha || this.needAlphaBlending();
  }
  needAlphaTesting() {
    return !!this._forceAlphaTest;
  }
  _shouldTurnAlphaTestOn(e) {
    return !this.needAlphaBlendingForMesh(e) && this.needAlphaTesting();
  }
  getAlphaTestTexture() {
    return null;
  }
  markDirty(e = !1) {
    const t = this.getScene().meshes;
    for (const i of t)
      if (!!i.subMeshes)
        for (const s of i.subMeshes)
          s.getMaterial() === this && (!s.effect || (s.effect._wasPreviouslyReady = !1, s.effect._wasPreviouslyUsingInstances = null, s.effect._forceRebindOnNextCall = e));
    e && this.markAsDirty(P.AllDirtyFlag);
  }
  _preBind(e, t = null) {
    const i = this._scene.getEngine(), r = (t == null ? this.sideOrientation : t) === P.ClockWiseSideOrientation;
    return i.enableEffect(e || this._getDrawWrapper()), i.setState(this.backFaceCulling, this.zOffset, !1, r, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits), r;
  }
  bind(e, t) {
  }
  buildUniformLayout() {
    const e = this._uniformBuffer;
    this._eventInfo.ubo = e, this._callbackPluginEventGeneric(je.PrepareUniformBuffer, this._eventInfo), e.create(), this._uniformBufferLayoutBuilt = !0;
  }
  bindForSubMesh(e, t, i) {
    const s = i.effect;
    !s || (this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), s._forceRebindOnNextCall = !1);
  }
  bindOnlyWorldMatrix(e) {
  }
  bindView(e) {
    this._useUBO ? this._needToBindSceneUbo = !0 : e.setMatrix("view", this.getScene().getViewMatrix());
  }
  bindViewProjection(e) {
    this._useUBO ? this._needToBindSceneUbo = !0 : (e.setMatrix("viewProjection", this.getScene().getTransformMatrix()), e.setMatrix("projection", this.getScene().getProjectionMatrix()));
  }
  bindEyePosition(e, t) {
    this._useUBO ? this._needToBindSceneUbo = !0 : this._scene.bindEyePosition(e, t);
  }
  _afterBind(e, t = null) {
    if (this._scene._cachedMaterial = this, this._needToBindSceneUbo && t && (this._needToBindSceneUbo = !1, te.BindSceneUniformBuffer(t, this.getScene().getSceneUniformBuffer()), this._scene.finalizeSceneUbo()), e ? this._scene._cachedVisibility = e.visibility : this._scene._cachedVisibility = 1, this._onBindObservable && e && this._onBindObservable.notifyObservers(e), this.disableDepthWrite) {
      const i = this._scene.getEngine();
      this._cachedDepthWriteState = i.getDepthWrite(), i.setDepthWrite(!1);
    }
    if (this.disableColorWrite) {
      const i = this._scene.getEngine();
      this._cachedColorWriteState = i.getColorWrite(), i.setColorWrite(!1);
    }
    if (this.depthFunction !== 0) {
      const i = this._scene.getEngine();
      this._cachedDepthFunctionState = i.getDepthFunction() || 0, i.setDepthFunction(this.depthFunction);
    }
  }
  unbind() {
    this._onUnBindObservable && this._onUnBindObservable.notifyObservers(this), this.depthFunction !== 0 && this._scene.getEngine().setDepthFunction(this._cachedDepthFunctionState), this.disableDepthWrite && this._scene.getEngine().setDepthWrite(this._cachedDepthWriteState), this.disableColorWrite && this._scene.getEngine().setColorWrite(this._cachedColorWriteState);
  }
  getAnimatables() {
    return this._eventInfo.animatables = [], this._callbackPluginEventGeneric(je.GetAnimatables, this._eventInfo), this._eventInfo.animatables;
  }
  getActiveTextures() {
    return this._eventInfo.activeTextures = [], this._callbackPluginEventGeneric(je.GetActiveTextures, this._eventInfo), this._eventInfo.activeTextures;
  }
  hasTexture(e) {
    return this._eventInfo.hasTexture = !1, this._eventInfo.texture = e, this._callbackPluginEventGeneric(je.HasTexture, this._eventInfo), this._eventInfo.hasTexture;
  }
  clone(e) {
    return null;
  }
  getBindedMeshes() {
    if (this.meshMap) {
      const e = new Array();
      for (const t in this.meshMap) {
        const i = this.meshMap[t];
        i && e.push(i);
      }
      return e;
    } else
      return this._scene.meshes.filter((t) => t.material === this);
  }
  forceCompilation(e, t, i, s) {
    const r = {
      clipPlane: !1,
      useInstances: !1,
      ...i
    }, n = this.getScene(), a = this.allowShaderHotSwapping;
    this.allowShaderHotSwapping = !1;
    const o = () => {
      if (!this._scene || !this._scene.getEngine())
        return;
      const h = n.clipPlane;
      if (r.clipPlane && (n.clipPlane = new xt(0, 0, 0, 1)), this._storeEffectOnSubMeshes) {
        let l = !0, u = null;
        if (e.subMeshes) {
          const d = new Et(0, 0, 0, 0, 0, e, void 0, !1, !1);
          d.materialDefines && (d.materialDefines._renderId = -1), this.isReadyForSubMesh(e, d, r.useInstances) || (d.effect && d.effect.getCompilationError() && d.effect.allFallbacksProcessed() ? u = d.effect.getCompilationError() : (l = !1, setTimeout(o, 16)));
        }
        l && (this.allowShaderHotSwapping = a, u && s && s(u), t && t(this));
      } else
        this.isReady() ? (this.allowShaderHotSwapping = a, t && t(this)) : setTimeout(o, 16);
      r.clipPlane && (n.clipPlane = h);
    };
    o();
  }
  forceCompilationAsync(e, t) {
    return new Promise((i, s) => {
      this.forceCompilation(e, () => {
        i();
      }, t, (r) => {
        s(r);
      });
    });
  }
  markAsDirty(e) {
    this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism || (P._DirtyCallbackArray.length = 0, e & P.TextureDirtyFlag && P._DirtyCallbackArray.push(P._TextureDirtyCallBack), e & P.LightDirtyFlag && P._DirtyCallbackArray.push(P._LightsDirtyCallBack), e & P.FresnelDirtyFlag && P._DirtyCallbackArray.push(P._FresnelDirtyCallBack), e & P.AttributesDirtyFlag && P._DirtyCallbackArray.push(P._AttributeDirtyCallBack), e & P.MiscDirtyFlag && P._DirtyCallbackArray.push(P._MiscDirtyCallBack), e & P.PrePassDirtyFlag && P._DirtyCallbackArray.push(P._PrePassDirtyCallBack), P._DirtyCallbackArray.length && this._markAllSubMeshesAsDirty(P._RunDirtyCallBacks), this.getScene().resetCachedMaterial());
  }
  resetDrawCache() {
    const e = this.getScene().meshes;
    for (const t of e)
      if (!!t.subMeshes)
        for (const i of t.subMeshes)
          i.getMaterial() === this && i.resetDrawCache();
  }
  _markAllSubMeshesAsDirty(e) {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism)
      return;
    const t = this.getScene().meshes;
    for (const i of t)
      if (!!i.subMeshes) {
        for (const s of i.subMeshes)
          if (s.getMaterial(!1) === this)
            for (const r of s._drawWrappers)
              !r || !r.defines || !r.defines.markAllAsDirty || this._materialContext === r.materialContext && e(r.defines);
      }
  }
  _markScenePrePassDirty() {
    if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism)
      return;
    const e = this.getScene().enablePrePassRenderer();
    e && e.markAsDirty();
  }
  _markAllSubMeshesAsAllDirty() {
    this._markAllSubMeshesAsDirty(P._AllDirtyCallBack);
  }
  _markAllSubMeshesAsImageProcessingDirty() {
    this._markAllSubMeshesAsDirty(P._ImageProcessingDirtyCallBack);
  }
  _markAllSubMeshesAsTexturesDirty() {
    this._markAllSubMeshesAsDirty(P._TextureDirtyCallBack);
  }
  _markAllSubMeshesAsFresnelDirty() {
    this._markAllSubMeshesAsDirty(P._FresnelDirtyCallBack);
  }
  _markAllSubMeshesAsFresnelAndMiscDirty() {
    this._markAllSubMeshesAsDirty(P._FresnelAndMiscDirtyCallBack);
  }
  _markAllSubMeshesAsLightsDirty() {
    this._markAllSubMeshesAsDirty(P._LightsDirtyCallBack);
  }
  _markAllSubMeshesAsAttributesDirty() {
    this._markAllSubMeshesAsDirty(P._AttributeDirtyCallBack);
  }
  _markAllSubMeshesAsMiscDirty() {
    this._markAllSubMeshesAsDirty(P._MiscDirtyCallBack);
  }
  _markAllSubMeshesAsPrePassDirty() {
    this._markAllSubMeshesAsDirty(P._MiscDirtyCallBack);
  }
  _markAllSubMeshesAsTexturesAndMiscDirty() {
    this._markAllSubMeshesAsDirty(P._TextureAndMiscDirtyCallBack);
  }
  setPrePassRenderer(e) {
    return !1;
  }
  dispose(e, t, i) {
    const s = this.getScene();
    if (s.stopAnimation(this), s.freeProcessedMaterials(), s.removeMaterial(this), this._eventInfo.forceDisposeTextures = t, this._callbackPluginEventGeneric(je.Disposed, this._eventInfo), this._parentContainer) {
      const r = this._parentContainer.materials.indexOf(this);
      r > -1 && this._parentContainer.materials.splice(r, 1), this._parentContainer = null;
    }
    if (i !== !0)
      if (this.meshMap)
        for (const r in this.meshMap) {
          const n = this.meshMap[r];
          n && (n.material = null, this.releaseVertexArrayObject(n, e));
        }
      else {
        const r = s.meshes;
        for (const n of r)
          n.material === this && !n.sourceMesh && (n.material = null, this.releaseVertexArrayObject(n, e));
      }
    this._uniformBuffer.dispose(), e && this._drawWrapper.effect && (this._storeEffectOnSubMeshes || this._drawWrapper.effect.dispose(), this._drawWrapper.effect = null), this.metadata = null, this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this._onBindObservable && this._onBindObservable.clear(), this._onUnBindObservable && this._onUnBindObservable.clear(), this._onEffectCreatedObservable && this._onEffectCreatedObservable.clear(), this._eventInfo && (this._eventInfo = {});
  }
  releaseVertexArrayObject(e, t) {
    if (e.geometry) {
      const i = e.geometry;
      if (this._storeEffectOnSubMeshes)
        for (const s of e.subMeshes)
          i._releaseVertexArrayObject(s.effect), t && s.effect && s.effect.dispose();
      else
        i._releaseVertexArrayObject(this._drawWrapper.effect);
    }
  }
  serialize() {
    const e = ae.Serialize(this);
    return e.stencil = this.stencil.serialize(), e.uniqueId = this.uniqueId, e;
  }
  static Parse(e, t, i) {
    if (!e.customType)
      e.customType = "BABYLON.StandardMaterial";
    else if (e.customType === "BABYLON.PBRMaterial" && e.overloadedAlbedo && (e.customType = "BABYLON.LegacyPBRMaterial", !BABYLON.LegacyPBRMaterial))
      return O.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library."), null;
    const r = X.Instantiate(e.customType).Parse(e, t, i);
    return r._loadedUniqueId = e.uniqueId, r;
  }
}
P.TriangleFillMode = 0;
P.WireFrameFillMode = 1;
P.PointFillMode = 2;
P.PointListDrawMode = 3;
P.LineListDrawMode = 4;
P.LineLoopDrawMode = 5;
P.LineStripDrawMode = 6;
P.TriangleStripDrawMode = 7;
P.TriangleFanDrawMode = 8;
P.ClockWiseSideOrientation = 0;
P.CounterClockWiseSideOrientation = 1;
P.TextureDirtyFlag = 1;
P.LightDirtyFlag = 2;
P.FresnelDirtyFlag = 4;
P.AttributesDirtyFlag = 8;
P.MiscDirtyFlag = 16;
P.PrePassDirtyFlag = 32;
P.AllDirtyFlag = 63;
P.MATERIAL_OPAQUE = 0;
P.MATERIAL_ALPHATEST = 1;
P.MATERIAL_ALPHABLEND = 2;
P.MATERIAL_ALPHATESTANDBLEND = 3;
P.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
P.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
P.OnEventObservable = new w();
P._AllDirtyCallBack = (c) => c.markAllAsDirty();
P._ImageProcessingDirtyCallBack = (c) => c.markAsImageProcessingDirty();
P._TextureDirtyCallBack = (c) => c.markAsTexturesDirty();
P._FresnelDirtyCallBack = (c) => c.markAsFresnelDirty();
P._MiscDirtyCallBack = (c) => c.markAsMiscDirty();
P._PrePassDirtyCallBack = (c) => c.markAsPrePassDirty();
P._LightsDirtyCallBack = (c) => c.markAsLightDirty();
P._AttributeDirtyCallBack = (c) => c.markAsAttributesDirty();
P._FresnelAndMiscDirtyCallBack = (c) => {
  P._FresnelDirtyCallBack(c), P._MiscDirtyCallBack(c);
};
P._TextureAndMiscDirtyCallBack = (c) => {
  P._TextureDirtyCallBack(c), P._MiscDirtyCallBack(c);
};
P._DirtyCallbackArray = [];
P._RunDirtyCallBacks = (c) => {
  for (const e of P._DirtyCallbackArray)
    e(c);
};
T([
  R()
], P.prototype, "id", void 0);
T([
  R()
], P.prototype, "uniqueId", void 0);
T([
  R()
], P.prototype, "name", void 0);
T([
  R()
], P.prototype, "metadata", void 0);
T([
  R()
], P.prototype, "checkReadyOnEveryCall", void 0);
T([
  R()
], P.prototype, "checkReadyOnlyOnce", void 0);
T([
  R()
], P.prototype, "state", void 0);
T([
  R("alpha")
], P.prototype, "_alpha", void 0);
T([
  R("backFaceCulling")
], P.prototype, "_backFaceCulling", void 0);
T([
  R("cullBackFaces")
], P.prototype, "_cullBackFaces", void 0);
T([
  R()
], P.prototype, "sideOrientation", void 0);
T([
  R("alphaMode")
], P.prototype, "_alphaMode", void 0);
T([
  R()
], P.prototype, "_needDepthPrePass", void 0);
T([
  R()
], P.prototype, "disableDepthWrite", void 0);
T([
  R()
], P.prototype, "disableColorWrite", void 0);
T([
  R()
], P.prototype, "forceDepthWrite", void 0);
T([
  R()
], P.prototype, "depthFunction", void 0);
T([
  R()
], P.prototype, "separateCullingPass", void 0);
T([
  R("fogEnabled")
], P.prototype, "_fogEnabled", void 0);
T([
  R()
], P.prototype, "pointSize", void 0);
T([
  R()
], P.prototype, "zOffset", void 0);
T([
  R()
], P.prototype, "zOffsetUnits", void 0);
T([
  R()
], P.prototype, "pointsCloud", null);
T([
  R()
], P.prototype, "fillMode", null);
T([
  R()
], P.prototype, "transparencyMode", null);
class Ai extends P {
  constructor(e, t) {
    super(e, t, !0), this._waitingSubMaterialsUniqueIds = [], this.getScene().multiMaterials.push(this), this.subMaterials = new Array(), this._storeEffectOnSubMeshes = !0;
  }
  get subMaterials() {
    return this._subMaterials;
  }
  set subMaterials(e) {
    this._subMaterials = e, this._hookArray(e);
  }
  getChildren() {
    return this.subMaterials;
  }
  _hookArray(e) {
    const t = e.push;
    e.push = (...s) => {
      const r = t.apply(e, s);
      return this._markAllSubMeshesAsTexturesDirty(), r;
    };
    const i = e.splice;
    e.splice = (s, r) => {
      const n = i.apply(e, [s, r]);
      return this._markAllSubMeshesAsTexturesDirty(), n;
    };
  }
  getSubMaterial(e) {
    return e < 0 || e >= this.subMaterials.length ? this.getScene().defaultMaterial : this.subMaterials[e];
  }
  getActiveTextures() {
    return super.getActiveTextures().concat(...this.subMaterials.map((e) => e ? e.getActiveTextures() : []));
  }
  hasTexture(e) {
    var t;
    if (super.hasTexture(e))
      return !0;
    for (let i = 0; i < this.subMaterials.length; i++)
      if (!((t = this.subMaterials[i]) === null || t === void 0) && t.hasTexture(e))
        return !0;
    return !1;
  }
  getClassName() {
    return "MultiMaterial";
  }
  isReadyForSubMesh(e, t, i) {
    for (let s = 0; s < this.subMaterials.length; s++) {
      const r = this.subMaterials[s];
      if (r) {
        if (r._storeEffectOnSubMeshes) {
          if (!r.isReadyForSubMesh(e, t, i))
            return !1;
          continue;
        }
        if (!r.isReady(e))
          return !1;
      }
    }
    return !0;
  }
  clone(e, t) {
    const i = new Ai(e, this.getScene());
    for (let s = 0; s < this.subMaterials.length; s++) {
      let r = null;
      const n = this.subMaterials[s];
      t && n ? r = n.clone(e + "-" + n.name) : r = this.subMaterials[s], i.subMaterials.push(r);
    }
    return i;
  }
  serialize() {
    const e = {};
    e.name = this.name, e.id = this.id, e.uniqueId = this.uniqueId, pe && (e.tags = pe.GetTags(this)), e.materialsUniqueIds = [], e.materials = [];
    for (let t = 0; t < this.subMaterials.length; t++) {
      const i = this.subMaterials[t];
      i ? (e.materialsUniqueIds.push(i.uniqueId), e.materials.push(i.id)) : (e.materialsUniqueIds.push(null), e.materials.push(null));
    }
    return e;
  }
  dispose(e, t, i) {
    const s = this.getScene();
    if (!s)
      return;
    if (i)
      for (let n = 0; n < this.subMaterials.length; n++) {
        const a = this.subMaterials[n];
        a && a.dispose(e, t);
      }
    const r = s.multiMaterials.indexOf(this);
    r >= 0 && s.multiMaterials.splice(r, 1), super.dispose(e, t);
  }
  static ParseMultiMaterial(e, t) {
    const i = new Ai(e.name, t);
    return i.id = e.id, i._loadedUniqueId = e.uniqueId, pe && pe.AddTagsTo(i, e.tags), e.materialsUniqueIds ? i._waitingSubMaterialsUniqueIds = e.materialsUniqueIds : e.materials.forEach((s) => i.subMaterials.push(t.getLastMaterialById(s))), i;
  }
}
st("BABYLON.MultiMaterial", Ai);
class Kn {
  constructor(e, t) {
    this.distanceOrScreenCoverage = e, this.mesh = t;
  }
}
class Yn {
  constructor() {
    this.visibleInstances = {}, this.batchCache = new fr(), this.batchCacheReplacementModeInFrozenMode = new fr(), this.instancesBufferSize = 32 * 16 * 4;
  }
}
class fr {
  constructor() {
    this.mustReturn = !1, this.visibleInstances = new Array(), this.renderSelf = new Array(), this.hardwareInstancedRendering = new Array();
  }
}
class Zn {
  constructor() {
    this.instancesCount = 0, this.matrixBuffer = null, this.previousMatrixBuffer = null, this.matrixBufferSize = 32 * 16, this.matrixData = null, this.boundingVectors = [], this.worldMatrices = null;
  }
}
class qn {
  constructor() {
    this._areNormalsFrozen = !1, this._source = null, this.meshMap = null, this._preActivateId = -1, this._LODLevels = new Array(), this._useLODScreenCoverage = !1, this._effectiveMaterial = null, this._forcedInstanceCount = 0;
  }
}
class W extends ot {
  constructor(e, t = null, i = null, s = null, r, n = !0) {
    if (super(e, t), this._internalMeshDataInfo = new qn(), this.delayLoadState = 0, this.instances = new Array(), this._creationDataStorage = null, this._geometry = null, this._instanceDataStorage = new Yn(), this._thinInstanceDataStorage = new Zn(), this._shouldGenerateFlatShading = !1, this._originalBuilderSideOrientation = W.DEFAULTSIDE, this.overrideMaterialSideOrientation = null, this.ignoreCameraMaxZ = !1, t = this.getScene(), this._onBeforeDraw = (a, o, h) => {
      a && h && (this._uniformBuffer ? this.transferToEffect(o) : h.bindOnlyWorldMatrix(o));
    }, s) {
      if (s._geometry && s._geometry.applyToMesh(this), Us.DeepCopy(s, this, [
        "name",
        "material",
        "skeleton",
        "instances",
        "parent",
        "uniqueId",
        "source",
        "metadata",
        "morphTargetManager",
        "hasInstances",
        "worldMatrixInstancedBuffer",
        "previousWorldMatrixInstancedBuffer",
        "hasLODLevels",
        "geometry",
        "isBlocked",
        "areNormalsFrozen",
        "facetNb",
        "isFacetDataEnabled",
        "lightSources",
        "useBones",
        "isAnInstance",
        "collider",
        "edgesRenderer",
        "forward",
        "up",
        "right",
        "absolutePosition",
        "absoluteScaling",
        "absoluteRotationQuaternion",
        "isWorldMatrixFrozen",
        "nonUniformScaling",
        "behaviors",
        "worldMatrixFromCache",
        "hasThinInstances",
        "cloneMeshMap",
        "hasBoundingInfo"
      ], ["_poseMatrix"]), this._internalMeshDataInfo._source = s, t.useClonedMeshMap && (s._internalMeshDataInfo.meshMap || (s._internalMeshDataInfo.meshMap = {}), s._internalMeshDataInfo.meshMap[this.uniqueId] = this), this._originalBuilderSideOrientation = s._originalBuilderSideOrientation, this._creationDataStorage = s._creationDataStorage, s._ranges) {
        const a = s._ranges;
        for (const o in a)
          !Object.prototype.hasOwnProperty.call(a, o) || !a[o] || this.createAnimationRange(o, a[o].from, a[o].to);
      }
      if (s.metadata && s.metadata.clone ? this.metadata = s.metadata.clone() : this.metadata = s.metadata, pe && pe.HasTags(s) && pe.AddTagsTo(this, pe.GetTags(s, !0)), this.setEnabled(s.isEnabled(!1)), this.parent = s.parent, this.setPivotMatrix(s.getPivotMatrix()), this.id = e + "." + s.id, this.material = s.material, !r) {
        const a = s.getDescendants(!0);
        for (let o = 0; o < a.length; o++) {
          const h = a[o];
          h.clone && h.clone(e + "." + h.name, this);
        }
      }
      if (s.morphTargetManager && (this.morphTargetManager = s.morphTargetManager), t.getPhysicsEngine) {
        const a = t.getPhysicsEngine();
        if (n && a && a.getPluginVersion() === 1) {
          const o = a.getImpostorForPhysicsObject(s);
          o && (this.physicsImpostor = o.clone(this));
        }
      }
      for (let a = 0; a < t.particleSystems.length; a++) {
        const o = t.particleSystems[a];
        o.emitter === s && o.clone(o.name, this);
      }
      this.skeleton = s.skeleton, this.refreshBoundingInfo(!0, !0), this.computeWorldMatrix(!0);
    }
    i !== null && (this.parent = i), this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays, this._internalMeshDataInfo._onMeshReadyObserverAdded = (a) => {
      a.unregisterOnNextCall = !0, this.isReady(!0) ? this.onMeshReadyObservable.notifyObservers(this) : this._internalMeshDataInfo._checkReadinessObserver || (this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {
        this.isReady(!0) && (this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), this._internalMeshDataInfo._checkReadinessObserver = null, this.onMeshReadyObservable.notifyObservers(this));
      }));
    }, this.onMeshReadyObservable = new w(this._internalMeshDataInfo._onMeshReadyObserverAdded), s && s.onClonedObservable.notifyObservers(this);
  }
  static _GetDefaultSideOrientation(e) {
    return e || W.FRONTSIDE;
  }
  get useLODScreenCoverage() {
    return this._internalMeshDataInfo._useLODScreenCoverage;
  }
  set useLODScreenCoverage(e) {
    this._internalMeshDataInfo._useLODScreenCoverage = e, this._sortLODLevels();
  }
  get computeBonesUsingShaders() {
    return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
  }
  set computeBonesUsingShaders(e) {
    this._internalAbstractMeshDataInfo._computeBonesUsingShaders !== e && (e && this._internalMeshDataInfo._sourcePositions && (this.setVerticesData(g.PositionKind, this._internalMeshDataInfo._sourcePositions, !0), this._internalMeshDataInfo._sourceNormals && this.setVerticesData(g.NormalKind, this._internalMeshDataInfo._sourceNormals, !0), this._internalMeshDataInfo._sourcePositions = null, this._internalMeshDataInfo._sourceNormals = null), this._internalAbstractMeshDataInfo._computeBonesUsingShaders = e, this._markSubMeshesAsAttributesDirty());
  }
  get onBeforeRenderObservable() {
    return this._internalMeshDataInfo._onBeforeRenderObservable || (this._internalMeshDataInfo._onBeforeRenderObservable = new w()), this._internalMeshDataInfo._onBeforeRenderObservable;
  }
  get onBeforeBindObservable() {
    return this._internalMeshDataInfo._onBeforeBindObservable || (this._internalMeshDataInfo._onBeforeBindObservable = new w()), this._internalMeshDataInfo._onBeforeBindObservable;
  }
  get onAfterRenderObservable() {
    return this._internalMeshDataInfo._onAfterRenderObservable || (this._internalMeshDataInfo._onAfterRenderObservable = new w()), this._internalMeshDataInfo._onAfterRenderObservable;
  }
  get onBetweenPassObservable() {
    return this._internalMeshDataInfo._onBetweenPassObservable || (this._internalMeshDataInfo._onBetweenPassObservable = new w()), this._internalMeshDataInfo._onBetweenPassObservable;
  }
  get onBeforeDrawObservable() {
    return this._internalMeshDataInfo._onBeforeDrawObservable || (this._internalMeshDataInfo._onBeforeDrawObservable = new w()), this._internalMeshDataInfo._onBeforeDrawObservable;
  }
  set onBeforeDraw(e) {
    this._onBeforeDrawObserver && this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver), this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(e);
  }
  get hasInstances() {
    return this.instances.length > 0;
  }
  get hasThinInstances() {
    var e;
    return ((e = this._thinInstanceDataStorage.instancesCount) !== null && e !== void 0 ? e : 0) > 0;
  }
  get forcedInstanceCount() {
    return this._internalMeshDataInfo._forcedInstanceCount;
  }
  set forcedInstanceCount(e) {
    this._internalMeshDataInfo._forcedInstanceCount = e;
  }
  get source() {
    return this._internalMeshDataInfo._source;
  }
  get cloneMeshMap() {
    return this._internalMeshDataInfo.meshMap;
  }
  get isUnIndexed() {
    return this._unIndexed;
  }
  set isUnIndexed(e) {
    this._unIndexed !== e && (this._unIndexed = e, this._markSubMeshesAsAttributesDirty());
  }
  get worldMatrixInstancedBuffer() {
    return this._instanceDataStorage.instancesData;
  }
  get previousWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.instancesPreviousData;
  }
  get manualUpdateOfWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.manualUpdate;
  }
  set manualUpdateOfWorldMatrixInstancedBuffer(e) {
    this._instanceDataStorage.manualUpdate = e;
  }
  get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
    return this._instanceDataStorage.previousManualUpdate;
  }
  set manualUpdateOfPreviousWorldMatrixInstancedBuffer(e) {
    this._instanceDataStorage.previousManualUpdate = e;
  }
  get forceWorldMatrixInstancedBufferUpdate() {
    return this._instanceDataStorage.forceMatrixUpdates;
  }
  set forceWorldMatrixInstancedBufferUpdate(e) {
    this._instanceDataStorage.forceMatrixUpdates = e;
  }
  instantiateHierarchy(e = null, t, i) {
    const s = this.getTotalVertices() === 0 || t && t.doNotInstantiate && (t.doNotInstantiate === !0 || t.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), e || this.parent, !0) : this.createInstance("instance of " + (this.name || this.id));
    s.parent = e || this.parent, s.position = this.position.clone(), s.scaling = this.scaling.clone(), this.rotationQuaternion ? s.rotationQuaternion = this.rotationQuaternion.clone() : s.rotation = this.rotation.clone(), i && i(this, s);
    for (const r of this.getChildTransformNodes(!0))
      r.getClassName() === "InstancedMesh" && s.getClassName() === "Mesh" ? r.instantiateHierarchy(s, {
        doNotInstantiate: t && t.doNotInstantiate || !1,
        newSourcedMesh: s
      }, i) : r.instantiateHierarchy(s, t, i);
    return s;
  }
  getClassName() {
    return "Mesh";
  }
  get _isMesh() {
    return !0;
  }
  toString(e) {
    let t = super.toString(e);
    if (t += ", n vertices: " + this.getTotalVertices(), t += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE"), this.animations)
      for (let i = 0; i < this.animations.length; i++)
        t += ", animation[0]: " + this.animations[i].toString(e);
    if (e)
      if (this._geometry) {
        const i = this.getIndices(), s = this.getVerticesData(g.PositionKind);
        s && i && (t += ", flat shading: " + (s.length / 3 === i.length ? "YES" : "NO"));
      } else
        t += ", flat shading: UNKNOWN";
    return t;
  }
  _unBindEffect() {
    super._unBindEffect();
    for (const e of this.instances)
      e._unBindEffect();
  }
  get hasLODLevels() {
    return this._internalMeshDataInfo._LODLevels.length > 0;
  }
  getLODLevels() {
    return this._internalMeshDataInfo._LODLevels;
  }
  _sortLODLevels() {
    const e = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
    this._internalMeshDataInfo._LODLevels.sort((t, i) => t.distanceOrScreenCoverage < i.distanceOrScreenCoverage ? e : t.distanceOrScreenCoverage > i.distanceOrScreenCoverage ? -e : 0);
  }
  addLODLevel(e, t) {
    if (t && t._masterMesh)
      return O.Warn("You cannot use a mesh as LOD level twice"), this;
    const i = new Kn(e, t);
    return this._internalMeshDataInfo._LODLevels.push(i), t && (t._masterMesh = this), this._sortLODLevels(), this;
  }
  getLODLevelAtDistance(e) {
    const t = this._internalMeshDataInfo;
    for (let i = 0; i < t._LODLevels.length; i++) {
      const s = t._LODLevels[i];
      if (s.distanceOrScreenCoverage === e)
        return s.mesh;
    }
    return null;
  }
  removeLODLevel(e) {
    const t = this._internalMeshDataInfo;
    for (let i = 0; i < t._LODLevels.length; i++)
      t._LODLevels[i].mesh === e && (t._LODLevels.splice(i, 1), e && (e._masterMesh = null));
    return this._sortLODLevels(), this;
  }
  getLOD(e, t) {
    const i = this._internalMeshDataInfo;
    if (!i._LODLevels || i._LODLevels.length === 0)
      return this;
    const s = t || this.getBoundingInfo().boundingSphere, r = e.mode === q.ORTHOGRAPHIC_CAMERA ? e.minZ : s.centerWorld.subtract(e.globalPosition).length();
    let n = r, a = 1;
    if (i._useLODScreenCoverage) {
      const o = e.screenArea;
      let h = s.radiusWorld * e.minZ / r;
      h = h * h * Math.PI, n = h / o, a = -1;
    }
    if (a * i._LODLevels[i._LODLevels.length - 1].distanceOrScreenCoverage > a * n)
      return this.onLODLevelSelection && this.onLODLevelSelection(n, this, this), this;
    for (let o = 0; o < i._LODLevels.length; o++) {
      const h = i._LODLevels[o];
      if (a * h.distanceOrScreenCoverage < a * n) {
        if (h.mesh) {
          if (h.mesh.delayLoadState === 4)
            return h.mesh._checkDelayState(), this;
          if (h.mesh.delayLoadState === 2)
            return this;
          h.mesh._preActivate(), h.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        }
        return this.onLODLevelSelection && this.onLODLevelSelection(n, this, h.mesh), h.mesh;
      }
    }
    return this.onLODLevelSelection && this.onLODLevelSelection(n, this, this), this;
  }
  get geometry() {
    return this._geometry;
  }
  getTotalVertices() {
    return this._geometry === null || this._geometry === void 0 ? 0 : this._geometry.getTotalVertices();
  }
  getVerticesData(e, t, i) {
    var s, r;
    if (!this._geometry)
      return null;
    let n = (r = (s = this._userInstancedBuffersStorage) === null || s === void 0 ? void 0 : s.vertexBuffers[e]) === null || r === void 0 ? void 0 : r.getFloatData(this._geometry.getTotalVertices(), i || t && this._geometry.meshes.length !== 1);
    return n || (n = this._geometry.getVerticesData(e, t, i)), n;
  }
  getVertexBuffer(e) {
    var t, i;
    return this._geometry ? (i = (t = this._userInstancedBuffersStorage) === null || t === void 0 ? void 0 : t.vertexBuffers[e]) !== null && i !== void 0 ? i : this._geometry.getVertexBuffer(e) : null;
  }
  isVerticesDataPresent(e) {
    var t;
    return this._geometry ? ((t = this._userInstancedBuffersStorage) === null || t === void 0 ? void 0 : t.vertexBuffers[e]) !== void 0 || this._geometry.isVerticesDataPresent(e) : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }
  isVertexBufferUpdatable(e) {
    var t, i;
    return this._geometry ? ((i = (t = this._userInstancedBuffersStorage) === null || t === void 0 ? void 0 : t.vertexBuffers[e]) === null || i === void 0 ? void 0 : i.isUpdatable()) || this._geometry.isVertexBufferUpdatable(e) : this._delayInfo ? this._delayInfo.indexOf(e) !== -1 : !1;
  }
  getVerticesDataKinds() {
    if (!this._geometry) {
      const t = new Array();
      return this._delayInfo && this._delayInfo.forEach(function(i) {
        t.push(i);
      }), t;
    }
    const e = this._geometry.getVerticesDataKinds();
    if (this._userInstancedBuffersStorage)
      for (const t in this._userInstancedBuffersStorage.vertexBuffers)
        e.push(t);
    return e;
  }
  getTotalIndices() {
    return this._geometry ? this._geometry.getTotalIndices() : 0;
  }
  getIndices(e, t) {
    return this._geometry ? this._geometry.getIndices(e, t) : [];
  }
  get isBlocked() {
    return this._masterMesh !== null && this._masterMesh !== void 0;
  }
  isReady(e = !1, t = !1) {
    var i, s, r, n, a, o;
    if (this.delayLoadState === 2 || !super.isReady(e))
      return !1;
    if (!this.subMeshes || this.subMeshes.length === 0 || !e)
      return !0;
    const h = this.getEngine(), l = this.getScene(), u = t || h.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
    this.computeWorldMatrix();
    const d = this.material || l.defaultMaterial;
    if (d) {
      if (d._storeEffectOnSubMeshes)
        for (const _ of this.subMeshes) {
          const E = _.getMaterial();
          if (E) {
            if (E._storeEffectOnSubMeshes) {
              if (!E.isReadyForSubMesh(this, _, u))
                return !1;
            } else if (!E.isReady(this, u))
              return !1;
          }
        }
      else if (!d.isReady(this, u))
        return !1;
    }
    const f = h.currentRenderPassId;
    for (const _ of this.lightSources) {
      const E = _.getShadowGenerators();
      if (!E)
        continue;
      const m = E.values();
      for (let v = m.next(); v.done !== !0; v = m.next()) {
        const S = v.value;
        if (S && (!(!((i = S.getShadowMap()) === null || i === void 0) && i.renderList) || ((s = S.getShadowMap()) === null || s === void 0 ? void 0 : s.renderList) && ((n = (r = S.getShadowMap()) === null || r === void 0 ? void 0 : r.renderList) === null || n === void 0 ? void 0 : n.indexOf(this)) !== -1)) {
          S.getShadowMap() && (h.currentRenderPassId = S.getShadowMap().renderPassId);
          for (const y of this.subMeshes)
            if (!S.isReady(y, u, (o = (a = y.getMaterial()) === null || a === void 0 ? void 0 : a.needAlphaBlendingForMesh(this)) !== null && o !== void 0 ? o : !1))
              return h.currentRenderPassId = f, !1;
          h.currentRenderPassId = f;
        }
      }
    }
    for (const _ of this._internalMeshDataInfo._LODLevels)
      if (_.mesh && !_.mesh.isReady(u))
        return !1;
    return !0;
  }
  get areNormalsFrozen() {
    return this._internalMeshDataInfo._areNormalsFrozen;
  }
  freezeNormals() {
    return this._internalMeshDataInfo._areNormalsFrozen = !0, this;
  }
  unfreezeNormals() {
    return this._internalMeshDataInfo._areNormalsFrozen = !1, this;
  }
  set overridenInstanceCount(e) {
    this._instanceDataStorage.overridenInstanceCount = e;
  }
  _preActivate() {
    const e = this._internalMeshDataInfo, t = this.getScene().getRenderId();
    return e._preActivateId === t ? this : (e._preActivateId = t, this._instanceDataStorage.visibleInstances = null, this);
  }
  _preActivateForIntermediateRendering(e) {
    return this._instanceDataStorage.visibleInstances && (this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = e), this;
  }
  _registerInstanceForRenderId(e, t) {
    return this._instanceDataStorage.visibleInstances || (this._instanceDataStorage.visibleInstances = {
      defaultRenderId: t,
      selfDefaultRenderId: this._renderId
    }), this._instanceDataStorage.visibleInstances[t] || (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen && (this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null), this._instanceDataStorage.previousRenderId = t, this._instanceDataStorage.visibleInstances[t] = new Array()), this._instanceDataStorage.visibleInstances[t].push(e), this;
  }
  _afterComputeWorldMatrix() {
    super._afterComputeWorldMatrix(), this.hasThinInstances && (this.doNotSyncBoundingInfo || this.thinInstanceRefreshBoundingInfo(!1));
  }
  _postActivate() {
    this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup && (this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer), this.edgesRenderer.customInstances.push(this.getWorldMatrix()));
  }
  refreshBoundingInfo(e = !1, t = !1) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked)
      return this;
    const i = this.geometry ? this.geometry.boundingBias : null;
    return this._refreshBoundingInfo(this._getPositionData(e, t), i), this;
  }
  _createGlobalSubMesh(e) {
    const t = this.getTotalVertices();
    if (!t || !this.getIndices())
      return null;
    if (this.subMeshes && this.subMeshes.length > 0) {
      const i = this.getIndices();
      if (!i)
        return null;
      const s = i.length;
      let r = !1;
      if (e)
        r = !0;
      else
        for (const n of this.subMeshes) {
          if (n.indexStart + n.indexCount > s) {
            r = !0;
            break;
          }
          if (n.verticesStart + n.verticesCount > t) {
            r = !0;
            break;
          }
        }
      if (!r)
        return this.subMeshes[0];
    }
    return this.releaseSubMeshes(), new Et(0, 0, t, 0, this.getTotalIndices(), this);
  }
  subdivide(e) {
    if (e < 1)
      return;
    const t = this.getTotalIndices();
    let i = t / e | 0, s = 0;
    for (; i % 3 !== 0; )
      i++;
    this.releaseSubMeshes();
    for (let r = 0; r < e && !(s >= t); r++)
      Et.CreateFromIndices(0, s, r === e - 1 ? t - s : i, this), s += i;
    this.synchronizeInstances();
  }
  setVerticesData(e, t, i = !1, s) {
    if (this._geometry)
      this._geometry.setVerticesData(e, t, i, s);
    else {
      const r = new J();
      r.set(t, e);
      const n = this.getScene();
      new at(at.RandomId(), n, r, i, this);
    }
    return this;
  }
  removeVerticesData(e) {
    !this._geometry || this._geometry.removeVerticesData(e);
  }
  markVerticesDataAsUpdatable(e, t = !0) {
    const i = this.getVertexBuffer(e);
    !i || i.isUpdatable() === t || this.setVerticesData(e, this.getVerticesData(e), t);
  }
  setVerticesBuffer(e, t = !0) {
    return this._geometry || (this._geometry = at.CreateGeometryForMesh(this)), this._geometry.setVerticesBuffer(e, null, t), this;
  }
  updateVerticesData(e, t, i, s) {
    return this._geometry ? (s ? (this.makeGeometryUnique(), this.updateVerticesData(e, t, i, !1)) : this._geometry.updateVerticesData(e, t, i), this) : this;
  }
  updateMeshPositions(e, t = !0) {
    const i = this.getVerticesData(g.PositionKind);
    if (!i)
      return this;
    if (e(i), this.updateVerticesData(g.PositionKind, i, !1, !1), t) {
      const s = this.getIndices(), r = this.getVerticesData(g.NormalKind);
      if (!r)
        return this;
      J.ComputeNormals(i, s, r), this.updateVerticesData(g.NormalKind, r, !1, !1);
    }
    return this;
  }
  makeGeometryUnique() {
    if (!this._geometry)
      return this;
    if (this._geometry.meshes.length === 1)
      return this;
    const e = this._geometry, t = this._geometry.copy(at.RandomId());
    return e.releaseForMesh(this, !0), t.applyToMesh(this), this;
  }
  setIndices(e, t = null, i = !1) {
    if (this._geometry)
      this._geometry.setIndices(e, t, i);
    else {
      const s = new J();
      s.indices = e;
      const r = this.getScene();
      new at(at.RandomId(), r, s, i, this);
    }
    return this;
  }
  updateIndices(e, t, i = !1) {
    return this._geometry ? (this._geometry.updateIndices(e, t, i), this) : this;
  }
  toLeftHanded() {
    return this._geometry ? (this._geometry.toLeftHanded(), this) : this;
  }
  _bind(e, t, i) {
    if (!this._geometry)
      return this;
    const s = this.getScene().getEngine();
    this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets && this.morphTargetManager._bind(t);
    let r;
    if (this._unIndexed)
      r = null;
    else
      switch (i) {
        case P.PointFillMode:
          r = null;
          break;
        case P.WireFrameFillMode:
          r = e._getLinesIndexBuffer(this.getIndices(), s);
          break;
        default:
        case P.TriangleFillMode:
          r = this._geometry.getIndexBuffer();
          break;
      }
    return !this._userInstancedBuffersStorage || this.hasThinInstances ? this._geometry._bind(t, r) : this._geometry._bind(t, r, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects), this;
  }
  _draw(e, t, i) {
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
      return this;
    this._internalMeshDataInfo._onBeforeDrawObservable && this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
    const r = this.getScene().getEngine();
    return this._unIndexed || t == P.PointFillMode ? r.drawArraysType(t, e.verticesStart, e.verticesCount, this.forcedInstanceCount || i) : t == P.WireFrameFillMode ? r.drawElementsType(t, 0, e._linesIndexCount, this.forcedInstanceCount || i) : r.drawElementsType(t, e.indexStart, e.indexCount, this.forcedInstanceCount || i), this;
  }
  registerBeforeRender(e) {
    return this.onBeforeRenderObservable.add(e), this;
  }
  unregisterBeforeRender(e) {
    return this.onBeforeRenderObservable.removeCallback(e), this;
  }
  registerAfterRender(e) {
    return this.onAfterRenderObservable.add(e), this;
  }
  unregisterAfterRender(e) {
    return this.onAfterRenderObservable.removeCallback(e), this;
  }
  _getInstancesRenderList(e, t = !1) {
    if (this._instanceDataStorage.isFrozen) {
      if (t)
        return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[e] = !1, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[e] = !0, this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
      if (this._instanceDataStorage.previousBatch)
        return this._instanceDataStorage.previousBatch;
    }
    const i = this.getScene(), s = i._isInIntermediateRendering(), r = s ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances, n = this._instanceDataStorage.batchCache;
    if (n.mustReturn = !1, n.renderSelf[e] = t || !r && this.isEnabled() && this.isVisible, n.visibleInstances[e] = null, this._instanceDataStorage.visibleInstances && !t) {
      const a = this._instanceDataStorage.visibleInstances, o = i.getRenderId(), h = s ? a.intermediateDefaultRenderId : a.defaultRenderId;
      n.visibleInstances[e] = a[o], !n.visibleInstances[e] && h && (n.visibleInstances[e] = a[h]);
    }
    return n.hardwareInstancedRendering[e] = !t && this._instanceDataStorage.hardwareInstancedRendering && n.visibleInstances[e] !== null && n.visibleInstances[e] !== void 0, this._instanceDataStorage.previousBatch = n, n;
  }
  _renderWithInstances(e, t, i, s, r) {
    var n;
    const a = i.visibleInstances[e._id], o = a ? a.length : 0, h = this._instanceDataStorage, l = h.instancesBufferSize;
    let u = h.instancesBuffer, d = h.instancesPreviousBuffer;
    const _ = (o + 1) * 16 * 4;
    for (; h.instancesBufferSize < _; )
      h.instancesBufferSize *= 2;
    (!h.instancesData || l != h.instancesBufferSize) && (h.instancesData = new Float32Array(h.instancesBufferSize / 4)), (this._scene.needsPreviousWorldMatrices && !h.instancesPreviousData || l != h.instancesBufferSize) && (h.instancesPreviousData = new Float32Array(h.instancesBufferSize / 4));
    let E = 0, m = 0;
    const v = i.renderSelf[e._id], S = !u || l !== h.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !h.instancesPreviousBuffer;
    if (!this._instanceDataStorage.manualUpdate && (!h.isFrozen || S)) {
      const y = this.getWorldMatrix();
      if (v && (this._scene.needsPreviousWorldMatrices && (h.masterMeshPreviousWorldMatrix ? (h.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData, E), h.masterMeshPreviousWorldMatrix.copyFrom(y)) : (h.masterMeshPreviousWorldMatrix = y.clone(), h.masterMeshPreviousWorldMatrix.copyToArray(h.instancesPreviousData, E))), y.copyToArray(h.instancesData, E), E += 16, m++), a) {
        if (W.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((n = e.getMaterial()) === null || n === void 0 ? void 0 : n.needAlphaBlendingForMesh(e.getRenderingMesh()))) {
          const A = this._scene.activeCamera.globalPosition;
          for (let C = 0; C < a.length; C++) {
            const b = a[C];
            b._distanceToCamera = p.Distance(b.getBoundingInfo().boundingSphere.centerWorld, A);
          }
          a.sort((C, b) => C._distanceToCamera > b._distanceToCamera ? -1 : C._distanceToCamera < b._distanceToCamera ? 1 : 0);
        }
        for (let A = 0; A < a.length; A++) {
          const C = a[A], b = C.getWorldMatrix();
          b.copyToArray(h.instancesData, E), this._scene.needsPreviousWorldMatrices && (C._previousWorldMatrix ? (C._previousWorldMatrix.copyToArray(h.instancesPreviousData, E), C._previousWorldMatrix.copyFrom(b)) : (C._previousWorldMatrix = b.clone(), C._previousWorldMatrix.copyToArray(h.instancesPreviousData, E))), E += 16, m++;
        }
      }
    } else
      m = (v ? 1 : 0) + o;
    return S ? (u && u.dispose(), d && d.dispose(), u = new es(r, h.instancesData, !0, 16, !1, !0), h.instancesBuffer = u, this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    }), this._userInstancedBuffersStorage.vertexBuffers.world0 = u.createVertexBuffer("world0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.world1 = u.createVertexBuffer("world1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.world2 = u.createVertexBuffer("world2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.world3 = u.createVertexBuffer("world3", 12, 4), this._scene.needsPreviousWorldMatrices && (d = new es(r, h.instancesPreviousData, !0, 16, !1, !0), h.instancesPreviousBuffer = d, this._userInstancedBuffersStorage.vertexBuffers.previousWorld0 = d.createVertexBuffer("previousWorld0", 0, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld1 = d.createVertexBuffer("previousWorld1", 4, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld2 = d.createVertexBuffer("previousWorld2", 8, 4), this._userInstancedBuffersStorage.vertexBuffers.previousWorld3 = d.createVertexBuffer("previousWorld3", 12, 4)), this._invalidateInstanceVertexArrayObject()) : (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && (u.updateDirectly(h.instancesData, 0, m), this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate) && d.updateDirectly(h.instancesPreviousData, 0, m)), this._processInstancedBuffers(a, v), this.getScene()._activeIndices.addCount(e.indexCount * m, !1), r._currentDrawContext && (r._currentDrawContext.useInstancing = !0), this._bind(e, s, t), this._draw(e, t, m), this._scene.needsPreviousWorldMatrices && !S && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate && d.updateDirectly(h.instancesData, 0, m), r.unbindInstanceAttributes(), this;
  }
  _renderWithThinInstances(e, t, i, s) {
    var r, n;
    const a = (n = (r = this._thinInstanceDataStorage) === null || r === void 0 ? void 0 : r.instancesCount) !== null && n !== void 0 ? n : 0;
    this.getScene()._activeIndices.addCount(e.indexCount * a, !1), s._currentDrawContext && (s._currentDrawContext.useInstancing = !0), this._bind(e, i, t), this._draw(e, t, a), this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData && (this._thinInstanceDataStorage.previousMatrixBuffer ? this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, a) : this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, !1)), s.unbindInstanceAttributes();
  }
  _processInstancedBuffers(e, t) {
  }
  _processRendering(e, t, i, s, r, n, a, o) {
    const h = this.getScene(), l = h.getEngine();
    if (n && t.getRenderingMesh().hasThinInstances)
      return this._renderWithThinInstances(t, s, i, l), this;
    if (n)
      this._renderWithInstances(t, s, r, i, l);
    else {
      l._currentDrawContext && (l._currentDrawContext.useInstancing = !1);
      let u = 0;
      r.renderSelf[t._id] && (a && a(!1, e.getWorldMatrix(), o), u++, this._draw(t, s, this._instanceDataStorage.overridenInstanceCount));
      const d = r.visibleInstances[t._id];
      if (d) {
        const f = d.length;
        u += f;
        for (let _ = 0; _ < f; _++) {
          const m = d[_].getWorldMatrix();
          a && a(!0, m, o), this._draw(t, s);
        }
      }
      h._activeIndices.addCount(t.indexCount * u, !1);
    }
    return this;
  }
  _rebuild(e = !1) {
    if (this._instanceDataStorage.instancesBuffer && (e && this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null), this._userInstancedBuffersStorage) {
      for (const t in this._userInstancedBuffersStorage.vertexBuffers) {
        const i = this._userInstancedBuffersStorage.vertexBuffers[t];
        i && (e && i.dispose(), this._userInstancedBuffersStorage.vertexBuffers[t] = null);
      }
      this._userInstancedBuffersStorage.vertexArrayObjects && (this._userInstancedBuffersStorage.vertexArrayObjects = {});
    }
    this._internalMeshDataInfo._effectiveMaterial = null, super._rebuild(e);
  }
  _freeze() {
    if (!!this.subMeshes) {
      for (let e = 0; e < this.subMeshes.length; e++)
        this._getInstancesRenderList(e);
      this._internalMeshDataInfo._effectiveMaterial = null, this._instanceDataStorage.isFrozen = !0;
    }
  }
  _unFreeze() {
    this._instanceDataStorage.isFrozen = !1, this._instanceDataStorage.previousBatch = null;
  }
  render(e, t, i) {
    var s, r, n;
    const a = this.getScene();
    if (this._internalAbstractMeshDataInfo._isActiveIntermediate ? this._internalAbstractMeshDataInfo._isActiveIntermediate = !1 : this._internalAbstractMeshDataInfo._isActive = !1, this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded)
      return this;
    const o = this._getInstancesRenderList(e._id, !!i);
    if (o.mustReturn)
      return this;
    if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer())
      return this;
    const h = a.getEngine();
    let l = 0, u = null;
    this.ignoreCameraMaxZ && a.activeCamera && !a._isInIntermediateRendering() && (l = a.activeCamera.maxZ, u = a.activeCamera, a.activeCamera.maxZ = 0, a.updateTransformMatrix(!0)), this._internalMeshDataInfo._onBeforeRenderObservable && this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
    const d = e.getRenderingMesh(), f = o.hardwareInstancedRendering[e._id] || d.hasThinInstances || !!this._userInstancedBuffersStorage && !e.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh, _ = this._instanceDataStorage, E = e.getMaterial();
    if (!E)
      return u && (u.maxZ = l, a.updateTransformMatrix(!0)), this;
    if (!_.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== E) {
      if (E._storeEffectOnSubMeshes) {
        if (!E.isReadyForSubMesh(this, e, f))
          return u && (u.maxZ = l, a.updateTransformMatrix(!0)), this;
      } else if (!E.isReady(this, f))
        return u && (u.maxZ = l, a.updateTransformMatrix(!0)), this;
      this._internalMeshDataInfo._effectiveMaterial = E;
    } else if (E._storeEffectOnSubMeshes && !(!((s = e.effect) === null || s === void 0) && s._wasPreviouslyReady) || !E._storeEffectOnSubMeshes && !(!((r = E.getEffect()) === null || r === void 0) && r._wasPreviouslyReady))
      return u && (u.maxZ = l, a.updateTransformMatrix(!0)), this;
    t && h.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
    let m;
    this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes ? m = e._drawWrapper : m = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
    const v = (n = m == null ? void 0 : m.effect) !== null && n !== void 0 ? n : null;
    for (const L of a._beforeRenderingMeshStage)
      L.action(this, e, o, v);
    if (!m || !v)
      return u && (u.maxZ = l, a.updateTransformMatrix(!0)), this;
    const S = i || this;
    let y;
    if (!_.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
      const L = S._getWorldMatrixDeterminant();
      y = this.overrideMaterialSideOrientation, y == null && (y = this._internalMeshDataInfo._effectiveMaterial.sideOrientation), L < 0 && (y = y === P.ClockWiseSideOrientation ? P.CounterClockWiseSideOrientation : P.ClockWiseSideOrientation), _.sideOrientation = y;
    } else
      y = _.sideOrientation;
    const A = this._internalMeshDataInfo._effectiveMaterial._preBind(m, y);
    this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite && h.setDepthWrite(!0);
    const C = a.forcePointsCloud ? P.PointFillMode : a.forceWireframe ? P.WireFrameFillMode : this._internalMeshDataInfo._effectiveMaterial.fillMode;
    this._internalMeshDataInfo._onBeforeBindObservable && this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this), f || this._bind(e, v, C);
    const b = this._internalMeshDataInfo._effectiveMaterial, M = S.getWorldMatrix();
    b._storeEffectOnSubMeshes ? b.bindForSubMesh(M, this, e) : b.bind(M, this), !b.backFaceCulling && b.separateCullingPass && (h.setState(!0, b.zOffset, !1, !A, b.cullBackFaces, b.stencil, b.zOffsetUnits), this._processRendering(this, e, v, C, o, f, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), h.setState(!0, b.zOffset, !1, A, b.cullBackFaces, b.stencil, b.zOffsetUnits), this._internalMeshDataInfo._onBetweenPassObservable && this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(e)), this._processRendering(this, e, v, C, o, f, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial), this._internalMeshDataInfo._effectiveMaterial.unbind();
    for (const L of a._afterRenderingMeshStage)
      L.action(this, e, o, v);
    return this._internalMeshDataInfo._onAfterRenderObservable && this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this), u && (u.maxZ = l, a.updateTransformMatrix(!0)), a.performancePriority === Ct.Aggressive && !_.isFrozen && this._freeze(), this;
  }
  cleanMatrixWeights() {
    this.isVerticesDataPresent(g.MatricesWeightsKind) && (this.isVerticesDataPresent(g.MatricesWeightsExtraKind) ? this._normalizeSkinWeightsAndExtra() : this._normalizeSkinFourWeights());
  }
  _normalizeSkinFourWeights() {
    const e = this.getVerticesData(g.MatricesWeightsKind), t = e.length;
    for (let i = 0; i < t; i += 4) {
      const s = e[i] + e[i + 1] + e[i + 2] + e[i + 3];
      if (s === 0)
        e[i] = 1;
      else {
        const r = 1 / s;
        e[i] *= r, e[i + 1] *= r, e[i + 2] *= r, e[i + 3] *= r;
      }
    }
    this.setVerticesData(g.MatricesWeightsKind, e);
  }
  _normalizeSkinWeightsAndExtra() {
    const e = this.getVerticesData(g.MatricesWeightsExtraKind), t = this.getVerticesData(g.MatricesWeightsKind), i = t.length;
    for (let s = 0; s < i; s += 4) {
      let r = t[s] + t[s + 1] + t[s + 2] + t[s + 3];
      if (r += e[s] + e[s + 1] + e[s + 2] + e[s + 3], r === 0)
        t[s] = 1;
      else {
        const n = 1 / r;
        t[s] *= n, t[s + 1] *= n, t[s + 2] *= n, t[s + 3] *= n, e[s] *= n, e[s + 1] *= n, e[s + 2] *= n, e[s + 3] *= n;
      }
    }
    this.setVerticesData(g.MatricesWeightsKind, t), this.setVerticesData(g.MatricesWeightsKind, e);
  }
  validateSkinning() {
    const e = this.getVerticesData(g.MatricesWeightsExtraKind), t = this.getVerticesData(g.MatricesWeightsKind);
    if (t === null || this.skeleton == null)
      return { skinned: !1, valid: !0, report: "not skinned" };
    const i = t.length;
    let s = 0, r = 0, n = 0, a = 0;
    const o = e === null ? 4 : 8, h = new Array();
    for (let m = 0; m <= o; m++)
      h[m] = 0;
    const l = 1e-3;
    for (let m = 0; m < i; m += 4) {
      let v = t[m], S = v, y = S === 0 ? 0 : 1;
      for (let A = 1; A < o; A++) {
        const C = A < 4 ? t[m + A] : e[m + A - 4];
        C > v && s++, C !== 0 && y++, S += C, v = C;
      }
      if (h[y]++, y > n && (n = y), S === 0)
        r++;
      else {
        const A = 1 / S;
        let C = 0;
        for (let b = 0; b < o; b++)
          b < 4 ? C += Math.abs(t[m + b] - t[m + b] * A) : C += Math.abs(e[m + b - 4] - e[m + b - 4] * A);
        C > l && a++;
      }
    }
    const u = this.skeleton.bones.length, d = this.getVerticesData(g.MatricesIndicesKind), f = this.getVerticesData(g.MatricesIndicesExtraKind);
    let _ = 0;
    for (let m = 0; m < i; m += 4)
      for (let v = 0; v < o; v++) {
        const S = v < 4 ? d[m + v] : f[m + v - 4];
        (S >= u || S < 0) && _++;
      }
    const E = "Number of Weights = " + i / 4 + `
Maximum influences = ` + n + `
Missing Weights = ` + r + `
Not Sorted = ` + s + `
Not Normalized = ` + a + `
WeightCounts = [` + h + `]
Number of bones = ` + u + `
Bad Bone Indices = ` + _;
    return { skinned: !0, valid: r === 0 && a === 0 && _ === 0, report: E };
  }
  _checkDelayState() {
    const e = this.getScene();
    return this._geometry ? this._geometry.load(e) : this.delayLoadState === 4 && (this.delayLoadState = 2, this._queueLoad(e)), this;
  }
  _queueLoad(e) {
    e.addPendingData(this);
    const t = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
    return X.LoadFile(this.delayLoadingFile, (i) => {
      i instanceof ArrayBuffer ? this._delayLoadingFunction(i, this) : this._delayLoadingFunction(JSON.parse(i), this), this.instances.forEach((s) => {
        s.refreshBoundingInfo(), s._syncSubMeshes();
      }), this.delayLoadState = 1, e.removePendingData(this);
    }, () => {
    }, e.offlineProvider, t), this;
  }
  isInFrustum(e) {
    return this.delayLoadState === 2 || !super.isInFrustum(e) ? !1 : (this._checkDelayState(), !0);
  }
  setMaterialById(e) {
    const t = this.getScene().materials;
    let i;
    for (i = t.length - 1; i > -1; i--)
      if (t[i].id === e)
        return this.material = t[i], this;
    const s = this.getScene().multiMaterials;
    for (i = s.length - 1; i > -1; i--)
      if (s[i].id === e)
        return this.material = s[i], this;
    return this;
  }
  getAnimatables() {
    const e = new Array();
    return this.material && e.push(this.material), this.skeleton && e.push(this.skeleton), e;
  }
  bakeTransformIntoVertices(e) {
    if (!this.isVerticesDataPresent(g.PositionKind))
      return this;
    const t = this.subMeshes.splice(0);
    this._resetPointsArrayCache();
    let i = this.getVerticesData(g.PositionKind);
    const s = p.Zero();
    let r;
    for (r = 0; r < i.length; r += 3)
      p.TransformCoordinatesFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).toArray(i, r);
    if (this.setVerticesData(g.PositionKind, i, this.getVertexBuffer(g.PositionKind).isUpdatable()), this.isVerticesDataPresent(g.NormalKind)) {
      for (i = this.getVerticesData(g.NormalKind), r = 0; r < i.length; r += 3)
        p.TransformNormalFromFloatsToRef(i[r], i[r + 1], i[r + 2], e, s).normalize().toArray(i, r);
      this.setVerticesData(g.NormalKind, i, this.getVertexBuffer(g.NormalKind).isUpdatable());
    }
    return e.determinant() < 0 && this.flipFaces(), this.releaseSubMeshes(), this.subMeshes = t, this;
  }
  bakeCurrentTransformIntoVertices(e = !0) {
    return this.bakeTransformIntoVertices(this.computeWorldMatrix(!0)), this.resetLocalMatrix(e), this;
  }
  get _positions() {
    return this._internalAbstractMeshDataInfo._positions ? this._internalAbstractMeshDataInfo._positions : this._geometry ? this._geometry._positions : null;
  }
  _resetPointsArrayCache() {
    return this._geometry && this._geometry._resetPointsArrayCache(), this;
  }
  _generatePointsArray() {
    return this._geometry ? this._geometry._generatePointsArray() : !1;
  }
  clone(e = "", t = null, i, s = !0) {
    return new W(e, this.getScene(), t, this, i, s);
  }
  dispose(e, t = !1) {
    this.morphTargetManager = null, this._geometry && this._geometry.releaseForMesh(this, !0);
    const i = this._internalMeshDataInfo;
    if (i._onBeforeDrawObservable && i._onBeforeDrawObservable.clear(), i._onBeforeBindObservable && i._onBeforeBindObservable.clear(), i._onBeforeRenderObservable && i._onBeforeRenderObservable.clear(), i._onAfterRenderObservable && i._onAfterRenderObservable.clear(), i._onBetweenPassObservable && i._onBetweenPassObservable.clear(), this._scene.useClonedMeshMap) {
      if (i.meshMap)
        for (const s in i.meshMap) {
          const r = i.meshMap[s];
          r && (r._internalMeshDataInfo._source = null, i.meshMap[s] = void 0);
        }
      i._source && i._source._internalMeshDataInfo.meshMap && (i._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0);
    } else {
      const s = this.getScene().meshes;
      for (const r of s) {
        const n = r;
        n._internalMeshDataInfo && n._internalMeshDataInfo._source && n._internalMeshDataInfo._source === this && (n._internalMeshDataInfo._source = null);
      }
    }
    i._source = null, this._disposeInstanceSpecificData(), this._disposeThinInstanceSpecificData(), this._internalMeshDataInfo._checkReadinessObserver && this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver), super.dispose(e, t);
  }
  _disposeInstanceSpecificData() {
  }
  _disposeThinInstanceSpecificData() {
  }
  _invalidateInstanceVertexArrayObject() {
  }
  applyDisplacementMap(e, t, i, s, r, n, a = !1) {
    const o = this.getScene(), h = (l) => {
      const u = l.width, d = l.height, _ = this.getEngine().createCanvas(u, d).getContext("2d");
      _.drawImage(l, 0, 0);
      const E = _.getImageData(0, 0, u, d).data;
      this.applyDisplacementMapFromBuffer(E, u, d, t, i, r, n, a), s && s(this);
    };
    return X.LoadImage(e, h, () => {
    }, o.offlineProvider), this;
  }
  applyDisplacementMapFromBuffer(e, t, i, s, r, n, a, o = !1) {
    if (!this.isVerticesDataPresent(g.PositionKind) || !this.isVerticesDataPresent(g.NormalKind) || !this.isVerticesDataPresent(g.UVKind))
      return O.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing"), this;
    const h = this.getVerticesData(g.PositionKind, !0, !0), l = this.getVerticesData(g.NormalKind), u = this.getVerticesData(g.UVKind);
    let d = p.Zero();
    const f = p.Zero(), _ = Te.Zero();
    n = n || Te.Zero(), a = a || new Te(1, 1);
    for (let E = 0; E < h.length; E += 3) {
      p.FromArrayToRef(h, E, d), p.FromArrayToRef(l, E, f), Te.FromArrayToRef(u, E / 3 * 2, _);
      const m = Math.abs(_.x * a.x + n.x % 1) * (t - 1) % t | 0, v = Math.abs(_.y * a.y + n.y % 1) * (i - 1) % i | 0, S = (m + v * t) * 4, y = e[S] / 255, A = e[S + 1] / 255, C = e[S + 2] / 255, b = y * 0.3 + A * 0.59 + C * 0.11;
      f.normalize(), f.scaleInPlace(s + (r - s) * b), d = d.add(f), d.toArray(h, E);
    }
    return J.ComputeNormals(h, this.getIndices(), l), o ? (this.setVerticesData(g.PositionKind, h), this.setVerticesData(g.NormalKind, l), this.setVerticesData(g.UVKind, u)) : (this.updateVerticesData(g.PositionKind, h), this.updateVerticesData(g.NormalKind, l)), this;
  }
  convertToFlatShadedMesh() {
    const e = this.getVerticesDataKinds(), t = {}, i = {}, s = {};
    let r = !1, n, a;
    for (n = 0; n < e.length; n++) {
      a = e[n];
      const m = this.getVertexBuffer(a), v = m.getData();
      if (!((v instanceof Array || v instanceof Float32Array) && v.length === 0)) {
        if (a === g.NormalKind) {
          r = m.isUpdatable(), e.splice(n, 1), n--;
          continue;
        }
        t[a] = m, i[a] = this.getVerticesData(a), s[a] = [];
      }
    }
    const o = this.subMeshes.slice(0), h = this.getIndices(), l = this.getTotalIndices();
    let u;
    for (u = 0; u < l; u++) {
      const m = h[u];
      for (n = 0; n < e.length; n++) {
        if (a = e[n], !t[a])
          continue;
        const v = t[a].getStrideSize();
        for (let S = 0; S < v; S++)
          s[a].push(i[a][m * v + S]);
      }
    }
    const d = [], f = s[g.PositionKind], _ = this.getScene().useRightHandedSystem;
    let E;
    for (_ ? E = this.overrideMaterialSideOrientation === 1 : E = this.overrideMaterialSideOrientation === 0, u = 0; u < l; u += 3) {
      h[u] = u, h[u + 1] = u + 1, h[u + 2] = u + 2;
      const m = p.FromArray(f, u * 3), v = p.FromArray(f, (u + 1) * 3), S = p.FromArray(f, (u + 2) * 3), y = m.subtract(v), A = S.subtract(v), C = p.Normalize(p.Cross(y, A));
      E && C.scaleInPlace(-1);
      for (let b = 0; b < 3; b++)
        d.push(C.x), d.push(C.y), d.push(C.z);
    }
    for (this.setIndices(h), this.setVerticesData(g.NormalKind, d, r), n = 0; n < e.length; n++)
      a = e[n], s[a] && this.setVerticesData(a, s[a], t[a].isUpdatable());
    this.releaseSubMeshes();
    for (let m = 0; m < o.length; m++) {
      const v = o[m];
      Et.AddToMesh(v.materialIndex, v.indexStart, v.indexCount, v.indexStart, v.indexCount, this);
    }
    return this.synchronizeInstances(), this;
  }
  convertToUnIndexedMesh() {
    const e = this.getVerticesDataKinds(), t = {}, i = {}, s = {};
    let r, n;
    for (r = 0; r < e.length; r++) {
      n = e[r];
      const u = this.getVertexBuffer(n);
      t[n] = u, i[n] = t[n].getData(), s[n] = [];
    }
    const a = this.subMeshes.slice(0), o = this.getIndices(), h = this.getTotalIndices();
    let l;
    for (l = 0; l < h; l++) {
      const u = o[l];
      for (r = 0; r < e.length; r++) {
        n = e[r];
        const d = t[n].getStrideSize();
        for (let f = 0; f < d; f++)
          s[n].push(i[n][u * d + f]);
      }
    }
    for (l = 0; l < h; l += 3)
      o[l] = l, o[l + 1] = l + 1, o[l + 2] = l + 2;
    for (this.setIndices(o), r = 0; r < e.length; r++)
      n = e[r], this.setVerticesData(n, s[n], t[n].isUpdatable(), t[n].getStrideSize());
    this.releaseSubMeshes();
    for (let u = 0; u < a.length; u++) {
      const d = a[u];
      Et.AddToMesh(d.materialIndex, d.indexStart, d.indexCount, d.indexStart, d.indexCount, this);
    }
    return this._unIndexed = !0, this.synchronizeInstances(), this;
  }
  flipFaces(e = !1) {
    const t = J.ExtractFromMesh(this);
    let i;
    if (e && this.isVerticesDataPresent(g.NormalKind) && t.normals)
      for (i = 0; i < t.normals.length; i++)
        t.normals[i] *= -1;
    if (t.indices) {
      let s;
      for (i = 0; i < t.indices.length; i += 3)
        s = t.indices[i + 1], t.indices[i + 1] = t.indices[i + 2], t.indices[i + 2] = s;
    }
    return t.applyToMesh(this, this.isVertexBufferUpdatable(g.PositionKind)), this;
  }
  increaseVertices(e = 1) {
    const t = J.ExtractFromMesh(this), i = t.indices && !Array.isArray(t.indices) && Array.from ? Array.from(t.indices) : t.indices, s = t.positions && !Array.isArray(t.positions) && Array.from ? Array.from(t.positions) : t.positions, r = t.uvs && !Array.isArray(t.uvs) && Array.from ? Array.from(t.uvs) : t.uvs, n = t.normals && !Array.isArray(t.normals) && Array.from ? Array.from(t.normals) : t.normals;
    if (!i || !s)
      O.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
    else {
      t.indices = i, t.positions = s, r && (t.uvs = r), n && (t.normals = n);
      const a = e + 1, o = new Array();
      for (let C = 0; C < a + 1; C++)
        o[C] = new Array();
      let h, l;
      const u = new p(0, 0, 0), d = new p(0, 0, 0), f = new Te(0, 0), _ = new Array(), E = new Array(), m = new Array();
      let v, S = s.length, y;
      r && (y = r.length);
      let A;
      n && (A = n.length);
      for (let C = 0; C < i.length; C += 3) {
        E[0] = i[C], E[1] = i[C + 1], E[2] = i[C + 2];
        for (let b = 0; b < 3; b++)
          if (h = E[b], l = E[(b + 1) % 3], m[h] === void 0 && m[l] === void 0 ? (m[h] = new Array(), m[l] = new Array()) : (m[h] === void 0 && (m[h] = new Array()), m[l] === void 0 && (m[l] = new Array())), m[h][l] === void 0 && m[l][h] === void 0) {
            m[h][l] = [], u.x = (s[3 * l] - s[3 * h]) / a, u.y = (s[3 * l + 1] - s[3 * h + 1]) / a, u.z = (s[3 * l + 2] - s[3 * h + 2]) / a, n && (d.x = (n[3 * l] - n[3 * h]) / a, d.y = (n[3 * l + 1] - n[3 * h + 1]) / a, d.z = (n[3 * l + 2] - n[3 * h + 2]) / a), r && (f.x = (r[2 * l] - r[2 * h]) / a, f.y = (r[2 * l + 1] - r[2 * h + 1]) / a), m[h][l].push(h);
            for (let M = 1; M < a; M++)
              m[h][l].push(s.length / 3), s[S++] = s[3 * h] + M * u.x, s[S++] = s[3 * h + 1] + M * u.y, s[S++] = s[3 * h + 2] + M * u.z, n && (n[A++] = n[3 * h] + M * d.x, n[A++] = n[3 * h + 1] + M * d.y, n[A++] = n[3 * h + 2] + M * d.z), r && (r[y++] = r[2 * h] + M * f.x, r[y++] = r[2 * h + 1] + M * f.y);
            m[h][l].push(l), m[l][h] = new Array(), v = m[h][l].length;
            for (let M = 0; M < v; M++)
              m[l][h][M] = m[h][l][v - 1 - M];
          }
        o[0][0] = i[C], o[1][0] = m[i[C]][i[C + 1]][1], o[1][1] = m[i[C]][i[C + 2]][1];
        for (let b = 2; b < a; b++) {
          o[b][0] = m[i[C]][i[C + 1]][b], o[b][b] = m[i[C]][i[C + 2]][b], u.x = (s[3 * o[b][b]] - s[3 * o[b][0]]) / b, u.y = (s[3 * o[b][b] + 1] - s[3 * o[b][0] + 1]) / b, u.z = (s[3 * o[b][b] + 2] - s[3 * o[b][0] + 2]) / b, n && (d.x = (n[3 * o[b][b]] - n[3 * o[b][0]]) / b, d.y = (n[3 * o[b][b] + 1] - n[3 * o[b][0] + 1]) / b, d.z = (n[3 * o[b][b] + 2] - n[3 * o[b][0] + 2]) / b), r && (f.x = (r[2 * o[b][b]] - r[2 * o[b][0]]) / b, f.y = (r[2 * o[b][b] + 1] - r[2 * o[b][0] + 1]) / b);
          for (let M = 1; M < b; M++)
            o[b][M] = s.length / 3, s[S++] = s[3 * o[b][0]] + M * u.x, s[S++] = s[3 * o[b][0] + 1] + M * u.y, s[S++] = s[3 * o[b][0] + 2] + M * u.z, n && (n[A++] = n[3 * o[b][0]] + M * d.x, n[A++] = n[3 * o[b][0] + 1] + M * d.y, n[A++] = n[3 * o[b][0] + 2] + M * d.z), r && (r[y++] = r[2 * o[b][0]] + M * f.x, r[y++] = r[2 * o[b][0] + 1] + M * f.y);
        }
        o[a] = m[i[C + 1]][i[C + 2]], _.push(o[0][0], o[1][0], o[1][1]);
        for (let b = 1; b < a; b++) {
          let M;
          for (M = 0; M < b; M++)
            _.push(o[b][M], o[b + 1][M], o[b + 1][M + 1]), _.push(o[b][M], o[b + 1][M + 1], o[b][M + 1]);
          _.push(o[b][M], o[b + 1][M], o[b + 1][M + 1]);
        }
      }
      t.indices = _, t.applyToMesh(this, this.isVertexBufferUpdatable(g.PositionKind));
    }
  }
  forceSharedVertices() {
    const e = J.ExtractFromMesh(this), t = e.uvs, i = e.indices, s = e.positions, r = e.colors, n = e.matricesIndices, a = e.matricesWeights, o = e.matricesIndicesExtra, h = e.matricesWeightsExtra;
    if (i === void 0 || s === void 0 || i === null || s === null)
      O.Warn("VertexData contains empty entries");
    else {
      const l = new Array(), u = new Array(), d = new Array(), f = new Array(), _ = new Array(), E = new Array(), m = new Array(), v = new Array();
      let S = new Array(), y = 0;
      const A = {};
      let C, b;
      for (let L = 0; L < i.length; L += 3) {
        b = [i[L], i[L + 1], i[L + 2]], S = new Array();
        for (let k = 0; k < 3; k++) {
          S[k] = "";
          for (let F = 0; F < 3; F++)
            Math.abs(s[3 * b[k] + F]) < 1e-8 && (s[3 * b[k] + F] = 0), S[k] += s[3 * b[k] + F] + "|";
        }
        if (!(S[0] == S[1] || S[0] == S[2] || S[1] == S[2]))
          for (let k = 0; k < 3; k++) {
            if (C = A[S[k]], C === void 0) {
              A[S[k]] = y, C = y++;
              for (let F = 0; F < 3; F++)
                l.push(s[3 * b[k] + F]);
              if (r != null)
                for (let F = 0; F < 4; F++)
                  f.push(r[4 * b[k] + F]);
              if (t != null)
                for (let F = 0; F < 2; F++)
                  d.push(t[2 * b[k] + F]);
              if (n != null)
                for (let F = 0; F < 4; F++)
                  _.push(n[4 * b[k] + F]);
              if (a != null)
                for (let F = 0; F < 4; F++)
                  E.push(a[4 * b[k] + F]);
              if (o != null)
                for (let F = 0; F < 4; F++)
                  m.push(o[4 * b[k] + F]);
              if (h != null)
                for (let F = 0; F < 4; F++)
                  v.push(h[4 * b[k] + F]);
            }
            u.push(C);
          }
      }
      const M = new Array();
      J.ComputeNormals(l, u, M), e.positions = l, e.indices = u, e.normals = M, t != null && (e.uvs = d), r != null && (e.colors = f), n != null && (e.matricesIndices = _), a != null && (e.matricesWeights = E), o != null && (e.matricesIndicesExtra = m), a != null && (e.matricesWeightsExtra = v), e.applyToMesh(this, this.isVertexBufferUpdatable(g.PositionKind));
    }
  }
  static _instancedMeshFactory(e, t) {
    throw Q("InstancedMesh");
  }
  static _PhysicsImpostorParser(e, t, i) {
    throw Q("PhysicsImpostor");
  }
  createInstance(e) {
    return W._instancedMeshFactory(e, this);
  }
  synchronizeInstances() {
    for (let e = 0; e < this.instances.length; e++)
      this.instances[e]._syncSubMeshes();
    return this;
  }
  optimizeIndices(e) {
    const t = this.getIndices(), i = this.getVerticesData(g.PositionKind);
    if (!i || !t)
      return this;
    const s = new Array();
    for (let n = 0; n < i.length; n = n + 3)
      s.push(p.FromArray(i, n));
    const r = new Array();
    return Ji.SyncAsyncForLoop(s.length, 40, (n) => {
      const a = s.length - 1 - n, o = s[a];
      for (let h = 0; h < a; ++h) {
        const l = s[h];
        if (o.equals(l)) {
          r[a] = h;
          break;
        }
      }
    }, () => {
      for (let a = 0; a < t.length; ++a)
        t[a] = r[t[a]] || t[a];
      const n = this.subMeshes.slice(0);
      this.setIndices(t), this.subMeshes = n, e && e(this);
    }), this;
  }
  serialize(e = {}) {
    e.name = this.name, e.id = this.id, e.uniqueId = this.uniqueId, e.type = this.getClassName(), pe && pe.HasTags(this) && (e.tags = pe.GetTags(this)), e.position = this.position.asArray(), this.rotationQuaternion ? e.rotationQuaternion = this.rotationQuaternion.asArray() : this.rotation && (e.rotation = this.rotation.asArray()), e.scaling = this.scaling.asArray(), this._postMultiplyPivotMatrix ? e.pivotMatrix = this.getPivotMatrix().asArray() : e.localMatrix = this.getPivotMatrix().asArray(), e.isEnabled = this.isEnabled(!1), e.isVisible = this.isVisible, e.infiniteDistance = this.infiniteDistance, e.pickable = this.isPickable, e.receiveShadows = this.receiveShadows, e.billboardMode = this.billboardMode, e.visibility = this.visibility, e.checkCollisions = this.checkCollisions, e.isBlocker = this.isBlocker, e.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation, this.parent && this.parent._serializeAsParent(e), e.isUnIndexed = this.isUnIndexed;
    const t = this._geometry;
    if (t && this.subMeshes) {
      e.geometryUniqueId = t.uniqueId, e.geometryId = t.id, e.subMeshes = [];
      for (let i = 0; i < this.subMeshes.length; i++) {
        const s = this.subMeshes[i];
        e.subMeshes.push({
          materialIndex: s.materialIndex,
          verticesStart: s.verticesStart,
          verticesCount: s.verticesCount,
          indexStart: s.indexStart,
          indexCount: s.indexCount
        });
      }
    }
    if (this.material ? this.material.doNotSerialize || (e.materialUniqueId = this.material.uniqueId, e.materialId = this.material.id) : (this.material = null, e.materialUniqueId = this._scene.defaultMaterial.uniqueId, e.materialId = this._scene.defaultMaterial.id), this.morphTargetManager && (e.morphTargetManagerId = this.morphTargetManager.uniqueId), this.skeleton && (e.skeletonId = this.skeleton.id, e.numBoneInfluencers = this.numBoneInfluencers), this.getScene()._getComponent(Z.NAME_PHYSICSENGINE)) {
      const i = this.getPhysicsImpostor();
      i && (e.physicsMass = i.getParam("mass"), e.physicsFriction = i.getParam("friction"), e.physicsRestitution = i.getParam("mass"), e.physicsImpostor = i.type);
    }
    this.metadata && (e.metadata = this.metadata), e.instances = [];
    for (let i = 0; i < this.instances.length; i++) {
      const s = this.instances[i];
      if (s.doNotSerialize)
        continue;
      const r = {
        name: s.name,
        id: s.id,
        isEnabled: s.isEnabled(!1),
        isVisible: s.isVisible,
        isPickable: s.isPickable,
        checkCollisions: s.checkCollisions,
        position: s.position.asArray(),
        scaling: s.scaling.asArray()
      };
      if (s.parent && s.parent._serializeAsParent(r), s.rotationQuaternion ? r.rotationQuaternion = s.rotationQuaternion.asArray() : s.rotation && (r.rotation = s.rotation.asArray()), this.getScene()._getComponent(Z.NAME_PHYSICSENGINE)) {
        const n = s.getPhysicsImpostor();
        n && (r.physicsMass = n.getParam("mass"), r.physicsFriction = n.getParam("friction"), r.physicsRestitution = n.getParam("mass"), r.physicsImpostor = n.type);
      }
      s.metadata && (r.metadata = s.metadata), e.instances.push(r), ae.AppendSerializedAnimations(s, r), r.ranges = s.serializeAnimationRanges();
    }
    if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData && (e.thinInstances = {
      instancesCount: this._thinInstanceDataStorage.instancesCount,
      matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
      matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
      enablePicking: this.thinInstanceEnablePicking
    }, this._userThinInstanceBuffersStorage)) {
      const i = {
        data: {},
        sizes: {},
        strides: {}
      };
      for (const s in this._userThinInstanceBuffersStorage.data)
        i.data[s] = Array.from(this._userThinInstanceBuffersStorage.data[s]), i.sizes[s] = this._userThinInstanceBuffersStorage.sizes[s], i.strides[s] = this._userThinInstanceBuffersStorage.strides[s];
      e.thinInstances.userThinInstance = i;
    }
    return ae.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.layerMask = this.layerMask, e.alphaIndex = this.alphaIndex, e.hasVertexAlpha = this.hasVertexAlpha, e.overlayAlpha = this.overlayAlpha, e.overlayColor = this.overlayColor.asArray(), e.renderOverlay = this.renderOverlay, e.applyFog = this.applyFog, this.actionManager && (e.actions = this.actionManager.serialize(this.name)), e;
  }
  _syncGeometryWithMorphTargetManager() {
    if (!this.geometry)
      return;
    this._markSubMeshesAsAttributesDirty();
    const e = this._internalAbstractMeshDataInfo._morphTargetManager;
    if (e && e.vertexCount) {
      if (e.vertexCount !== this.getTotalVertices()) {
        O.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count."), this.morphTargetManager = null;
        return;
      }
      if (e.isUsingTextureForTargets)
        return;
      for (let t = 0; t < e.numInfluencers; t++) {
        const i = e.getActiveTarget(t), s = i.getPositions();
        if (!s) {
          O.Error("Invalid morph target. Target must have positions.");
          return;
        }
        this.geometry.setVerticesData(g.PositionKind + t, s, !1, 3);
        const r = i.getNormals();
        r && this.geometry.setVerticesData(g.NormalKind + t, r, !1, 3);
        const n = i.getTangents();
        n && this.geometry.setVerticesData(g.TangentKind + t, n, !1, 3);
        const a = i.getUVs();
        a && this.geometry.setVerticesData(g.UVKind + "_" + t, a, !1, 2);
      }
    } else {
      let t = 0;
      for (; this.geometry.isVerticesDataPresent(g.PositionKind + t); )
        this.geometry.removeVerticesData(g.PositionKind + t), this.geometry.isVerticesDataPresent(g.NormalKind + t) && this.geometry.removeVerticesData(g.NormalKind + t), this.geometry.isVerticesDataPresent(g.TangentKind + t) && this.geometry.removeVerticesData(g.TangentKind + t), this.geometry.isVerticesDataPresent(g.UVKind + t) && this.geometry.removeVerticesData(g.UVKind + "_" + t), t++;
    }
  }
  static Parse(e, t, i) {
    let s;
    if (e.type && e.type === "LinesMesh" ? s = W._LinesMeshParser(e, t) : e.type && e.type === "GroundMesh" ? s = W._GroundMeshParser(e, t) : e.type && e.type === "GoldbergMesh" ? s = W._GoldbergMeshParser(e, t) : s = new W(e.name, t), s.id = e.id, s._waitingParsedUniqueId = e.uniqueId, pe && pe.AddTagsTo(s, e.tags), s.position = p.FromArray(e.position), e.metadata !== void 0 && (s.metadata = e.metadata), e.rotationQuaternion ? s.rotationQuaternion = Y.FromArray(e.rotationQuaternion) : e.rotation && (s.rotation = p.FromArray(e.rotation)), s.scaling = p.FromArray(e.scaling), e.localMatrix ? s.setPreTransformMatrix(x.FromArray(e.localMatrix)) : e.pivotMatrix && s.setPivotMatrix(x.FromArray(e.pivotMatrix)), s.setEnabled(e.isEnabled), s.isVisible = e.isVisible, s.infiniteDistance = e.infiniteDistance, s.showBoundingBox = e.showBoundingBox, s.showSubMeshesBoundingBox = e.showSubMeshesBoundingBox, e.applyFog !== void 0 && (s.applyFog = e.applyFog), e.pickable !== void 0 && (s.isPickable = e.pickable), e.alphaIndex !== void 0 && (s.alphaIndex = e.alphaIndex), s.receiveShadows = e.receiveShadows, e.billboardMode !== void 0 && (s.billboardMode = e.billboardMode), e.visibility !== void 0 && (s.visibility = e.visibility), s.checkCollisions = e.checkCollisions, s.overrideMaterialSideOrientation = e.overrideMaterialSideOrientation, e.isBlocker !== void 0 && (s.isBlocker = e.isBlocker), s._shouldGenerateFlatShading = e.useFlatShading, e.freezeWorldMatrix && (s._waitingData.freezeWorldMatrix = e.freezeWorldMatrix), e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), e.actions !== void 0 && (s._waitingData.actions = e.actions), e.overlayAlpha !== void 0 && (s.overlayAlpha = e.overlayAlpha), e.overlayColor !== void 0 && (s.overlayColor = se.FromArray(e.overlayColor)), e.renderOverlay !== void 0 && (s.renderOverlay = e.renderOverlay), s.isUnIndexed = !!e.isUnIndexed, s.hasVertexAlpha = e.hasVertexAlpha, e.delayLoadingFile ? (s.delayLoadState = 4, s.delayLoadingFile = i + e.delayLoadingFile, s.buildBoundingInfo(p.FromArray(e.boundingBoxMinimum), p.FromArray(e.boundingBoxMaximum)), e._binaryInfo && (s._binaryInfo = e._binaryInfo), s._delayInfo = [], e.hasUVs && s._delayInfo.push(g.UVKind), e.hasUVs2 && s._delayInfo.push(g.UV2Kind), e.hasUVs3 && s._delayInfo.push(g.UV3Kind), e.hasUVs4 && s._delayInfo.push(g.UV4Kind), e.hasUVs5 && s._delayInfo.push(g.UV5Kind), e.hasUVs6 && s._delayInfo.push(g.UV6Kind), e.hasColors && s._delayInfo.push(g.ColorKind), e.hasMatricesIndices && s._delayInfo.push(g.MatricesIndicesKind), e.hasMatricesWeights && s._delayInfo.push(g.MatricesWeightsKind), s._delayLoadingFunction = at._ImportGeometry, we.ForceFullSceneLoadingForIncremental && s._checkDelayState()) : at._ImportGeometry(e, s), e.materialUniqueId ? s._waitingMaterialId = e.materialUniqueId : e.materialId && (s._waitingMaterialId = e.materialId), e.morphTargetManagerId > -1 && (s.morphTargetManager = t.getMorphTargetManagerById(e.morphTargetManagerId)), e.skeletonId !== void 0 && e.skeletonId !== null && (s.skeleton = t.getLastSkeletonById(e.skeletonId), e.numBoneInfluencers && (s.numBoneInfluencers = e.numBoneInfluencers)), e.animations) {
      for (let r = 0; r < e.animations.length; r++) {
        const n = e.animations[r], a = ci("BABYLON.Animation");
        a && s.animations.push(a.Parse(n));
      }
      Xe.ParseAnimationRanges(s, e, t);
    }
    if (e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.layerMask && !isNaN(e.layerMask) ? s.layerMask = Math.abs(parseInt(e.layerMask)) : s.layerMask = 268435455, e.physicsImpostor && W._PhysicsImpostorParser(t, s, e), e.lodMeshIds && (s._waitingData.lods = {
      ids: e.lodMeshIds,
      distances: e.lodDistances ? e.lodDistances : null,
      coverages: e.lodCoverages ? e.lodCoverages : null
    }), e.instances)
      for (let r = 0; r < e.instances.length; r++) {
        const n = e.instances[r], a = s.createInstance(n.name);
        if (n.id && (a.id = n.id), pe && (n.tags ? pe.AddTagsTo(a, n.tags) : pe.AddTagsTo(a, e.tags)), a.position = p.FromArray(n.position), n.metadata !== void 0 && (a.metadata = n.metadata), n.parentId !== void 0 && (a._waitingParentId = n.parentId), n.parentInstanceIndex !== void 0 && (a._waitingParentInstanceIndex = n.parentInstanceIndex), n.isEnabled !== void 0 && n.isEnabled !== null && a.setEnabled(n.isEnabled), n.isVisible !== void 0 && n.isVisible !== null && (a.isVisible = n.isVisible), n.isPickable !== void 0 && n.isPickable !== null && (a.isPickable = n.isPickable), n.rotationQuaternion ? a.rotationQuaternion = Y.FromArray(n.rotationQuaternion) : n.rotation && (a.rotation = p.FromArray(n.rotation)), a.scaling = p.FromArray(n.scaling), n.checkCollisions != null && n.checkCollisions != null && (a.checkCollisions = n.checkCollisions), n.pickable != null && n.pickable != null && (a.isPickable = n.pickable), n.showBoundingBox != null && n.showBoundingBox != null && (a.showBoundingBox = n.showBoundingBox), n.showSubMeshesBoundingBox != null && n.showSubMeshesBoundingBox != null && (a.showSubMeshesBoundingBox = n.showSubMeshesBoundingBox), n.alphaIndex != null && n.showSubMeshesBoundingBox != null && (a.alphaIndex = n.alphaIndex), n.physicsImpostor && W._PhysicsImpostorParser(t, a, n), n.animations) {
          for (let o = 0; o < n.animations.length; o++) {
            const h = n.animations[o], l = ci("BABYLON.Animation");
            l && a.animations.push(l.Parse(h));
          }
          Xe.ParseAnimationRanges(a, n, t), n.autoAnimate && t.beginAnimation(a, n.autoAnimateFrom, n.autoAnimateTo, n.autoAnimateLoop, n.autoAnimateSpeed || 1);
        }
      }
    if (e.thinInstances) {
      const r = e.thinInstances;
      if (s.thinInstanceEnablePicking = !!r.enablePicking, r.matrixData ? (s.thinInstanceSetBuffer("matrix", new Float32Array(r.matrixData), 16, !1), s._thinInstanceDataStorage.matrixBufferSize = r.matrixBufferSize, s._thinInstanceDataStorage.instancesCount = r.instancesCount) : s._thinInstanceDataStorage.matrixBufferSize = r.matrixBufferSize, e.thinInstances.userThinInstance) {
        const n = e.thinInstances.userThinInstance;
        for (const a in n.data)
          s.thinInstanceSetBuffer(a, new Float32Array(n.data[a]), n.strides[a], !1), s._userThinInstanceBuffersStorage.sizes[a] = n.sizes[a];
      }
    }
    return s;
  }
  setPositionsForCPUSkinning() {
    const e = this._internalMeshDataInfo;
    if (!e._sourcePositions) {
      const t = this.getVerticesData(g.PositionKind);
      if (!t)
        return e._sourcePositions;
      e._sourcePositions = new Float32Array(t), this.isVertexBufferUpdatable(g.PositionKind) || this.setVerticesData(g.PositionKind, t, !0);
    }
    return e._sourcePositions;
  }
  setNormalsForCPUSkinning() {
    const e = this._internalMeshDataInfo;
    if (!e._sourceNormals) {
      const t = this.getVerticesData(g.NormalKind);
      if (!t)
        return e._sourceNormals;
      e._sourceNormals = new Float32Array(t), this.isVertexBufferUpdatable(g.NormalKind) || this.setVerticesData(g.NormalKind, t, !0);
    }
    return e._sourceNormals;
  }
  applySkeleton(e) {
    if (!this.geometry)
      return this;
    if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId())
      return this;
    if (this.geometry._softwareSkinningFrameId = this.getScene().getFrameId(), !this.isVerticesDataPresent(g.PositionKind))
      return this;
    if (!this.isVerticesDataPresent(g.MatricesIndicesKind))
      return this;
    if (!this.isVerticesDataPresent(g.MatricesWeightsKind))
      return this;
    const t = this.isVerticesDataPresent(g.NormalKind), i = this._internalMeshDataInfo;
    if (!i._sourcePositions) {
      const v = this.subMeshes.slice();
      this.setPositionsForCPUSkinning(), this.subMeshes = v;
    }
    t && !i._sourceNormals && this.setNormalsForCPUSkinning();
    let s = this.getVerticesData(g.PositionKind);
    if (!s)
      return this;
    s instanceof Float32Array || (s = new Float32Array(s));
    let r = this.getVerticesData(g.NormalKind);
    if (t) {
      if (!r)
        return this;
      r instanceof Float32Array || (r = new Float32Array(r));
    }
    const n = this.getVerticesData(g.MatricesIndicesKind), a = this.getVerticesData(g.MatricesWeightsKind);
    if (!a || !n)
      return this;
    const o = this.numBoneInfluencers > 4, h = o ? this.getVerticesData(g.MatricesIndicesExtraKind) : null, l = o ? this.getVerticesData(g.MatricesWeightsExtraKind) : null, u = e.getTransformMatrices(this), d = p.Zero(), f = new x(), _ = new x();
    let E = 0, m;
    for (let v = 0; v < s.length; v += 3, E += 4) {
      let S;
      for (m = 0; m < 4; m++)
        S = a[E + m], S > 0 && (x.FromFloat32ArrayToRefScaled(u, Math.floor(n[E + m] * 16), S, _), f.addToSelf(_));
      if (o)
        for (m = 0; m < 4; m++)
          S = l[E + m], S > 0 && (x.FromFloat32ArrayToRefScaled(u, Math.floor(h[E + m] * 16), S, _), f.addToSelf(_));
      p.TransformCoordinatesFromFloatsToRef(i._sourcePositions[v], i._sourcePositions[v + 1], i._sourcePositions[v + 2], f, d), d.toArray(s, v), t && (p.TransformNormalFromFloatsToRef(i._sourceNormals[v], i._sourceNormals[v + 1], i._sourceNormals[v + 2], f, d), d.toArray(r, v)), f.reset();
    }
    return this.updateVerticesData(g.PositionKind, s), t && this.updateVerticesData(g.NormalKind, r), this;
  }
  static MinMax(e) {
    let t = null, i = null;
    return e.forEach(function(s) {
      const n = s.getBoundingInfo().boundingBox;
      !t || !i ? (t = n.minimumWorld, i = n.maximumWorld) : (t.minimizeInPlace(n.minimumWorld), i.maximizeInPlace(n.maximumWorld));
    }), !t || !i ? {
      min: p.Zero(),
      max: p.Zero()
    } : {
      min: t,
      max: i
    };
  }
  static Center(e) {
    const t = e instanceof Array ? W.MinMax(e) : e;
    return p.Center(t.min, t.max);
  }
  static MergeMeshes(e, t = !0, i, s, r, n) {
    return Ks(W._MergeMeshesCoroutine(e, t, i, s, r, n, !1));
  }
  static MergeMeshesAsync(e, t = !0, i, s, r, n) {
    return kn(W._MergeMeshesCoroutine(e, t, i, s, r, n, !0), Un());
  }
  static *_MergeMeshesCoroutine(e, t = !0, i, s, r, n, a) {
    if (e = e.filter(Boolean), e.length === 0)
      return null;
    let o;
    if (!i) {
      let M = 0;
      for (o = 0; o < e.length; o++)
        if (M += e[o].getTotalVertices(), M >= 65536)
          return O.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices"), null;
    }
    n && (r = !1);
    const h = new Array(), l = new Array(), u = new Array(), d = e[0].overrideMaterialSideOrientation;
    for (o = 0; o < e.length; o++) {
      const M = e[o];
      if (M.isAnInstance)
        return O.Warn("Cannot merge instance meshes."), null;
      if (d !== M.overrideMaterialSideOrientation)
        return O.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values."), null;
      if (r && u.push(M.getTotalIndices()), n)
        if (M.material) {
          const L = M.material;
          if (L instanceof Ai) {
            for (let k = 0; k < L.subMaterials.length; k++)
              h.indexOf(L.subMaterials[k]) < 0 && h.push(L.subMaterials[k]);
            for (let k = 0; k < M.subMeshes.length; k++)
              l.push(h.indexOf(L.subMaterials[M.subMeshes[k].materialIndex])), u.push(M.subMeshes[k].indexCount);
          } else {
            h.indexOf(L) < 0 && h.push(L);
            for (let k = 0; k < M.subMeshes.length; k++)
              l.push(h.indexOf(L)), u.push(M.subMeshes[k].indexCount);
          }
        } else
          for (let L = 0; L < M.subMeshes.length; L++)
            l.push(0), u.push(M.subMeshes[L].indexCount);
    }
    const f = e[0], _ = (M) => {
      const L = M.computeWorldMatrix(!0);
      return [J.ExtractFromMesh(M, !1, !1), L];
    }, [E, m] = _(f);
    a && (yield);
    const v = new Array(e.length - 1);
    for (let M = 1; M < e.length; M++)
      v[M - 1] = _(e[M]), a && (yield);
    const S = E._mergeCoroutine(m, v, i, a, !t);
    let y = S.next();
    for (; !y.done; )
      a && (yield), y = S.next();
    const A = y.value;
    s || (s = new W(f.name + "_merged", f.getScene()));
    const C = A._applyToCoroutine(s, void 0, a);
    let b = C.next();
    for (; !b.done; )
      a && (yield), b = C.next();
    if (s.checkCollisions = f.checkCollisions, s.overrideMaterialSideOrientation = f.overrideMaterialSideOrientation, t)
      for (o = 0; o < e.length; o++)
        e[o].dispose();
    if (r || n) {
      s.releaseSubMeshes(), o = 0;
      let M = 0;
      for (; o < u.length; )
        Et.CreateFromIndices(0, M, u[o], s, void 0, !1), M += u[o], o++;
      for (const L of s.subMeshes)
        L.refreshBoundingInfo();
      s.computeWorldMatrix(!0);
    }
    if (n) {
      const M = new Ai(f.name + "_merged", f.getScene());
      M.subMaterials = h;
      for (let L = 0; L < s.subMeshes.length; L++)
        s.subMeshes[L].materialIndex = l[L];
      s.material = M;
    } else
      s.material = f.material;
    return s;
  }
  addInstance(e) {
    e._indexInSourceMeshInstanceArray = this.instances.length, this.instances.push(e);
  }
  removeInstance(e) {
    const t = e._indexInSourceMeshInstanceArray;
    if (t != -1) {
      if (t !== this.instances.length - 1) {
        const i = this.instances[this.instances.length - 1];
        this.instances[t] = i, i._indexInSourceMeshInstanceArray = t;
      }
      e._indexInSourceMeshInstanceArray = -1, this.instances.pop();
    }
  }
  _shouldConvertRHS() {
    return this.overrideMaterialSideOrientation === P.CounterClockWiseSideOrientation;
  }
}
W.FRONTSIDE = J.FRONTSIDE;
W.BACKSIDE = J.BACKSIDE;
W.DOUBLESIDE = J.DOUBLESIDE;
W.DEFAULTSIDE = J.DEFAULTSIDE;
W.NO_CAP = 0;
W.CAP_START = 1;
W.CAP_END = 2;
W.CAP_ALL = 3;
W.NO_FLIP = 0;
W.FLIP_TILE = 1;
W.ROTATE_TILE = 2;
W.FLIP_ROW = 3;
W.ROTATE_ROW = 4;
W.FLIP_N_ROTATE_TILE = 5;
W.FLIP_N_ROTATE_ROW = 6;
W.CENTER = 0;
W.LEFT = 1;
W.RIGHT = 2;
W.TOP = 3;
W.BOTTOM = 4;
W.INSTANCEDMESH_SORT_TRANSPARENT = !1;
W._GroundMeshParser = (c, e) => {
  throw Q("GroundMesh");
};
W._GoldbergMeshParser = (c, e) => {
  throw Q("GoldbergMesh");
};
W._LinesMeshParser = (c, e) => {
  throw Q("LinesMesh");
};
st("BABYLON.Mesh", W);
W.prototype.setMaterialByID = function(c) {
  return this.setMaterialById(c);
};
W.CreateDisc = W.CreateDisc || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateBox = W.CreateBox || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateSphere = W.CreateSphere || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateCylinder = W.CreateCylinder || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateTorusKnot = W.CreateTorusKnot || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateTorus = W.CreateTorus || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreatePlane = W.CreatePlane || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateGround = W.CreateGround || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateTiledGround = W.CreateTiledGround || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateGroundFromHeightMap = W.CreateGroundFromHeightMap || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateTube = W.CreateTube || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreatePolyhedron = W.CreatePolyhedron || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateIcoSphere = W.CreateIcoSphere || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateDecal = W.CreateDecal || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.CreateCapsule = W.CreateCapsule || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
W.ExtendToGoldberg = W.ExtendToGoldberg || (() => {
  throw new Error("Import MeshBuilder to populate this function");
});
class Ht {
  constructor(e = 0) {
    this.priority = e;
  }
  getDescription() {
    return "";
  }
  apply(e, t) {
    return !0;
  }
}
class As extends Ht {
  constructor(e = 0, t = 1024, i = 0.5) {
    super(e), this.priority = e, this.maximumSize = t, this.step = i;
  }
  getDescription() {
    return "Reducing render target texture size to " + this.maximumSize;
  }
  apply(e, t) {
    let i = !0;
    for (let s = 0; s < e.textures.length; s++) {
      const r = e.textures[s];
      if (!r.canRescale || r.getContext)
        continue;
      const n = r.getSize();
      Math.max(n.width, n.height) > this.maximumSize && (r.scale(this.step), i = !1);
    }
    return i;
  }
}
class _r extends Ht {
  constructor(e = 0, t = 2, i = 0.25) {
    super(e), this.priority = e, this.maximumScale = t, this.step = i, this._currentScale = -1, this._directionOffset = 1;
  }
  getDescription() {
    return "Setting hardware scaling level to " + this._currentScale;
  }
  apply(e, t) {
    return this._currentScale === -1 && (this._currentScale = e.getEngine().getHardwareScalingLevel(), this._currentScale > this.maximumScale && (this._directionOffset = -1)), this._currentScale += this._directionOffset * this.step, e.getEngine().setHardwareScalingLevel(this._currentScale), this._directionOffset === 1 ? this._currentScale >= this.maximumScale : this._currentScale <= this.maximumScale;
  }
}
class Rs extends Ht {
  getDescription() {
    return "Turning shadows on/off";
  }
  apply(e, t) {
    return e.shadowsEnabled = t.isInImprovementMode, !0;
  }
}
class ys extends Ht {
  getDescription() {
    return "Turning post-processes on/off";
  }
  apply(e, t) {
    return e.postProcessesEnabled = t.isInImprovementMode, !0;
  }
}
class Cs extends Ht {
  getDescription() {
    return "Turning lens flares on/off";
  }
  apply(e, t) {
    return e.lensFlaresEnabled = t.isInImprovementMode, !0;
  }
}
class jn extends Ht {
  getDescription() {
    return this.onGetDescription ? this.onGetDescription() : "Running user defined callback";
  }
  apply(e, t) {
    return this.onApply ? this.onApply(e, t) : !0;
  }
}
class Is extends Ht {
  getDescription() {
    return "Turning particles on/off";
  }
  apply(e, t) {
    return e.particlesEnabled = t.isInImprovementMode, !0;
  }
}
class gr extends Ht {
  getDescription() {
    return "Turning render targets off";
  }
  apply(e, t) {
    return e.renderTargetsEnabled = t.isInImprovementMode, !0;
  }
}
class jt extends Ht {
  constructor() {
    super(...arguments), this._canBeMerged = (e) => {
      if (!(e instanceof W))
        return !1;
      const t = e;
      return !(t.isDisposed() || !t.isVisible || !t.isEnabled() || t.instances.length > 0 || t.skeleton || t.hasLODLevels);
    };
  }
  static get UpdateSelectionTree() {
    return jt._UpdateSelectionTree;
  }
  static set UpdateSelectionTree(e) {
    jt._UpdateSelectionTree = e;
  }
  getDescription() {
    return "Merging similar meshes together";
  }
  apply(e, t, i) {
    const s = e.meshes.slice(0);
    let r = s.length;
    for (let a = 0; a < r; a++) {
      const o = new Array(), h = s[a];
      if (!!this._canBeMerged(h)) {
        o.push(h);
        for (let l = a + 1; l < r; l++) {
          const u = s[l];
          !this._canBeMerged(u) || u.material === h.material && u.checkCollisions === h.checkCollisions && (o.push(u), r--, s.splice(l, 1), l--);
        }
        o.length < 2 || W.MergeMeshes(o, void 0, !0);
      }
    }
    const n = e;
    return n.createOrUpdateSelectionOctree && (i != null ? i && n.createOrUpdateSelectionOctree() : jt.UpdateSelectionTree && n.createOrUpdateSelectionOctree()), !0;
  }
}
jt._UpdateSelectionTree = !1;
class li {
  constructor(e = 60, t = 2e3) {
    this.targetFrameRate = e, this.trackerDuration = t, this.optimizations = new Array();
  }
  addOptimization(e) {
    return this.optimizations.push(e), this;
  }
  addCustomOptimization(e, t, i = 0) {
    const s = new jn(i);
    return s.onApply = e, s.onGetDescription = t, this.optimizations.push(s), this;
  }
  static LowDegradationAllowed(e) {
    const t = new li(e);
    let i = 0;
    return t.addOptimization(new jt(i)), t.addOptimization(new Rs(i)), t.addOptimization(new Cs(i)), i++, t.addOptimization(new ys(i)), t.addOptimization(new Is(i)), i++, t.addOptimization(new As(i, 1024)), t;
  }
  static ModerateDegradationAllowed(e) {
    const t = new li(e);
    let i = 0;
    return t.addOptimization(new jt(i)), t.addOptimization(new Rs(i)), t.addOptimization(new Cs(i)), i++, t.addOptimization(new ys(i)), t.addOptimization(new Is(i)), i++, t.addOptimization(new As(i, 512)), i++, t.addOptimization(new gr(i)), i++, t.addOptimization(new _r(i, 2)), t;
  }
  static HighDegradationAllowed(e) {
    const t = new li(e);
    let i = 0;
    return t.addOptimization(new jt(i)), t.addOptimization(new Rs(i)), t.addOptimization(new Cs(i)), i++, t.addOptimization(new ys(i)), t.addOptimization(new Is(i)), i++, t.addOptimization(new As(i, 256)), i++, t.addOptimization(new gr(i)), i++, t.addOptimization(new _r(i, 4)), t;
  }
}
class Zs {
  constructor(e, t, i = !0, s = !1) {
    if (this._isRunning = !1, this._currentPriorityLevel = 0, this._targetFrameRate = 60, this._trackerDuration = 2e3, this._currentFrameRate = 0, this._improvementMode = !1, this.onSuccessObservable = new w(), this.onNewOptimizationAppliedObservable = new w(), this.onFailureObservable = new w(), t ? this._options = t : this._options = new li(), this._options.targetFrameRate && (this._targetFrameRate = this._options.targetFrameRate), this._options.trackerDuration && (this._trackerDuration = this._options.trackerDuration), i) {
      let r = 0;
      for (const n of this._options.optimizations)
        n.priority = r++;
    }
    this._improvementMode = s, this._scene = e || fe.LastCreatedScene, this._sceneDisposeObserver = this._scene.onDisposeObservable.add(() => {
      this._sceneDisposeObserver = null, this.dispose();
    });
  }
  get isInImprovementMode() {
    return this._improvementMode;
  }
  set isInImprovementMode(e) {
    this._improvementMode = e;
  }
  get currentPriorityLevel() {
    return this._currentPriorityLevel;
  }
  get currentFrameRate() {
    return this._currentFrameRate;
  }
  get targetFrameRate() {
    return this._targetFrameRate;
  }
  set targetFrameRate(e) {
    this._targetFrameRate = e;
  }
  get trackerDuration() {
    return this._trackerDuration;
  }
  set trackerDuration(e) {
    this._trackerDuration = e;
  }
  get optimizations() {
    return this._options.optimizations;
  }
  stop() {
    this._isRunning = !1;
  }
  reset() {
    this._currentPriorityLevel = 0;
  }
  start() {
    this._isRunning || (this._isRunning = !0, this._scene.executeWhenReady(() => {
      setTimeout(() => {
        this._checkCurrentState();
      }, this._trackerDuration);
    }));
  }
  _checkCurrentState() {
    if (!this._isRunning)
      return;
    const e = this._scene, t = this._options;
    if (this._currentFrameRate = Math.round(e.getEngine().getFps()), this._improvementMode && this._currentFrameRate <= this._targetFrameRate || !this._improvementMode && this._currentFrameRate >= this._targetFrameRate) {
      this._isRunning = !1, this.onSuccessObservable.notifyObservers(this);
      return;
    }
    let i = !0, s = !0;
    for (let r = 0; r < t.optimizations.length; r++) {
      const n = t.optimizations[r];
      n.priority === this._currentPriorityLevel && (s = !1, i = i && n.apply(e, this), this.onNewOptimizationAppliedObservable.notifyObservers(n));
    }
    if (s) {
      this._isRunning = !1, this.onFailureObservable.notifyObservers(this);
      return;
    }
    i && this._currentPriorityLevel++, e.executeWhenReady(() => {
      setTimeout(() => {
        this._checkCurrentState();
      }, this._trackerDuration);
    });
  }
  dispose() {
    this.stop(), this.onSuccessObservable.clear(), this.onFailureObservable.clear(), this.onNewOptimizationAppliedObservable.clear(), this._sceneDisposeObserver && this._scene.onDisposeObservable.remove(this._sceneDisposeObserver);
  }
  static OptimizeAsync(e, t, i, s) {
    const r = new Zs(e, t || li.ModerateDegradationAllowed(), !1);
    return i && r.onSuccessObservable.add(() => {
      i();
    }), s && r.onFailureObservable.add(() => {
      s();
    }), r.start(), r;
  }
}
function Qn(c) {
  const { engine: e } = c, t = new re(e);
  t.clearColor = new ge(0, 0, 0, 0), t.pointerMovePredicate = () => !1, t.pointerDownPredicate = () => !1, t.pointerUpPredicate = () => !1, t.clearCachedVertexData(), t.themeData = {};
  const i = li.LowDegradationAllowed();
  return i.optimizations = i.optimizations.splice(1), i.targetFrameRate = 60, Zs.OptimizeAsync(t, i), t;
}
class Ge extends q {
  constructor(e, t, i, s = !0) {
    super(e, t, i, s), this._tmpUpVector = p.Zero(), this._tmpTargetVector = p.Zero(), this.cameraDirection = new p(0, 0, 0), this.cameraRotation = new Te(0, 0), this.ignoreParentScaling = !1, this.updateUpVectorFromRotation = !1, this._tmpQuaternion = new Y(), this.rotation = new p(0, 0, 0), this.speed = 2, this.noRotationConstraint = !1, this.invertRotation = !1, this.inverseRotationSpeed = 0.2, this.lockedTarget = null, this._currentTarget = p.Zero(), this._initialFocalDistance = 1, this._viewMatrix = x.Zero(), this._camMatrix = x.Zero(), this._cameraTransformMatrix = x.Zero(), this._cameraRotationMatrix = x.Zero(), this._referencePoint = new p(0, 0, 1), this._transformedReferencePoint = p.Zero(), this._defaultUp = p.Up(), this._cachedRotationZ = 0, this._cachedQuaternionRotationZ = 0;
  }
  getFrontPosition(e) {
    this.getWorldMatrix();
    const t = this.getTarget().subtract(this.position);
    return t.normalize(), t.scaleInPlace(e), this.globalPosition.add(t);
  }
  _getLockedTargetPosition() {
    return this.lockedTarget ? (this.lockedTarget.absolutePosition && this.lockedTarget.computeWorldMatrix(), this.lockedTarget.absolutePosition || this.lockedTarget) : null;
  }
  storeState() {
    return this._storedPosition = this.position.clone(), this._storedRotation = this.rotation.clone(), this.rotationQuaternion && (this._storedRotationQuaternion = this.rotationQuaternion.clone()), super.storeState();
  }
  _restoreStateValues() {
    return super._restoreStateValues() ? (this.position = this._storedPosition.clone(), this.rotation = this._storedRotation.clone(), this.rotationQuaternion && (this.rotationQuaternion = this._storedRotationQuaternion.clone()), this.cameraDirection.copyFromFloats(0, 0, 0), this.cameraRotation.copyFromFloats(0, 0), !0) : !1;
  }
  _initCache() {
    super._initCache(), this._cache.lockedTarget = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotation = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cache.rotationQuaternion = new Y(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  }
  _updateCache(e) {
    e || super._updateCache();
    const t = this._getLockedTargetPosition();
    t ? this._cache.lockedTarget ? this._cache.lockedTarget.copyFrom(t) : this._cache.lockedTarget = t.clone() : this._cache.lockedTarget = null, this._cache.rotation.copyFrom(this.rotation), this.rotationQuaternion && this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
  }
  _isSynchronizedViewMatrix() {
    if (!super._isSynchronizedViewMatrix())
      return !1;
    const e = this._getLockedTargetPosition();
    return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(e) : !e) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
  }
  _computeLocalCameraSpeed() {
    const e = this.getEngine();
    return this.speed * Math.sqrt(e.getDeltaTime() / (e.getFps() * 100));
  }
  setTarget(e) {
    this.upVector.normalize(), this._initialFocalDistance = e.subtract(this.position).length(), this.position.z === e.z && (this.position.z += Re), this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance), x.LookAtLHToRef(this.position, e, this._defaultUp, this._camMatrix), this._camMatrix.invert(), this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
    const t = e.subtract(this.position);
    t.x >= 0 ? this.rotation.y = -Math.atan(t.z / t.x) + Math.PI / 2 : this.rotation.y = -Math.atan(t.z / t.x) - Math.PI / 2, this.rotation.z = 0, isNaN(this.rotation.x) && (this.rotation.x = 0), isNaN(this.rotation.y) && (this.rotation.y = 0), isNaN(this.rotation.z) && (this.rotation.z = 0), this.rotationQuaternion && Y.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
  }
  get target() {
    return this.getTarget();
  }
  set target(e) {
    this.setTarget(e);
  }
  getTarget() {
    return this._currentTarget;
  }
  _decideIfNeedsToMove() {
    return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
  }
  _updatePosition() {
    if (this.parent) {
      this.parent.getWorldMatrix().invertToRef(D.Matrix[0]), p.TransformNormalToRef(this.cameraDirection, D.Matrix[0], D.Vector3[0]), this.position.addInPlace(D.Vector3[0]);
      return;
    }
    this.position.addInPlace(this.cameraDirection);
  }
  _checkInputs() {
    const e = this.invertRotation ? -this.inverseRotationSpeed : 1, t = this._decideIfNeedsToMove(), i = Math.abs(this.cameraRotation.x) > 0 || Math.abs(this.cameraRotation.y) > 0;
    t && this._updatePosition(), i && (this.rotationQuaternion && this.rotationQuaternion.toEulerAnglesToRef(this.rotation), this.rotation.x += this.cameraRotation.x * e, this.rotation.y += this.cameraRotation.y * e, this.noRotationConstraint || (this.rotation.x > 1.570796 && (this.rotation.x = 1.570796), this.rotation.x < -1.570796 && (this.rotation.x = -1.570796)), this.rotationQuaternion && this.rotation.lengthSquared() && Y.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion)), t && (Math.abs(this.cameraDirection.x) < this.speed * Re && (this.cameraDirection.x = 0), Math.abs(this.cameraDirection.y) < this.speed * Re && (this.cameraDirection.y = 0), Math.abs(this.cameraDirection.z) < this.speed * Re && (this.cameraDirection.z = 0), this.cameraDirection.scaleInPlace(this.inertia)), i && (Math.abs(this.cameraRotation.x) < this.speed * Re && (this.cameraRotation.x = 0), Math.abs(this.cameraRotation.y) < this.speed * Re && (this.cameraRotation.y = 0), this.cameraRotation.scaleInPlace(this.inertia)), super._checkInputs();
  }
  _updateCameraRotationMatrix() {
    this.rotationQuaternion ? this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix) : x.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
  }
  _rotateUpVectorWithCameraRotationMatrix() {
    return p.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector), this;
  }
  _getViewMatrix() {
    return this.lockedTarget && this.setTarget(this._getLockedTargetPosition()), this._updateCameraRotationMatrix(), this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z ? (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedQuaternionRotationZ = this.rotationQuaternion.z) : this._cachedRotationZ !== this.rotation.z && (this._rotateUpVectorWithCameraRotationMatrix(), this._cachedRotationZ = this.rotation.z), p.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint), this.position.addToRef(this._transformedReferencePoint, this._currentTarget), this.updateUpVectorFromRotation && (this.rotationQuaternion ? ui.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector) : (Y.FromEulerVectorToRef(this.rotation, this._tmpQuaternion), ui.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector))), this._computeViewMatrix(this.position, this._currentTarget, this.upVector), this._viewMatrix;
  }
  _computeViewMatrix(e, t, i) {
    if (this.ignoreParentScaling) {
      if (this.parent) {
        const s = this.parent.getWorldMatrix();
        p.TransformCoordinatesToRef(e, s, this._globalPosition), p.TransformCoordinatesToRef(t, s, this._tmpTargetVector), p.TransformNormalToRef(i, s, this._tmpUpVector), this._markSyncedWithParent();
      } else
        this._globalPosition.copyFrom(e), this._tmpTargetVector.copyFrom(t), this._tmpUpVector.copyFrom(i);
      this.getScene().useRightHandedSystem ? x.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix) : x.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
      return;
    }
    if (this.getScene().useRightHandedSystem ? x.LookAtRHToRef(e, t, i, this._viewMatrix) : x.LookAtLHToRef(e, t, i, this._viewMatrix), this.parent) {
      const s = this.parent.getWorldMatrix();
      this._viewMatrix.invert(), this._viewMatrix.multiplyToRef(s, this._viewMatrix), this._viewMatrix.getTranslationToRef(this._globalPosition), this._viewMatrix.invert(), this._markSyncedWithParent();
    } else
      this._globalPosition.copyFrom(e);
  }
  createRigCamera(e, t) {
    if (this.cameraRigMode !== q.RIG_MODE_NONE) {
      const i = new Ge(e, this.position.clone(), this.getScene());
      return i.isRigCamera = !0, i.rigParent = this, (this.cameraRigMode === q.RIG_MODE_VR || this.cameraRigMode === q.RIG_MODE_WEBVR) && (this.rotationQuaternion || (this.rotationQuaternion = new Y()), i._cameraRigParams = {}, i.rotationQuaternion = new Y()), i.mode = this.mode, i.orthoLeft = this.orthoLeft, i.orthoRight = this.orthoRight, i.orthoTop = this.orthoTop, i.orthoBottom = this.orthoBottom, i;
    }
    return null;
  }
  _updateRigCameras() {
    const e = this._rigCameras[0], t = this._rigCameras[1];
    switch (this.computeWorldMatrix(), this.cameraRigMode) {
      case q.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
      case q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
      case q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
      case q.RIG_MODE_STEREOSCOPIC_OVERUNDER:
      case q.RIG_MODE_STEREOSCOPIC_INTERLACED: {
        const i = this.cameraRigMode === q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1, s = this.cameraRigMode === q.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
        this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * i, e), this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * s, t);
        break;
      }
      case q.RIG_MODE_VR:
        e.rotationQuaternion ? (e.rotationQuaternion.copyFrom(this.rotationQuaternion), t.rotationQuaternion.copyFrom(this.rotationQuaternion)) : (e.rotation.copyFrom(this.rotation), t.rotation.copyFrom(this.rotation)), e.position.copyFrom(this.position), t.position.copyFrom(this.position);
        break;
    }
    super._updateRigCameras();
  }
  _getRigCamPositionAndTarget(e, t) {
    this.getTarget().subtractToRef(this.position, Ge._TargetFocalPoint), Ge._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
    const s = Ge._TargetFocalPoint.addInPlace(this.position);
    x.TranslationToRef(-s.x, -s.y, -s.z, Ge._TargetTransformMatrix), Ge._TargetTransformMatrix.multiplyToRef(x.RotationAxis(t.upVector, e), Ge._RigCamTransformMatrix), x.TranslationToRef(s.x, s.y, s.z, Ge._TargetTransformMatrix), Ge._RigCamTransformMatrix.multiplyToRef(Ge._TargetTransformMatrix, Ge._RigCamTransformMatrix), p.TransformCoordinatesToRef(this.position, Ge._RigCamTransformMatrix, t.position), t.setTarget(s);
  }
  getClassName() {
    return "TargetCamera";
  }
}
Ge._RigCamTransformMatrix = new x();
Ge._TargetTransformMatrix = new x();
Ge._TargetFocalPoint = new p();
T([
  Gt()
], Ge.prototype, "rotation", void 0);
T([
  R()
], Ge.prototype, "speed", void 0);
T([
  In("lockedTargetId")
], Ge.prototype, "lockedTarget", void 0);
function $n(c) {
  const { scene: e } = c;
  let t;
  const i = 36.5;
  return t = new Ge("TargetCamera1", new p(0, i, 0), e), t.fov = 0.25, t.minZ = 5, t.maxZ = i + 1, t.setTarget(p.Zero()), t;
}
class he extends Xe {
  constructor(e, t) {
    super(e, t), this.diffuse = new se(1, 1, 1), this.specular = new se(1, 1, 1), this.falloffType = he.FALLOFF_DEFAULT, this.intensity = 1, this._range = Number.MAX_VALUE, this._inverseSquaredRange = 0, this._photometricScale = 1, this._intensityMode = he.INTENSITYMODE_AUTOMATIC, this._radius = 1e-5, this.renderPriority = 0, this._shadowEnabled = !0, this._excludeWithLayerMask = 0, this._includeOnlyWithLayerMask = 0, this._lightmapMode = 0, this._shadowGenerators = null, this._excludedMeshesIds = new Array(), this._includedOnlyMeshesIds = new Array(), this._isLight = !0, this.getScene().addLight(this), this._uniformBuffer = new V(this.getScene().getEngine(), void 0, void 0, e), this._buildUniformLayout(), this.includedOnlyMeshes = new Array(), this.excludedMeshes = new Array(), this._resyncMeshes();
  }
  get range() {
    return this._range;
  }
  set range(e) {
    this._range = e, this._inverseSquaredRange = 1 / (this.range * this.range);
  }
  get intensityMode() {
    return this._intensityMode;
  }
  set intensityMode(e) {
    this._intensityMode = e, this._computePhotometricScale();
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    this._radius = e, this._computePhotometricScale();
  }
  get shadowEnabled() {
    return this._shadowEnabled;
  }
  set shadowEnabled(e) {
    this._shadowEnabled !== e && (this._shadowEnabled = e, this._markMeshesAsLightDirty());
  }
  get includedOnlyMeshes() {
    return this._includedOnlyMeshes;
  }
  set includedOnlyMeshes(e) {
    this._includedOnlyMeshes = e, this._hookArrayForIncludedOnly(e);
  }
  get excludedMeshes() {
    return this._excludedMeshes;
  }
  set excludedMeshes(e) {
    this._excludedMeshes = e, this._hookArrayForExcluded(e);
  }
  get excludeWithLayerMask() {
    return this._excludeWithLayerMask;
  }
  set excludeWithLayerMask(e) {
    this._excludeWithLayerMask = e, this._resyncMeshes();
  }
  get includeOnlyWithLayerMask() {
    return this._includeOnlyWithLayerMask;
  }
  set includeOnlyWithLayerMask(e) {
    this._includeOnlyWithLayerMask = e, this._resyncMeshes();
  }
  get lightmapMode() {
    return this._lightmapMode;
  }
  set lightmapMode(e) {
    this._lightmapMode !== e && (this._lightmapMode = e, this._markMeshesAsLightDirty());
  }
  transferTexturesToEffect(e, t) {
    return this;
  }
  _bindLight(e, t, i, s, r = !0) {
    var n;
    const a = e.toString();
    let o = !1;
    if (this._uniformBuffer.bindToEffect(i, "Light" + a), this._renderId !== t.getRenderId() || this._lastUseSpecular !== s || !this._uniformBuffer.useUbo) {
      this._renderId = t.getRenderId(), this._lastUseSpecular = s;
      const h = this.getScaledIntensity();
      this.transferToEffect(i, a), this.diffuse.scaleToRef(h, vi.Color3[0]), this._uniformBuffer.updateColor4("vLightDiffuse", vi.Color3[0], this.range, a), s && (this.specular.scaleToRef(h, vi.Color3[1]), this._uniformBuffer.updateColor4("vLightSpecular", vi.Color3[1], this.radius, a)), o = !0;
    }
    if (this.transferTexturesToEffect(i, a), t.shadowsEnabled && this.shadowEnabled && r) {
      const h = (n = this.getShadowGenerator(t.activeCamera)) !== null && n !== void 0 ? n : this.getShadowGenerator();
      h && (h.bindShadowLight(a, i), o = !0);
    }
    o ? this._uniformBuffer.update() : this._uniformBuffer.bindUniformBuffer();
  }
  getClassName() {
    return "Light";
  }
  toString(e) {
    let t = "Name: " + this.name;
    if (t += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()], this.animations)
      for (let i = 0; i < this.animations.length; i++)
        t += ", animation[0]: " + this.animations[i].toString(e);
    return t;
  }
  _syncParentEnabledState() {
    super._syncParentEnabledState(), this.isDisposed() || this._resyncMeshes();
  }
  setEnabled(e) {
    super.setEnabled(e), this._resyncMeshes();
  }
  getShadowGenerator(e = null) {
    var t;
    return this._shadowGenerators === null ? null : (t = this._shadowGenerators.get(e)) !== null && t !== void 0 ? t : null;
  }
  getShadowGenerators() {
    return this._shadowGenerators;
  }
  getAbsolutePosition() {
    return p.Zero();
  }
  canAffectMesh(e) {
    return e ? !(this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(e) === -1 || this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(e) !== -1 || this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & e.layerMask) === 0 || this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & e.layerMask) : !0;
  }
  dispose(e, t = !1) {
    if (this._shadowGenerators) {
      const i = this._shadowGenerators.values();
      for (let s = i.next(); s.done !== !0; s = i.next())
        s.value.dispose();
      this._shadowGenerators = null;
    }
    if (this.getScene().stopAnimation(this), this._parentContainer) {
      const i = this._parentContainer.lights.indexOf(this);
      i > -1 && this._parentContainer.lights.splice(i, 1), this._parentContainer = null;
    }
    for (const i of this.getScene().meshes)
      i._removeLightSource(this, !0);
    this._uniformBuffer.dispose(), this.getScene().removeLight(this), super.dispose(e, t);
  }
  getTypeID() {
    return 0;
  }
  getScaledIntensity() {
    return this._photometricScale * this.intensity;
  }
  clone(e, t = null) {
    const i = he.GetConstructorFromName(this.getTypeID(), e, this.getScene());
    if (!i)
      return null;
    const s = ae.Clone(i, this);
    return e && (s.name = e), t && (s.parent = t), s.setEnabled(this.isEnabled()), this.onClonedObservable.notifyObservers(s), s;
  }
  serialize() {
    const e = ae.Serialize(this);
    return e.uniqueId = this.uniqueId, e.type = this.getTypeID(), this.parent && this.parent._serializeAsParent(e), this.excludedMeshes.length > 0 && (e.excludedMeshesIds = [], this.excludedMeshes.forEach((t) => {
      e.excludedMeshesIds.push(t.id);
    })), this.includedOnlyMeshes.length > 0 && (e.includedOnlyMeshesIds = [], this.includedOnlyMeshes.forEach((t) => {
      e.includedOnlyMeshesIds.push(t.id);
    })), ae.AppendSerializedAnimations(this, e), e.ranges = this.serializeAnimationRanges(), e.isEnabled = this.isEnabled(), e;
  }
  static GetConstructorFromName(e, t, i) {
    const s = Xe.Construct("Light_Type_" + e, t, i);
    return s || null;
  }
  static Parse(e, t) {
    const i = he.GetConstructorFromName(e.type, e.name, t);
    if (!i)
      return null;
    const s = ae.Parse(i, e, t);
    if (e.excludedMeshesIds && (s._excludedMeshesIds = e.excludedMeshesIds), e.includedOnlyMeshesIds && (s._includedOnlyMeshesIds = e.includedOnlyMeshesIds), e.parentId !== void 0 && (s._waitingParentId = e.parentId), e.parentInstanceIndex !== void 0 && (s._waitingParentInstanceIndex = e.parentInstanceIndex), e.falloffType !== void 0 && (s.falloffType = e.falloffType), e.lightmapMode !== void 0 && (s.lightmapMode = e.lightmapMode), e.animations) {
      for (let r = 0; r < e.animations.length; r++) {
        const n = e.animations[r], a = ci("BABYLON.Animation");
        a && s.animations.push(a.Parse(n));
      }
      Xe.ParseAnimationRanges(s, e, t);
    }
    return e.autoAnimate && t.beginAnimation(s, e.autoAnimateFrom, e.autoAnimateTo, e.autoAnimateLoop, e.autoAnimateSpeed || 1), e.isEnabled !== void 0 && s.setEnabled(e.isEnabled), s;
  }
  _hookArrayForExcluded(e) {
    const t = e.push;
    e.push = (...s) => {
      const r = t.apply(e, s);
      for (const n of s)
        n._resyncLightSource(this);
      return r;
    };
    const i = e.splice;
    e.splice = (s, r) => {
      const n = i.apply(e, [s, r]);
      for (const a of n)
        a._resyncLightSource(this);
      return n;
    };
    for (const s of e)
      s._resyncLightSource(this);
  }
  _hookArrayForIncludedOnly(e) {
    const t = e.push;
    e.push = (...s) => {
      const r = t.apply(e, s);
      return this._resyncMeshes(), r;
    };
    const i = e.splice;
    e.splice = (s, r) => {
      const n = i.apply(e, [s, r]);
      return this._resyncMeshes(), n;
    }, this._resyncMeshes();
  }
  _resyncMeshes() {
    for (const e of this.getScene().meshes)
      e._resyncLightSource(this);
  }
  _markMeshesAsLightDirty() {
    for (const e of this.getScene().meshes)
      e.lightSources.indexOf(this) !== -1 && e._markSubMeshesAsLightDirty();
  }
  _computePhotometricScale() {
    this._photometricScale = this._getPhotometricScale(), this.getScene().resetCachedMaterial();
  }
  _getPhotometricScale() {
    let e = 0;
    const t = this.getTypeID();
    let i = this.intensityMode;
    switch (i === he.INTENSITYMODE_AUTOMATIC && (t === he.LIGHTTYPEID_DIRECTIONALLIGHT ? i = he.INTENSITYMODE_ILLUMINANCE : i = he.INTENSITYMODE_LUMINOUSINTENSITY), t) {
      case he.LIGHTTYPEID_POINTLIGHT:
      case he.LIGHTTYPEID_SPOTLIGHT:
        switch (i) {
          case he.INTENSITYMODE_LUMINOUSPOWER:
            e = 1 / (4 * Math.PI);
            break;
          case he.INTENSITYMODE_LUMINOUSINTENSITY:
            e = 1;
            break;
          case he.INTENSITYMODE_LUMINANCE:
            e = this.radius * this.radius;
            break;
        }
        break;
      case he.LIGHTTYPEID_DIRECTIONALLIGHT:
        switch (i) {
          case he.INTENSITYMODE_ILLUMINANCE:
            e = 1;
            break;
          case he.INTENSITYMODE_LUMINANCE: {
            let s = this.radius;
            s = Math.max(s, 1e-3), e = 2 * Math.PI * (1 - Math.cos(s));
            break;
          }
        }
        break;
      case he.LIGHTTYPEID_HEMISPHERICLIGHT:
        e = 1;
        break;
    }
    return e;
  }
  _reorderLightsInScene() {
    const e = this.getScene();
    this._renderPriority != 0 && (e.requireLightSorting = !0), this.getScene().sortLightsByPriority();
  }
}
he.FALLOFF_DEFAULT = Ee.FALLOFF_DEFAULT;
he.FALLOFF_PHYSICAL = Ee.FALLOFF_PHYSICAL;
he.FALLOFF_GLTF = Ee.FALLOFF_GLTF;
he.FALLOFF_STANDARD = Ee.FALLOFF_STANDARD;
he.LIGHTMAP_DEFAULT = Ee.LIGHTMAP_DEFAULT;
he.LIGHTMAP_SPECULAR = Ee.LIGHTMAP_SPECULAR;
he.LIGHTMAP_SHADOWSONLY = Ee.LIGHTMAP_SHADOWSONLY;
he.INTENSITYMODE_AUTOMATIC = Ee.INTENSITYMODE_AUTOMATIC;
he.INTENSITYMODE_LUMINOUSPOWER = Ee.INTENSITYMODE_LUMINOUSPOWER;
he.INTENSITYMODE_LUMINOUSINTENSITY = Ee.INTENSITYMODE_LUMINOUSINTENSITY;
he.INTENSITYMODE_ILLUMINANCE = Ee.INTENSITYMODE_ILLUMINANCE;
he.INTENSITYMODE_LUMINANCE = Ee.INTENSITYMODE_LUMINANCE;
he.LIGHTTYPEID_POINTLIGHT = Ee.LIGHTTYPEID_POINTLIGHT;
he.LIGHTTYPEID_DIRECTIONALLIGHT = Ee.LIGHTTYPEID_DIRECTIONALLIGHT;
he.LIGHTTYPEID_SPOTLIGHT = Ee.LIGHTTYPEID_SPOTLIGHT;
he.LIGHTTYPEID_HEMISPHERICLIGHT = Ee.LIGHTTYPEID_HEMISPHERICLIGHT;
T([
  di()
], he.prototype, "diffuse", void 0);
T([
  di()
], he.prototype, "specular", void 0);
T([
  R()
], he.prototype, "falloffType", void 0);
T([
  R()
], he.prototype, "intensity", void 0);
T([
  R()
], he.prototype, "range", null);
T([
  R()
], he.prototype, "intensityMode", null);
T([
  R()
], he.prototype, "radius", null);
T([
  R()
], he.prototype, "_renderPriority", void 0);
T([
  be("_reorderLightsInScene")
], he.prototype, "renderPriority", void 0);
T([
  R("shadowEnabled")
], he.prototype, "_shadowEnabled", void 0);
T([
  R("excludeWithLayerMask")
], he.prototype, "_excludeWithLayerMask", void 0);
T([
  R("includeOnlyWithLayerMask")
], he.prototype, "_includeOnlyWithLayerMask", void 0);
T([
  R("lightmapMode")
], he.prototype, "_lightmapMode", void 0);
class Wi extends he {
  constructor() {
    super(...arguments), this._needProjectionMatrixCompute = !0;
  }
  _setPosition(e) {
    this._position = e;
  }
  get position() {
    return this._position;
  }
  set position(e) {
    this._setPosition(e);
  }
  _setDirection(e) {
    this._direction = e;
  }
  get direction() {
    return this._direction;
  }
  set direction(e) {
    this._setDirection(e);
  }
  get shadowMinZ() {
    return this._shadowMinZ;
  }
  set shadowMinZ(e) {
    this._shadowMinZ = e, this.forceProjectionMatrixCompute();
  }
  get shadowMaxZ() {
    return this._shadowMaxZ;
  }
  set shadowMaxZ(e) {
    this._shadowMaxZ = e, this.forceProjectionMatrixCompute();
  }
  computeTransformedInformation() {
    return this.parent && this.parent.getWorldMatrix ? (this.transformedPosition || (this.transformedPosition = p.Zero()), p.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition), this.direction && (this.transformedDirection || (this.transformedDirection = p.Zero()), p.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection)), !0) : !1;
  }
  getDepthScale() {
    return 50;
  }
  getShadowDirection(e) {
    return this.transformedDirection ? this.transformedDirection : this.direction;
  }
  getAbsolutePosition() {
    return this.transformedPosition ? this.transformedPosition : this.position;
  }
  setDirectionToTarget(e) {
    return this.direction = p.Normalize(e.subtract(this.position)), this.direction;
  }
  getRotation() {
    this.direction.normalize();
    const e = p.Cross(this.direction, ui.Y), t = p.Cross(e, this.direction);
    return p.RotationFromAxis(e, t, this.direction);
  }
  needCube() {
    return !1;
  }
  needProjectionMatrixCompute() {
    return this._needProjectionMatrixCompute;
  }
  forceProjectionMatrixCompute() {
    this._needProjectionMatrixCompute = !0;
  }
  _initCache() {
    super._initCache(), this._cache.position = p.Zero();
  }
  _isSynchronized() {
    return !!this._cache.position.equals(this.position);
  }
  computeWorldMatrix(e) {
    return !e && this.isSynchronized() ? (this._currentRenderId = this.getScene().getRenderId(), this._worldMatrix) : (this._updateCache(), this._cache.position.copyFrom(this.position), this._worldMatrix || (this._worldMatrix = x.Identity()), x.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix), this.parent && this.parent.getWorldMatrix && (this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix), this._markSyncedWithParent()), this._worldMatrixDeterminantIsDirty = !0, this._worldMatrix);
  }
  getDepthMinZ(e) {
    return this.shadowMinZ !== void 0 ? this.shadowMinZ : e.minZ;
  }
  getDepthMaxZ(e) {
    return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : e.maxZ;
  }
  setShadowProjectionMatrix(e, t, i) {
    return this.customProjectionMatrixBuilder ? this.customProjectionMatrixBuilder(t, i, e) : this._setDefaultShadowProjectionMatrix(e, t, i), this;
  }
  _syncParentEnabledState() {
    super._syncParentEnabledState(), (!this.parent || !this.parent.getWorldMatrix) && (this.transformedPosition = null, this.transformedDirection = null);
  }
}
T([
  Gt()
], Wi.prototype, "position", null);
T([
  Gt()
], Wi.prototype, "direction", null);
T([
  R()
], Wi.prototype, "shadowMinZ", null);
T([
  R()
], Wi.prototype, "shadowMaxZ", null);
Xe.AddNodeConstructor("Light_Type_1", (c, e) => () => new Pt(c, p.Zero(), e));
class Pt extends Wi {
  constructor(e, t, i) {
    super(e, i), this._shadowFrustumSize = 0, this._shadowOrthoScale = 0.1, this.autoUpdateExtends = !0, this.autoCalcShadowZBounds = !1, this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE, this.position = t.scale(-1), this.direction = t;
  }
  get shadowFrustumSize() {
    return this._shadowFrustumSize;
  }
  set shadowFrustumSize(e) {
    this._shadowFrustumSize = e, this.forceProjectionMatrixCompute();
  }
  get shadowOrthoScale() {
    return this._shadowOrthoScale;
  }
  set shadowOrthoScale(e) {
    this._shadowOrthoScale = e, this.forceProjectionMatrixCompute();
  }
  get orthoLeft() {
    return this._orthoLeft;
  }
  set orthoLeft(e) {
    this._orthoLeft = e;
  }
  get orthoRight() {
    return this._orthoRight;
  }
  set orthoRight(e) {
    this._orthoRight = e;
  }
  get orthoTop() {
    return this._orthoTop;
  }
  set orthoTop(e) {
    this._orthoTop = e;
  }
  get orthoBottom() {
    return this._orthoBottom;
  }
  set orthoBottom(e) {
    this._orthoBottom = e;
  }
  getClassName() {
    return "DirectionalLight";
  }
  getTypeID() {
    return he.LIGHTTYPEID_DIRECTIONALLIGHT;
  }
  _setDefaultShadowProjectionMatrix(e, t, i) {
    this.shadowFrustumSize > 0 ? this._setDefaultFixedFrustumShadowProjectionMatrix(e) : this._setDefaultAutoExtendShadowProjectionMatrix(e, t, i);
  }
  _setDefaultFixedFrustumShadowProjectionMatrix(e) {
    const t = this.getScene().activeCamera;
    !t || x.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : t.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : t.maxZ, e, this.getScene().getEngine().isNDCHalfZRange);
  }
  _setDefaultAutoExtendShadowProjectionMatrix(e, t, i) {
    const s = this.getScene().activeCamera;
    if (!s)
      return;
    if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
      const l = p.Zero();
      this._orthoLeft = Number.MAX_VALUE, this._orthoRight = Number.MIN_VALUE, this._orthoTop = Number.MIN_VALUE, this._orthoBottom = Number.MAX_VALUE;
      let u = Number.MAX_VALUE, d = Number.MIN_VALUE;
      for (let f = 0; f < i.length; f++) {
        const _ = i[f];
        if (!_)
          continue;
        const m = _.getBoundingInfo().boundingBox;
        for (let v = 0; v < m.vectorsWorld.length; v++)
          p.TransformCoordinatesToRef(m.vectorsWorld[v], t, l), l.x < this._orthoLeft && (this._orthoLeft = l.x), l.y < this._orthoBottom && (this._orthoBottom = l.y), l.x > this._orthoRight && (this._orthoRight = l.x), l.y > this._orthoTop && (this._orthoTop = l.y), this.autoCalcShadowZBounds && (l.z < u && (u = l.z), l.z > d && (d = l.z));
      }
      this.autoCalcShadowZBounds && (this._shadowMinZ = u, this._shadowMaxZ = d);
    }
    const r = this._orthoRight - this._orthoLeft, n = this._orthoTop - this._orthoBottom, a = this.shadowMinZ !== void 0 ? this.shadowMinZ : s.minZ, o = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : s.maxZ, h = this.getScene().getEngine().useReverseDepthBuffer;
    x.OrthoOffCenterLHToRef(this._orthoLeft - r * this.shadowOrthoScale, this._orthoRight + r * this.shadowOrthoScale, this._orthoBottom - n * this.shadowOrthoScale, this._orthoTop + n * this.shadowOrthoScale, h ? o : a, h ? a : o, e, this.getScene().getEngine().isNDCHalfZRange);
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create();
  }
  transferToEffect(e, t) {
    return this.computeTransformedInformation() ? (this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, t), this) : (this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, t), this);
  }
  transferToNodeMaterialEffect(e, t) {
    return this.computeTransformedInformation() ? (e.setFloat3(t, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z), this) : (e.setFloat3(t, this.direction.x, this.direction.y, this.direction.z), this);
  }
  getDepthMinZ(e) {
    const t = this._scene.getEngine();
    return !t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1;
  }
  getDepthMaxZ(e) {
    const t = this._scene.getEngine();
    return t.useReverseDepthBuffer && t.isNDCHalfZRange ? 0 : 1;
  }
  prepareLightSpecificDefines(e, t) {
    e["DIRLIGHT" + t] = !0;
  }
}
T([
  R()
], Pt.prototype, "shadowFrustumSize", null);
T([
  R()
], Pt.prototype, "shadowOrthoScale", null);
T([
  R()
], Pt.prototype, "autoUpdateExtends", void 0);
T([
  R()
], Pt.prototype, "autoCalcShadowZBounds", void 0);
T([
  R("orthoLeft")
], Pt.prototype, "_orthoLeft", void 0);
T([
  R("orthoRight")
], Pt.prototype, "_orthoRight", void 0);
T([
  R("orthoTop")
], Pt.prototype, "_orthoTop", void 0);
T([
  R("orthoBottom")
], Pt.prototype, "_orthoBottom", void 0);
Xe.AddNodeConstructor("Light_Type_3", (c, e) => () => new us(c, p.Zero(), e));
class us extends he {
  constructor(e, t, i) {
    super(e, i), this.groundColor = new se(0, 0, 0), this.direction = t || p.Up();
  }
  _buildUniformLayout() {
    this._uniformBuffer.addUniform("vLightData", 4), this._uniformBuffer.addUniform("vLightDiffuse", 4), this._uniformBuffer.addUniform("vLightSpecular", 4), this._uniformBuffer.addUniform("vLightGround", 3), this._uniformBuffer.addUniform("shadowsInfo", 3), this._uniformBuffer.addUniform("depthValues", 2), this._uniformBuffer.create();
  }
  getClassName() {
    return "HemisphericLight";
  }
  setDirectionToTarget(e) {
    return this.direction = p.Normalize(e.subtract(p.Zero())), this.direction;
  }
  getShadowGenerator() {
    return null;
  }
  transferToEffect(e, t) {
    const i = p.Normalize(this.direction);
    return this._uniformBuffer.updateFloat4("vLightData", i.x, i.y, i.z, 0, t), this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), t), this;
  }
  transferToNodeMaterialEffect(e, t) {
    const i = p.Normalize(this.direction);
    return e.setFloat3(t, i.x, i.y, i.z), this;
  }
  computeWorldMatrix() {
    return this._worldMatrix || (this._worldMatrix = x.Identity()), this._worldMatrix;
  }
  getTypeID() {
    return he.LIGHTTYPEID_HEMISPHERICLIGHT;
  }
  prepareLightSpecificDefines(e, t) {
    e["HEMILIGHT" + t] = !0;
  }
}
T([
  di()
], us.prototype, "groundColor", void 0);
T([
  Gt()
], us.prototype, "direction", void 0);
class Bt {
  constructor(e, t) {
    this.width = e, this.height = t;
  }
  toString() {
    return `{W: ${this.width}, H: ${this.height}}`;
  }
  getClassName() {
    return "Size";
  }
  getHashCode() {
    let e = this.width | 0;
    return e = e * 397 ^ (this.height | 0), e;
  }
  copyFrom(e) {
    this.width = e.width, this.height = e.height;
  }
  copyFromFloats(e, t) {
    return this.width = e, this.height = t, this;
  }
  set(e, t) {
    return this.copyFromFloats(e, t);
  }
  multiplyByFloats(e, t) {
    return new Bt(this.width * e, this.height * t);
  }
  clone() {
    return new Bt(this.width, this.height);
  }
  equals(e) {
    return e ? this.width === e.width && this.height === e.height : !1;
  }
  get surface() {
    return this.width * this.height;
  }
  static Zero() {
    return new Bt(0, 0);
  }
  add(e) {
    return new Bt(this.width + e.width, this.height + e.height);
  }
  subtract(e) {
    return new Bt(this.width - e.width, this.height - e.height);
  }
  static Lerp(e, t, i) {
    const s = e.width + (t.width - e.width) * i, r = e.height + (t.height - e.height) * i;
    return new Bt(s, r);
  }
}
class Jn {
  constructor(e) {
    this._wrapU = 1, this._wrapV = 1, this.wrapR = 1, this.anisotropicFilteringLevel = 4, this.delayLoadState = 0, this._texture = null, this._engine = null, this._cachedSize = Bt.Zero(), this._cachedBaseSize = Bt.Zero(), this._initialSamplingMode = 2, this._texture = e, this._texture && (this._engine = this._texture.getEngine());
  }
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(e) {
    this._wrapU = e;
  }
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(e) {
    this._wrapV = e;
  }
  get coordinatesMode() {
    return 0;
  }
  get isCube() {
    return this._texture ? this._texture.isCube : !1;
  }
  set isCube(e) {
    !this._texture || (this._texture.isCube = e);
  }
  get is3D() {
    return this._texture ? this._texture.is3D : !1;
  }
  set is3D(e) {
    !this._texture || (this._texture.is3D = e);
  }
  get is2DArray() {
    return this._texture ? this._texture.is2DArray : !1;
  }
  set is2DArray(e) {
    !this._texture || (this._texture.is2DArray = e);
  }
  getClassName() {
    return "ThinTexture";
  }
  isReady() {
    return this.delayLoadState === 4 ? (this.delayLoad(), !1) : this._texture ? this._texture.isReady : !1;
  }
  delayLoad() {
  }
  getInternalTexture() {
    return this._texture;
  }
  getSize() {
    if (this._texture) {
      if (this._texture.width)
        return this._cachedSize.width = this._texture.width, this._cachedSize.height = this._texture.height, this._cachedSize;
      if (this._texture._size)
        return this._cachedSize.width = this._texture._size, this._cachedSize.height = this._texture._size, this._cachedSize;
    }
    return this._cachedSize;
  }
  getBaseSize() {
    return !this.isReady() || !this._texture ? (this._cachedBaseSize.width = 0, this._cachedBaseSize.height = 0, this._cachedBaseSize) : this._texture._size ? (this._cachedBaseSize.width = this._texture._size, this._cachedBaseSize.height = this._texture._size, this._cachedBaseSize) : (this._cachedBaseSize.width = this._texture.baseWidth, this._cachedBaseSize.height = this._texture.baseHeight, this._cachedBaseSize);
  }
  get samplingMode() {
    return this._texture ? this._texture.samplingMode : this._initialSamplingMode;
  }
  updateSamplingMode(e) {
    this._texture && this._engine && this._engine.updateTextureSamplingMode(e, this._texture);
  }
  releaseInternalTexture() {
    this._texture && (this._texture.dispose(), this._texture = null);
  }
  dispose() {
    this._texture && (this.releaseInternalTexture(), this._engine = null);
  }
}
class Me extends Jn {
  constructor(e, t = null) {
    super(null), this.metadata = null, this.reservedDataStore = null, this._hasAlpha = !1, this._getAlphaFromRGB = !1, this.level = 1, this._coordinatesIndex = 0, this.optimizeUVAllocation = !0, this._coordinatesMode = 0, this.wrapR = 1, this.anisotropicFilteringLevel = Me.DEFAULT_ANISOTROPIC_FILTERING_LEVEL, this._isCube = !1, this._gammaSpace = !0, this.invertZ = !1, this.lodLevelInAlpha = !1, this.isRenderTarget = !1, this._prefiltered = !1, this._forceSerialize = !1, this.animations = new Array(), this.onDisposeObservable = new w(), this._onDisposeObserver = null, this._scene = null, this._uid = null, this._parentContainer = null, this._loadingError = !1, e ? Me._IsScene(e) ? this._scene = e : this._engine = e : this._scene = fe.LastCreatedScene, this._scene && (this.uniqueId = this._scene.getUniqueId(), this._scene.addTexture(this), this._engine = this._scene.getEngine()), this._texture = t, this._uid = null;
  }
  set hasAlpha(e) {
    this._hasAlpha !== e && (this._hasAlpha = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get hasAlpha() {
    return this._hasAlpha;
  }
  set getAlphaFromRGB(e) {
    this._getAlphaFromRGB !== e && (this._getAlphaFromRGB = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get getAlphaFromRGB() {
    return this._getAlphaFromRGB;
  }
  set coordinatesIndex(e) {
    this._coordinatesIndex !== e && (this._coordinatesIndex = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get coordinatesIndex() {
    return this._coordinatesIndex;
  }
  set coordinatesMode(e) {
    this._coordinatesMode !== e && (this._coordinatesMode = e, this._scene && this._scene.markAllMaterialsAsDirty(1, (t) => t.hasTexture(this)));
  }
  get coordinatesMode() {
    return this._coordinatesMode;
  }
  get wrapU() {
    return this._wrapU;
  }
  set wrapU(e) {
    this._wrapU = e;
  }
  get wrapV() {
    return this._wrapV;
  }
  set wrapV(e) {
    this._wrapV = e;
  }
  get isCube() {
    return this._texture ? this._texture.isCube : this._isCube;
  }
  set isCube(e) {
    this._texture ? this._texture.isCube = e : this._isCube = e;
  }
  get is3D() {
    return this._texture ? this._texture.is3D : !1;
  }
  set is3D(e) {
    !this._texture || (this._texture.is3D = e);
  }
  get is2DArray() {
    return this._texture ? this._texture.is2DArray : !1;
  }
  set is2DArray(e) {
    !this._texture || (this._texture.is2DArray = e);
  }
  get gammaSpace() {
    if (this._texture)
      this._texture._gammaSpace === null && (this._texture._gammaSpace = this._gammaSpace);
    else
      return this._gammaSpace;
    return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
  }
  set gammaSpace(e) {
    if (this._texture) {
      if (this._texture._gammaSpace === e)
        return;
      this._texture._gammaSpace = e;
    } else {
      if (this._gammaSpace === e)
        return;
      this._gammaSpace = e;
    }
    this._markAllSubMeshesAsTexturesDirty();
  }
  get isRGBD() {
    return this._texture != null && this._texture._isRGBD;
  }
  set isRGBD(e) {
    this._texture && (this._texture._isRGBD = e);
  }
  get noMipmap() {
    return !1;
  }
  get lodGenerationOffset() {
    return this._texture ? this._texture._lodGenerationOffset : 0;
  }
  set lodGenerationOffset(e) {
    this._texture && (this._texture._lodGenerationOffset = e);
  }
  get lodGenerationScale() {
    return this._texture ? this._texture._lodGenerationScale : 0;
  }
  set lodGenerationScale(e) {
    this._texture && (this._texture._lodGenerationScale = e);
  }
  get linearSpecularLOD() {
    return this._texture ? this._texture._linearSpecularLOD : !1;
  }
  set linearSpecularLOD(e) {
    this._texture && (this._texture._linearSpecularLOD = e);
  }
  get irradianceTexture() {
    return this._texture ? this._texture._irradianceTexture : null;
  }
  set irradianceTexture(e) {
    this._texture && (this._texture._irradianceTexture = e);
  }
  get uid() {
    return this._uid || (this._uid = Dr()), this._uid;
  }
  toString() {
    return this.name;
  }
  getClassName() {
    return "BaseTexture";
  }
  set onDispose(e) {
    this._onDisposeObserver && this.onDisposeObservable.remove(this._onDisposeObserver), this._onDisposeObserver = this.onDisposeObservable.add(e);
  }
  get isBlocking() {
    return !0;
  }
  get loadingError() {
    return this._loadingError;
  }
  get errorObject() {
    return this._errorObject;
  }
  getScene() {
    return this._scene;
  }
  _getEngine() {
    return this._engine;
  }
  checkTransformsAreIdentical(e) {
    return e !== null;
  }
  getTextureMatrix() {
    return x.IdentityReadOnly;
  }
  getReflectionTextureMatrix() {
    return x.IdentityReadOnly;
  }
  isReadyOrNotBlocking() {
    return !this.isBlocking || this.isReady() || this.loadingError;
  }
  scale(e) {
  }
  get canRescale() {
    return !1;
  }
  _getFromCache(e, t, i, s, r, n) {
    const a = this._getEngine();
    if (!a)
      return null;
    const o = a._getUseSRGBBuffer(!!r, t), h = a.getLoadedTexturesCache();
    for (let l = 0; l < h.length; l++) {
      const u = h[l];
      if ((r === void 0 || o === u._useSRGBBuffer) && (s === void 0 || s === u.invertY) && u.url === e && u.generateMipMaps === !t && (!i || i === u.samplingMode) && (n === void 0 || n === u.isCube))
        return u.incrementReferences(), u;
    }
    return null;
  }
  _rebuild() {
  }
  clone() {
    return null;
  }
  get textureType() {
    return this._texture && this._texture.type !== void 0 ? this._texture.type : 0;
  }
  get textureFormat() {
    return this._texture && this._texture.format !== void 0 ? this._texture.format : 5;
  }
  _markAllSubMeshesAsTexturesDirty() {
    const e = this.getScene();
    !e || e.markAllMaterialsAsDirty(1);
  }
  readPixels(e = 0, t = 0, i = null, s = !0, r = !1, n = 0, a = 0, o = Number.MAX_VALUE, h = Number.MAX_VALUE) {
    if (!this._texture)
      return null;
    const l = this._getEngine();
    if (!l)
      return null;
    const u = this.getSize();
    let d = u.width, f = u.height;
    t !== 0 && (d = d / Math.pow(2, t), f = f / Math.pow(2, t), d = Math.round(d), f = Math.round(f)), o = Math.min(d, o), h = Math.min(f, h);
    try {
      return this._texture.isCube ? l._readTexturePixels(this._texture, o, h, e, t, i, s, r, n, a) : l._readTexturePixels(this._texture, o, h, -1, t, i, s, r, n, a);
    } catch {
      return null;
    }
  }
  _readPixelsSync(e = 0, t = 0, i = null, s = !0, r = !1) {
    if (!this._texture)
      return null;
    const n = this.getSize();
    let a = n.width, o = n.height;
    const h = this._getEngine();
    if (!h)
      return null;
    t != 0 && (a = a / Math.pow(2, t), o = o / Math.pow(2, t), a = Math.round(a), o = Math.round(o));
    try {
      return this._texture.isCube ? h._readTexturePixelsSync(this._texture, a, o, e, t, i, s, r) : h._readTexturePixelsSync(this._texture, a, o, -1, t, i, s, r);
    } catch {
      return null;
    }
  }
  get _lodTextureHigh() {
    return this._texture ? this._texture._lodTextureHigh : null;
  }
  get _lodTextureMid() {
    return this._texture ? this._texture._lodTextureMid : null;
  }
  get _lodTextureLow() {
    return this._texture ? this._texture._lodTextureLow : null;
  }
  dispose() {
    if (this._scene) {
      this._scene.stopAnimation && this._scene.stopAnimation(this), this._scene.removePendingData(this);
      const e = this._scene.textures.indexOf(this);
      if (e >= 0 && this._scene.textures.splice(e, 1), this._scene.onTextureRemovedObservable.notifyObservers(this), this._scene = null, this._parentContainer) {
        const t = this._parentContainer.textures.indexOf(this);
        t > -1 && this._parentContainer.textures.splice(t, 1), this._parentContainer = null;
      }
    }
    this.onDisposeObservable.notifyObservers(this), this.onDisposeObservable.clear(), this.metadata = null, super.dispose();
  }
  serialize(e = !1) {
    if (!this.name && !e)
      return null;
    const t = ae.Serialize(this);
    return ae.AppendSerializedAnimations(this, t), t;
  }
  static WhenAllReady(e, t) {
    let i = e.length;
    if (i === 0) {
      t();
      return;
    }
    for (let s = 0; s < e.length; s++) {
      const r = e[s];
      if (r.isReady())
        --i === 0 && t();
      else {
        const n = r.onLoadObservable;
        n ? n.addOnce(() => {
          --i === 0 && t();
        }) : --i === 0 && t();
      }
    }
  }
  static _IsScene(e) {
    return e.getClassName() === "Scene";
  }
}
Me.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
T([
  R()
], Me.prototype, "uniqueId", void 0);
T([
  R()
], Me.prototype, "name", void 0);
T([
  R()
], Me.prototype, "metadata", void 0);
T([
  R("hasAlpha")
], Me.prototype, "_hasAlpha", void 0);
T([
  R("getAlphaFromRGB")
], Me.prototype, "_getAlphaFromRGB", void 0);
T([
  R()
], Me.prototype, "level", void 0);
T([
  R("coordinatesIndex")
], Me.prototype, "_coordinatesIndex", void 0);
T([
  R()
], Me.prototype, "optimizeUVAllocation", void 0);
T([
  R("coordinatesMode")
], Me.prototype, "_coordinatesMode", void 0);
T([
  R()
], Me.prototype, "wrapU", null);
T([
  R()
], Me.prototype, "wrapV", null);
T([
  R()
], Me.prototype, "wrapR", void 0);
T([
  R()
], Me.prototype, "anisotropicFilteringLevel", void 0);
T([
  R()
], Me.prototype, "isCube", null);
T([
  R()
], Me.prototype, "is3D", null);
T([
  R()
], Me.prototype, "is2DArray", null);
T([
  R()
], Me.prototype, "gammaSpace", null);
T([
  R()
], Me.prototype, "invertZ", void 0);
T([
  R()
], Me.prototype, "lodLevelInAlpha", void 0);
T([
  R()
], Me.prototype, "lodGenerationOffset", null);
T([
  R()
], Me.prototype, "lodGenerationScale", null);
T([
  R()
], Me.prototype, "linearSpecularLOD", null);
T([
  vt()
], Me.prototype, "irradianceTexture", null);
T([
  R()
], Me.prototype, "isRenderTarget", void 0);
function Br(c, e, t = !1) {
  const i = e.width, s = e.height;
  if (c instanceof Float32Array) {
    let h = c.byteLength / c.BYTES_PER_ELEMENT;
    const l = new Uint8Array(h);
    for (; --h >= 0; ) {
      let u = c[h];
      u < 0 ? u = 0 : u > 1 && (u = 1), l[h] = u * 255;
    }
    c = l;
  }
  const r = document.createElement("canvas");
  r.width = i, r.height = s;
  const n = r.getContext("2d");
  if (!n)
    return null;
  const a = n.createImageData(i, s);
  if (a.data.set(c), n.putImageData(a, 0, 0), t) {
    const h = document.createElement("canvas");
    h.width = i, h.height = s;
    const l = h.getContext("2d");
    return l ? (l.translate(0, s), l.scale(1, -1), l.drawImage(r, 0, 0), h.toDataURL("image/png")) : null;
  }
  return r.toDataURL("image/png");
}
function ea(c, e = 0, t = 0) {
  const i = c.getInternalTexture();
  if (!i)
    return null;
  const s = c._readPixelsSync(e, t);
  return s ? Br(s, c.getSize(), i.invertY) : null;
}
async function ta(c, e = 0, t = 0) {
  const i = c.getInternalTexture();
  if (!i)
    return null;
  const s = await c.readPixels(e, t);
  return s ? Br(s, c.getSize(), i.invertY) : null;
}
class B extends Me {
  constructor(e, t, i, s, r = B.TRILINEAR_SAMPLINGMODE, n = null, a = null, o = null, h = !1, l, u, d, f, _) {
    var E, m, v, S, y, A, C, b, M;
    super(t), this.url = null, this.uOffset = 0, this.vOffset = 0, this.uScale = 1, this.vScale = 1, this.uAng = 0, this.vAng = 0, this.wAng = 0, this.uRotationCenter = 0.5, this.vRotationCenter = 0.5, this.wRotationCenter = 0.5, this.homogeneousRotationInUVTransform = !1, this.inspectableCustomProperties = null, this._noMipmap = !1, this._invertY = !1, this._rowGenerationMatrix = null, this._cachedTextureMatrix = null, this._projectionModeMatrix = null, this._t0 = null, this._t1 = null, this._t2 = null, this._cachedUOffset = -1, this._cachedVOffset = -1, this._cachedUScale = 0, this._cachedVScale = 0, this._cachedUAng = -1, this._cachedVAng = -1, this._cachedWAng = -1, this._cachedReflectionProjectionMatrixId = -1, this._cachedURotationCenter = -1, this._cachedVRotationCenter = -1, this._cachedWRotationCenter = -1, this._cachedHomogeneousRotationInUVTransform = !1, this._cachedReflectionTextureMatrix = null, this._cachedReflectionUOffset = -1, this._cachedReflectionVOffset = -1, this._cachedReflectionUScale = 0, this._cachedReflectionVScale = 0, this._cachedReflectionCoordinatesMode = -1, this._buffer = null, this._deleteBuffer = !1, this._format = null, this._delayedOnLoad = null, this._delayedOnError = null, this.onLoadObservable = new w(), this._isBlocking = !0, this.name = e || "", this.url = e;
    let L, k = !1, F = null;
    typeof i == "object" && i !== null ? (L = (E = i.noMipmap) !== null && E !== void 0 ? E : !1, s = (m = i.invertY) !== null && m !== void 0 ? m : !ut.UseOpenGLOrientationForUV, r = (v = i.samplingMode) !== null && v !== void 0 ? v : B.TRILINEAR_SAMPLINGMODE, n = (S = i.onLoad) !== null && S !== void 0 ? S : null, a = (y = i.onError) !== null && y !== void 0 ? y : null, o = (A = i.buffer) !== null && A !== void 0 ? A : null, h = (C = i.deleteBuffer) !== null && C !== void 0 ? C : !1, l = i.format, u = i.mimeType, d = i.loaderOptions, f = i.creationFlags, k = (b = i.useSRGBBuffer) !== null && b !== void 0 ? b : !1, F = (M = i.internalTexture) !== null && M !== void 0 ? M : null) : L = !!i, this._noMipmap = L, this._invertY = s === void 0 ? !ut.UseOpenGLOrientationForUV : s, this._initialSamplingMode = r, this._buffer = o, this._deleteBuffer = h, this._mimeType = u, this._loaderOptions = d, this._creationFlags = f, this._useSRGBBuffer = k, this._forcedExtension = _, l && (this._format = l);
    const ue = this.getScene(), ce = this._getEngine();
    if (!ce)
      return;
    ce.onBeforeTextureInitObservable.notifyObservers(this);
    const ie = () => {
      this._texture && (this._texture._invertVScale && (this.vScale *= -1, this.vOffset += 1), this._texture._cachedWrapU !== null && (this.wrapU = this._texture._cachedWrapU, this._texture._cachedWrapU = null), this._texture._cachedWrapV !== null && (this.wrapV = this._texture._cachedWrapV, this._texture._cachedWrapV = null), this._texture._cachedWrapR !== null && (this.wrapR = this._texture._cachedWrapR, this._texture._cachedWrapR = null)), this.onLoadObservable.hasObservers() && this.onLoadObservable.notifyObservers(this), n && n(), !this.isBlocking && ue && ue.resetCachedMaterial();
    }, ee = (Ce, Ie) => {
      this._loadingError = !0, this._errorObject = { message: Ce, exception: Ie }, a && a(Ce, Ie), B.OnTextureLoadErrorObservable.notifyObservers(this);
    };
    if (!this.url && !F) {
      this._delayedOnLoad = ie, this._delayedOnError = ee;
      return;
    }
    if (this._texture = F != null ? F : this._getFromCache(this.url, L, r, this._invertY, k), this._texture)
      if (this._texture.isReady)
        ji.SetImmediate(() => ie());
      else {
        const Ce = this._texture.onLoadedObservable.add(ie);
        this._texture.onErrorObservable.add((Ie) => {
          var Be;
          ee(Ie.message, Ie.exception), (Be = this._texture) === null || Be === void 0 || Be.onLoadedObservable.remove(Ce);
        });
      }
    else if (!ue || !ue.useDelayedTextureLoading) {
      try {
        this._texture = ce.createTexture(this.url, L, this._invertY, ue, r, ie, ee, this._buffer, void 0, this._format, this._forcedExtension, u, d, f, k);
      } catch (Ce) {
        throw ee("error loading", Ce), Ce;
      }
      h && (this._buffer = null);
    } else
      this.delayLoadState = 4, this._delayedOnLoad = ie, this._delayedOnError = ee;
  }
  get noMipmap() {
    return this._noMipmap;
  }
  get mimeType() {
    return this._mimeType;
  }
  set isBlocking(e) {
    this._isBlocking = e;
  }
  get isBlocking() {
    return this._isBlocking;
  }
  get invertY() {
    return this._invertY;
  }
  updateURL(e, t = null, i, s) {
    this.url && (this.releaseInternalTexture(), this.getScene().markAllMaterialsAsDirty(1)), (!this.name || this.name.startsWith("data:")) && (this.name = e), this.url = e, this._buffer = t, this._forcedExtension = s, this.delayLoadState = 4, i && (this._delayedOnLoad = i), this.delayLoad();
  }
  delayLoad() {
    if (this.delayLoadState !== 4)
      return;
    const e = this.getScene();
    !e || (this.delayLoadState = 1, this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer), this._texture ? this._delayedOnLoad && (this._texture.isReady ? ji.SetImmediate(this._delayedOnLoad) : this._texture.onLoadedObservable.add(this._delayedOnLoad)) : (this._texture = e.getEngine().createTexture(this.url, this._noMipmap, this._invertY, e, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer), this._deleteBuffer && (this._buffer = null)), this._delayedOnLoad = null, this._delayedOnError = null);
  }
  _prepareRowForTextureGeneration(e, t, i, s) {
    e *= this._cachedUScale, t *= this._cachedVScale, e -= this.uRotationCenter * this._cachedUScale, t -= this.vRotationCenter * this._cachedVScale, i -= this.wRotationCenter, p.TransformCoordinatesFromFloatsToRef(e, t, i, this._rowGenerationMatrix, s), s.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset, s.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset, s.z += this.wRotationCenter;
  }
  checkTransformsAreIdentical(e) {
    return e !== null && this.uOffset === e.uOffset && this.vOffset === e.vOffset && this.uScale === e.uScale && this.vScale === e.vScale && this.uAng === e.uAng && this.vAng === e.vAng && this.wAng === e.wAng;
  }
  getTextureMatrix(e = 1) {
    if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * e === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform)
      return this._cachedTextureMatrix;
    this._cachedUOffset = this.uOffset, this._cachedVOffset = this.vOffset, this._cachedUScale = this.uScale * e, this._cachedVScale = this.vScale, this._cachedUAng = this.uAng, this._cachedVAng = this.vAng, this._cachedWAng = this.wAng, this._cachedURotationCenter = this.uRotationCenter, this._cachedVRotationCenter = this.vRotationCenter, this._cachedWRotationCenter = this.wRotationCenter, this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform, (!this._cachedTextureMatrix || !this._rowGenerationMatrix) && (this._cachedTextureMatrix = x.Zero(), this._rowGenerationMatrix = new x(), this._t0 = p.Zero(), this._t1 = p.Zero(), this._t2 = p.Zero()), x.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix), this.homogeneousRotationInUVTransform ? (x.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, D.Matrix[0]), x.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, D.Matrix[1]), x.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, D.Matrix[2]), x.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, D.Matrix[3]), D.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[1], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[2], this._cachedTextureMatrix), this._cachedTextureMatrix.multiplyToRef(D.Matrix[3], this._cachedTextureMatrix), this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1)) : (this._prepareRowForTextureGeneration(0, 0, 0, this._t0), this._prepareRowForTextureGeneration(1, 0, 0, this._t1), this._prepareRowForTextureGeneration(0, 1, 0, this._t2), this._t1.subtractInPlace(this._t0), this._t2.subtractInPlace(this._t0), x.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix));
    const t = this.getScene();
    return t ? (this.optimizeUVAllocation && t.markAllMaterialsAsDirty(1, (i) => i.hasTexture(this)), this._cachedTextureMatrix) : this._cachedTextureMatrix;
  }
  getReflectionTextureMatrix() {
    const e = this.getScene();
    if (!e)
      return this._cachedReflectionTextureMatrix;
    if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode)
      if (this.coordinatesMode === B.PROJECTION_MODE) {
        if (this._cachedReflectionProjectionMatrixId === e.getProjectionMatrix().updateFlag)
          return this._cachedReflectionTextureMatrix;
      } else
        return this._cachedReflectionTextureMatrix;
    this._cachedReflectionTextureMatrix || (this._cachedReflectionTextureMatrix = x.Zero()), this._projectionModeMatrix || (this._projectionModeMatrix = x.Zero());
    const t = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
    switch (this._cachedReflectionUOffset = this.uOffset, this._cachedReflectionVOffset = this.vOffset, this._cachedReflectionUScale = this.uScale, this._cachedReflectionVScale = this.vScale, this._cachedReflectionCoordinatesMode = this.coordinatesMode, this.coordinatesMode) {
      case B.PLANAR_MODE: {
        x.IdentityToRef(this._cachedReflectionTextureMatrix), this._cachedReflectionTextureMatrix[0] = this.uScale, this._cachedReflectionTextureMatrix[5] = this.vScale, this._cachedReflectionTextureMatrix[12] = this.uOffset, this._cachedReflectionTextureMatrix[13] = this.vOffset;
        break;
      }
      case B.PROJECTION_MODE: {
        x.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
        const i = e.getProjectionMatrix();
        this._cachedReflectionProjectionMatrixId = i.updateFlag, i.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
        break;
      }
      default:
        x.IdentityToRef(this._cachedReflectionTextureMatrix);
        break;
    }
    return t && e.markAllMaterialsAsDirty(1, (i) => i.getActiveTextures().indexOf(this) !== -1), this._cachedReflectionTextureMatrix;
  }
  clone() {
    const e = {
      noMipmap: this._noMipmap,
      invertY: this._invertY,
      samplingMode: this.samplingMode,
      onLoad: void 0,
      onError: void 0,
      buffer: this._texture ? this._texture._buffer : void 0,
      deleteBuffer: this._deleteBuffer,
      format: this.textureFormat,
      mimeType: this.mimeType,
      loaderOptions: this._loaderOptions,
      creationFlags: this._creationFlags,
      useSRGBBuffer: this._useSRGBBuffer
    };
    return ae.Clone(() => new B(this._texture ? this._texture.url : null, this.getScene(), e), this);
  }
  serialize() {
    var e, t;
    const i = this.name;
    B.SerializeBuffers || this.name.startsWith("data:") && (this.name = ""), this.name.startsWith("data:") && this.url === this.name && (this.url = "");
    const s = super.serialize(B._SerializeInternalTextureUniqueId);
    return s ? ((B.SerializeBuffers || B.ForceSerializeBuffers) && (typeof this._buffer == "string" && this._buffer.substr(0, 5) === "data:" ? (s.base64String = this._buffer, s.name = s.name.replace("data:", "")) : this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array ? s.base64String = "data:image/png;base64," + Ar(this._buffer) : (B.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) && (s.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? ea(this) : ta(this))), s.invertY = this._invertY, s.samplingMode = this.samplingMode, s._creationFlags = this._creationFlags, s._useSRGBBuffer = this._useSRGBBuffer, B._SerializeInternalTextureUniqueId && (s.internalTextureUniqueId = (t = (e = this._texture) === null || e === void 0 ? void 0 : e.uniqueId) !== null && t !== void 0 ? t : void 0), this.name = i, s) : null;
  }
  getClassName() {
    return "Texture";
  }
  dispose() {
    super.dispose(), this.onLoadObservable.clear(), this._delayedOnLoad = null, this._delayedOnError = null, this._buffer = null;
  }
  static Parse(e, t, i) {
    if (e.customType) {
      const h = Pi.Instantiate(e.customType).Parse(e, t, i);
      return e.samplingMode && h.updateSamplingMode && h._samplingMode && h._samplingMode !== e.samplingMode && h.updateSamplingMode(e.samplingMode), h;
    }
    if (e.isCube && !e.isRenderTarget)
      return B._CubeTextureParser(e, t, i);
    const s = e.internalTextureUniqueId !== void 0;
    if (!e.name && !e.isRenderTarget && !s)
      return null;
    let r;
    if (s) {
      const o = t.getEngine().getLoadedTexturesCache();
      for (const h of o)
        if (h.uniqueId === e.internalTextureUniqueId) {
          r = h;
          break;
        }
    }
    const n = (o) => {
      var h;
      if (o && o._texture && (o._texture._cachedWrapU = null, o._texture._cachedWrapV = null, o._texture._cachedWrapR = null), e.samplingMode) {
        const l = e.samplingMode;
        o && o.samplingMode !== l && o.updateSamplingMode(l);
      }
      if (o && e.animations)
        for (let l = 0; l < e.animations.length; l++) {
          const u = e.animations[l], d = ci("BABYLON.Animation");
          d && o.animations.push(d.Parse(u));
        }
      s && !r && ((h = o == null ? void 0 : o._texture) === null || h === void 0 || h._setUniqueId(e.internalTextureUniqueId));
    };
    return ae.Parse(() => {
      var o, h, l;
      let u = !0;
      if (e.noMipmap && (u = !1), e.mirrorPlane) {
        const d = B._CreateMirror(e.name, e.renderTargetSize, t, u);
        return d._waitingRenderList = e.renderList, d.mirrorPlane = xt.FromArray(e.mirrorPlane), n(d), d;
      } else if (e.isRenderTarget) {
        let d = null;
        if (e.isCube) {
          if (t.reflectionProbes)
            for (let f = 0; f < t.reflectionProbes.length; f++) {
              const _ = t.reflectionProbes[f];
              if (_.name === e.name)
                return _.cubeTexture;
            }
        } else
          d = B._CreateRenderTargetTexture(e.name, e.renderTargetSize, t, u, (o = e._creationFlags) !== null && o !== void 0 ? o : 0), d._waitingRenderList = e.renderList;
        return n(d), d;
      } else {
        let d;
        if (e.base64String && !r)
          d = B.CreateFromBase64String(e.base64String, e.base64String, t, !u, e.invertY, e.samplingMode, () => {
            n(d);
          }, (h = e._creationFlags) !== null && h !== void 0 ? h : 0, (l = e._useSRGBBuffer) !== null && l !== void 0 ? l : !1), d.name = e.name;
        else {
          let f;
          e.name && e.name.indexOf("://") > 0 ? f = e.name : f = i + e.name, e.url && (e.url.startsWith("data:") || B.UseSerializedUrlIfAny) && (f = e.url);
          const _ = {
            noMipmap: !u,
            invertY: e.invertY,
            samplingMode: e.samplingMode,
            onLoad: () => {
              n(d);
            },
            internalTexture: r
          };
          d = new B(f, t, _);
        }
        return d;
      }
    }, e, t);
  }
  static CreateFromBase64String(e, t, i, s, r, n = B.TRILINEAR_SAMPLINGMODE, a = null, o = null, h = 5, l) {
    return new B("data:" + t, i, s, r, n, a, o, e, !1, h, void 0, void 0, l);
  }
  static LoadFromDataString(e, t, i, s = !1, r, n = !0, a = B.TRILINEAR_SAMPLINGMODE, o = null, h = null, l = 5, u) {
    return e.substr(0, 5) !== "data:" && (e = "data:" + e), new B(e, i, r, n, a, o, h, t, s, l, void 0, void 0, u);
  }
}
B.SerializeBuffers = !0;
B.ForceSerializeBuffers = !1;
B.OnTextureLoadErrorObservable = new w();
B._SerializeInternalTextureUniqueId = !1;
B._CubeTextureParser = (c, e, t) => {
  throw Q("CubeTexture");
};
B._CreateMirror = (c, e, t, i) => {
  throw Q("MirrorTexture");
};
B._CreateRenderTargetTexture = (c, e, t, i, s) => {
  throw Q("RenderTargetTexture");
};
B.NEAREST_SAMPLINGMODE = 1;
B.NEAREST_NEAREST_MIPLINEAR = 8;
B.BILINEAR_SAMPLINGMODE = 2;
B.LINEAR_LINEAR_MIPNEAREST = 11;
B.TRILINEAR_SAMPLINGMODE = 3;
B.LINEAR_LINEAR_MIPLINEAR = 3;
B.NEAREST_NEAREST_MIPNEAREST = 4;
B.NEAREST_LINEAR_MIPNEAREST = 5;
B.NEAREST_LINEAR_MIPLINEAR = 6;
B.NEAREST_LINEAR = 7;
B.NEAREST_NEAREST = 1;
B.LINEAR_NEAREST_MIPNEAREST = 9;
B.LINEAR_NEAREST_MIPLINEAR = 10;
B.LINEAR_LINEAR = 2;
B.LINEAR_NEAREST = 12;
B.EXPLICIT_MODE = 0;
B.SPHERICAL_MODE = 1;
B.PLANAR_MODE = 2;
B.CUBIC_MODE = 3;
B.PROJECTION_MODE = 4;
B.SKYBOX_MODE = 5;
B.INVCUBIC_MODE = 6;
B.EQUIRECTANGULAR_MODE = 7;
B.FIXED_EQUIRECTANGULAR_MODE = 8;
B.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
B.CLAMP_ADDRESSMODE = 0;
B.WRAP_ADDRESSMODE = 1;
B.MIRROR_ADDRESSMODE = 2;
B.UseSerializedUrlIfAny = !1;
T([
  R()
], B.prototype, "url", void 0);
T([
  R()
], B.prototype, "uOffset", void 0);
T([
  R()
], B.prototype, "vOffset", void 0);
T([
  R()
], B.prototype, "uScale", void 0);
T([
  R()
], B.prototype, "vScale", void 0);
T([
  R()
], B.prototype, "uAng", void 0);
T([
  R()
], B.prototype, "vAng", void 0);
T([
  R()
], B.prototype, "wAng", void 0);
T([
  R()
], B.prototype, "uRotationCenter", void 0);
T([
  R()
], B.prototype, "vRotationCenter", void 0);
T([
  R()
], B.prototype, "wRotationCenter", void 0);
T([
  R()
], B.prototype, "homogeneousRotationInUVTransform", void 0);
T([
  R()
], B.prototype, "isBlocking", null);
st("BABYLON.Texture", B);
ae._TextureParser = B.Parse;
class ia {
  constructor(e, t, i, s) {
    this._textures = null, this._samples = 1, this._attachments = null, this._generateStencilBuffer = !1, this._generateDepthBuffer = !1, this._depthStencilTextureWithStencil = !1, this._isMulti = e, this._isCube = t, this._size = i, this._engine = s, this._depthStencilTexture = null;
  }
  get depthStencilTexture() {
    return this._depthStencilTexture;
  }
  get depthStencilTextureWithStencil() {
    return this._depthStencilTextureWithStencil;
  }
  get isCube() {
    return this._isCube;
  }
  get isMulti() {
    return this._isMulti;
  }
  get is2DArray() {
    return this.layers > 0;
  }
  get size() {
    return this.width;
  }
  get width() {
    return this._size.width || this._size;
  }
  get height() {
    return this._size.height || this._size;
  }
  get layers() {
    return this._size.layers || 0;
  }
  get texture() {
    var e, t;
    return (t = (e = this._textures) === null || e === void 0 ? void 0 : e[0]) !== null && t !== void 0 ? t : null;
  }
  get textures() {
    return this._textures;
  }
  get samples() {
    return this._samples;
  }
  setSamples(e, t = !0, i = !1) {
    if (this.samples === e && !i)
      return e;
    const s = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, e, t) : this._engine.updateRenderTargetTextureSampleCount(this, e);
    return this._samples = e, s;
  }
  setTextures(e) {
    Array.isArray(e) ? this._textures = e : e ? this._textures = [e] : this._textures = null;
  }
  setTexture(e, t = 0, i = !0) {
    this._textures || (this._textures = []), this._textures[t] && i && this._textures[t].dispose(), this._textures[t] = e;
  }
  createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, r = 14) {
    var n;
    return (n = this._depthStencilTexture) === null || n === void 0 || n.dispose(), this._depthStencilTextureWithStencil = i, this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
      bilinearFiltering: t,
      comparisonFunction: e,
      generateStencil: i,
      isCube: this._isCube,
      samples: s,
      depthTextureFormat: r
    }, this), this._depthStencilTexture;
  }
  _shareDepth(e) {
    this._depthStencilTexture && (e._depthStencilTexture && e._depthStencilTexture.dispose(), e._depthStencilTexture = this._depthStencilTexture, this._depthStencilTexture.incrementReferences());
  }
  _swapAndDie(e) {
    this.texture && this.texture._swapAndDie(e), this._textures = null, this.dispose(!0);
  }
  _cloneRenderTargetWrapper() {
    var e, t, i, s, r, n;
    let a = null;
    if (this._isMulti) {
      const o = this.textures;
      if (o && o.length > 0) {
        let h = !1, l = o.length;
        const u = o[o.length - 1]._source;
        (u === Oe.Depth || u === Oe.DepthStencil) && (h = !0, l--);
        const d = [], f = [];
        for (let m = 0; m < l; ++m) {
          const v = o[m];
          d.push(v.samplingMode), f.push(v.type);
        }
        const _ = {
          samplingModes: d,
          generateMipMaps: o[0].generateMipMaps,
          generateDepthBuffer: this._generateDepthBuffer,
          generateStencilBuffer: this._generateStencilBuffer,
          generateDepthTexture: h,
          types: f,
          textureCount: l
        }, E = {
          width: this.width,
          height: this.height
        };
        a = this._engine.createMultipleRenderTarget(E, _);
      }
    } else {
      const o = {};
      if (o.generateDepthBuffer = this._generateDepthBuffer, o.generateMipMaps = (t = (e = this.texture) === null || e === void 0 ? void 0 : e.generateMipMaps) !== null && t !== void 0 ? t : !1, o.generateStencilBuffer = this._generateStencilBuffer, o.samplingMode = (i = this.texture) === null || i === void 0 ? void 0 : i.samplingMode, o.type = (s = this.texture) === null || s === void 0 ? void 0 : s.type, o.format = (r = this.texture) === null || r === void 0 ? void 0 : r.format, this.isCube)
        a = this._engine.createRenderTargetCubeTexture(this.width, o);
      else {
        const h = {
          width: this.width,
          height: this.height,
          layers: this.is2DArray ? (n = this.texture) === null || n === void 0 ? void 0 : n.depth : void 0
        };
        a = this._engine.createRenderTargetTexture(h, o);
      }
      a.texture.isReady = !0;
    }
    return a;
  }
  _swapRenderTargetWrapper(e) {
    if (this._textures && e._textures)
      for (let t = 0; t < this._textures.length; ++t)
        this._textures[t]._swapAndDie(e._textures[t], !1), e._textures[t].isReady = !0;
    this._depthStencilTexture && e._depthStencilTexture && (this._depthStencilTexture._swapAndDie(e._depthStencilTexture), e._depthStencilTexture.isReady = !0), this._textures = null, this._depthStencilTexture = null;
  }
  _rebuild() {
    const e = this._cloneRenderTargetWrapper();
    if (!!e) {
      if (this._depthStencilTexture) {
        const t = this._depthStencilTexture.samplingMode, i = t === 2 || t === 3 || t === 11;
        e.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, i, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
      }
      this.samples > 1 && e.setSamples(this.samples), e._swapRenderTargetWrapper(this), e.dispose();
    }
  }
  releaseTextures() {
    var e, t;
    if (this._textures)
      for (let i = 0; (t = i < ((e = this._textures) === null || e === void 0 ? void 0 : e.length)) !== null && t !== void 0 && t; ++i)
        this._textures[i].dispose();
    this._textures = null;
  }
  dispose(e = !1) {
    var t;
    e || ((t = this._depthStencilTexture) === null || t === void 0 || t.dispose(), this._depthStencilTexture = null, this.releaseTextures()), this._engine._releaseRenderTargetWrapper(this);
  }
}
class sa extends ia {
  constructor(e, t, i, s, r) {
    super(e, t, i, s), this._framebuffer = null, this._depthStencilBuffer = null, this._MSAAFramebuffer = null, this._colorTextureArray = null, this._depthStencilTextureArray = null, this._context = r;
  }
  _cloneRenderTargetWrapper() {
    let e = null;
    return this._colorTextureArray && this._depthStencilTextureArray ? (e = this._engine.createMultiviewRenderTargetTexture(this.width, this.height), e.texture.isReady = !0) : e = super._cloneRenderTargetWrapper(), e;
  }
  _swapRenderTargetWrapper(e) {
    super._swapRenderTargetWrapper(e), e._framebuffer = this._framebuffer, e._depthStencilBuffer = this._depthStencilBuffer, e._MSAAFramebuffer = this._MSAAFramebuffer, e._colorTextureArray = this._colorTextureArray, e._depthStencilTextureArray = this._depthStencilTextureArray, this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
  }
  _shareDepth(e) {
    super._shareDepth(e);
    const t = this._context, i = this._depthStencilBuffer, s = e._MSAAFramebuffer || e._framebuffer;
    e._depthStencilBuffer && t.deleteRenderbuffer(e._depthStencilBuffer), e._depthStencilBuffer = this._depthStencilBuffer, this._engine._bindUnboundFramebuffer(s), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_ATTACHMENT, t.RENDERBUFFER, i), this._engine._bindUnboundFramebuffer(null);
  }
  _bindTextureRenderTarget(e, t = 0, i = -1, s = 0) {
    if (!e._hardwareTexture)
      return;
    const r = this._context, n = this._framebuffer, a = this._engine._currentFramebuffer;
    this._engine._bindUnboundFramebuffer(n);
    const o = r[this._engine.webGLVersion > 1 ? "COLOR_ATTACHMENT" + t : "COLOR_ATTACHMENT" + t + "_WEBGL"], h = i !== -1 ? r.TEXTURE_CUBE_MAP_POSITIVE_X + i : r.TEXTURE_2D;
    r.framebufferTexture2D(r.FRAMEBUFFER, o, h, e._hardwareTexture.underlyingResource, s), this._engine._bindUnboundFramebuffer(a);
  }
  setTexture(e, t = 0, i = !0) {
    super.setTexture(e, t, i), this._bindTextureRenderTarget(e, t);
  }
  dispose(e = !1) {
    const t = this._context;
    e || (this._colorTextureArray && (this._context.deleteTexture(this._colorTextureArray), this._colorTextureArray = null), this._depthStencilTextureArray && (this._context.deleteTexture(this._depthStencilTextureArray), this._depthStencilTextureArray = null)), this._framebuffer && (t.deleteFramebuffer(this._framebuffer), this._framebuffer = null), this._depthStencilBuffer && (t.deleteRenderbuffer(this._depthStencilBuffer), this._depthStencilBuffer = null), this._MSAAFramebuffer && (t.deleteFramebuffer(this._MSAAFramebuffer), this._MSAAFramebuffer = null), super.dispose(e);
  }
}
le.prototype._createHardwareRenderTargetWrapper = function(c, e, t) {
  const i = new sa(c, e, t, this, this._gl);
  return this._renderTargetWrapperCache.push(i), i;
};
le.prototype.createRenderTargetTexture = function(c, e) {
  var t, i;
  const s = this._createHardwareRenderTargetWrapper(!1, !1, c);
  let r = !0, n = !1, a = !1, o, h = 1;
  e !== void 0 && typeof e == "object" && (r = (t = e.generateDepthBuffer) !== null && t !== void 0 ? t : !0, n = !!e.generateStencilBuffer, a = !!e.noColorAttachment, o = e.colorAttachment, h = (i = e.samples) !== null && i !== void 0 ? i : 1);
  const l = o || (a ? null : this._createInternalTexture(c, e, !0, Oe.RenderTarget)), u = c.width || c, d = c.height || c, f = this._currentFramebuffer, _ = this._gl, E = _.createFramebuffer();
  return this._bindUnboundFramebuffer(E), s._depthStencilBuffer = this._setupFramebufferDepthAttachments(n, r, u, d), l && !l.is2DArray && _.framebufferTexture2D(_.FRAMEBUFFER, _.COLOR_ATTACHMENT0, _.TEXTURE_2D, l._hardwareTexture.underlyingResource, 0), this._bindUnboundFramebuffer(f), s._framebuffer = E, s._generateDepthBuffer = r, s._generateStencilBuffer = n, s.setTextures(l), this.updateRenderTargetTextureSampleCount(s, h), s;
};
le.prototype.createDepthStencilTexture = function(c, e, t) {
  if (e.isCube) {
    const i = c.width || c;
    return this._createDepthStencilCubeTexture(i, e, t);
  } else
    return this._createDepthStencilTexture(c, e, t);
};
le.prototype._createDepthStencilTexture = function(c, e, t) {
  const i = this._gl, s = c.layers || 0, r = s !== 0 ? i.TEXTURE_2D_ARRAY : i.TEXTURE_2D, n = new Vt(this, Oe.DepthStencil);
  if (!this._caps.depthTextureExtension)
    return O.Error("Depth texture is not supported by your browser or hardware."), n;
  const a = {
    bilinearFiltering: !1,
    comparisonFunction: 0,
    generateStencil: !1,
    ...e
  };
  if (this._bindTextureDirectly(r, n, !0), this._setupDepthStencilTexture(n, c, a.generateStencil, a.comparisonFunction === 0 ? !1 : a.bilinearFiltering, a.comparisonFunction, a.samples), a.depthTextureFormat !== void 0) {
    if (a.depthTextureFormat !== 15 && a.depthTextureFormat !== 16 && a.depthTextureFormat !== 17 && a.depthTextureFormat !== 13 && a.depthTextureFormat !== 14 && a.depthTextureFormat !== 18)
      return O.Error("Depth texture format is not supported."), n;
    n.format = a.depthTextureFormat;
  } else
    n.format = a.generateStencil ? 13 : 16;
  const o = n.format === 17 || n.format === 13 || n.format === 18;
  t._depthStencilTexture = n, t._depthStencilTextureWithStencil = o;
  let h = i.UNSIGNED_INT;
  n.format === 15 ? h = i.UNSIGNED_SHORT : n.format === 17 || n.format === 13 ? h = i.UNSIGNED_INT_24_8 : n.format === 14 ? h = i.FLOAT : n.format === 18 && (h = i.FLOAT_32_UNSIGNED_INT_24_8_REV);
  const l = o ? i.DEPTH_STENCIL : i.DEPTH_COMPONENT;
  let u = l;
  this.webGLVersion > 1 && (n.format === 15 ? u = i.DEPTH_COMPONENT16 : n.format === 16 ? u = i.DEPTH_COMPONENT24 : n.format === 17 || n.format === 13 ? u = i.DEPTH24_STENCIL8 : n.format === 14 ? u = i.DEPTH_COMPONENT32F : n.format === 18 && (u = i.DEPTH32F_STENCIL8)), n.is2DArray ? i.texImage3D(r, 0, u, n.width, n.height, s, 0, l, h, null) : i.texImage2D(r, 0, u, n.width, n.height, 0, l, h, null), this._bindTextureDirectly(r, null), this._internalTexturesCache.push(n);
  const d = t;
  if (d._depthStencilBuffer) {
    const f = this._currentFramebuffer;
    this._bindUnboundFramebuffer(d._framebuffer), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, null), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, null), i.framebufferRenderbuffer(i.FRAMEBUFFER, i.STENCIL_ATTACHMENT, i.RENDERBUFFER, null), this._bindUnboundFramebuffer(f), i.deleteRenderbuffer(d._depthStencilBuffer), d._depthStencilBuffer = null;
  }
  return n;
};
le.prototype.updateRenderTargetTextureSampleCount = function(c, e) {
  if (this.webGLVersion < 2 || !c || !c.texture)
    return 1;
  if (c.samples === e)
    return e;
  const t = this._gl;
  e = Math.min(e, this.getCaps().maxMSAASamples), c._depthStencilBuffer && (t.deleteRenderbuffer(c._depthStencilBuffer), c._depthStencilBuffer = null), c._MSAAFramebuffer && (t.deleteFramebuffer(c._MSAAFramebuffer), c._MSAAFramebuffer = null);
  const i = c.texture._hardwareTexture;
  if (i._MSAARenderBuffer && (t.deleteRenderbuffer(i._MSAARenderBuffer), i._MSAARenderBuffer = null), e > 1 && t.renderbufferStorageMultisample) {
    const s = t.createFramebuffer();
    if (!s)
      throw new Error("Unable to create multi sampled framebuffer");
    c._MSAAFramebuffer = s, this._bindUnboundFramebuffer(c._MSAAFramebuffer);
    const r = this._createRenderBuffer(c.texture.width, c.texture.height, e, -1, this._getRGBAMultiSampleBufferFormat(c.texture.type), t.COLOR_ATTACHMENT0, !1);
    if (!r)
      throw new Error("Unable to create multi sampled framebuffer");
    i._MSAARenderBuffer = r;
  } else
    this._bindUnboundFramebuffer(c._framebuffer);
  return c.texture.samples = e, c._samples = e, c._depthStencilBuffer = this._setupFramebufferDepthAttachments(c._generateStencilBuffer, c._generateDepthBuffer, c.texture.width, c.texture.height, e), this._bindUnboundFramebuffer(null), e;
};
le.prototype.createRenderTargetCubeTexture = function(c, e) {
  const t = this._createHardwareRenderTargetWrapper(!1, !0, c), i = {
    generateMipMaps: !0,
    generateDepthBuffer: !0,
    generateStencilBuffer: !1,
    type: 0,
    samplingMode: 3,
    format: 5,
    ...e
  };
  i.generateStencilBuffer = i.generateDepthBuffer && i.generateStencilBuffer, (i.type === 1 && !this._caps.textureFloatLinearFiltering || i.type === 2 && !this._caps.textureHalfFloatLinearFiltering) && (i.samplingMode = 1);
  const s = this._gl, r = new Vt(this, Oe.RenderTarget);
  this._bindTextureDirectly(s.TEXTURE_CUBE_MAP, r, !0);
  const n = this._getSamplingParameters(i.samplingMode, i.generateMipMaps);
  i.type === 1 && !this._caps.textureFloat && (i.type = 0, O.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type")), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MAG_FILTER, n.mag), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_MIN_FILTER, n.min), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_S, s.CLAMP_TO_EDGE), s.texParameteri(s.TEXTURE_CUBE_MAP, s.TEXTURE_WRAP_T, s.CLAMP_TO_EDGE);
  for (let o = 0; o < 6; o++)
    s.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + o, 0, this._getRGBABufferInternalSizedFormat(i.type, i.format), c, c, 0, this._getInternalFormat(i.format), this._getWebGLTextureType(i.type), null);
  const a = s.createFramebuffer();
  return this._bindUnboundFramebuffer(a), t._depthStencilBuffer = this._setupFramebufferDepthAttachments(i.generateStencilBuffer, i.generateDepthBuffer, c, c), i.generateMipMaps && s.generateMipmap(s.TEXTURE_CUBE_MAP), this._bindTextureDirectly(s.TEXTURE_CUBE_MAP, null), this._bindUnboundFramebuffer(null), t._framebuffer = a, t._generateDepthBuffer = i.generateDepthBuffer, t._generateStencilBuffer = i.generateStencilBuffer, r.width = c, r.height = c, r.isReady = !0, r.isCube = !0, r.samples = 1, r.generateMipMaps = i.generateMipMaps, r.samplingMode = i.samplingMode, r.type = i.type, r.format = i.format, this._internalTexturesCache.push(r), t.setTextures(r), t;
};
const ra = "postprocessVertexShader", na = `attribute vec2 position;
uniform vec2 scale;
varying vec2 vUV;
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
U.ShadersStore[ra] = na;
const Ps = {
  positions: [1, 1, -1, 1, -1, -1, 1, -1],
  indices: [0, 1, 2, 0, 2, 3]
};
class aa {
  constructor(e, t = Ps) {
    var i, s;
    this._fullscreenViewport = new Oi(0, 0, 1, 1);
    const r = (i = t.positions) !== null && i !== void 0 ? i : Ps.positions, n = (s = t.indices) !== null && s !== void 0 ? s : Ps.indices;
    this.engine = e, this._vertexBuffers = {
      [g.PositionKind]: new g(e, r, g.PositionKind, !1, !1, 2)
    }, this._indexBuffer = e.createIndexBuffer(n), this._onContextRestoredObserver = e.onContextRestoredObservable.add(() => {
      this._indexBuffer = e.createIndexBuffer(n);
      for (const a in this._vertexBuffers)
        this._vertexBuffers[a]._rebuild();
    });
  }
  setViewport(e = this._fullscreenViewport) {
    this.engine.setViewport(e);
  }
  bindBuffers(e) {
    this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, e);
  }
  applyEffectWrapper(e) {
    this.engine.setState(!0), this.engine.depthCullingState.depthTest = !1, this.engine.stencilState.stencilTest = !1, this.engine.enableEffect(e._drawWrapper), this.bindBuffers(e.effect), e.onApplyObservable.notifyObservers({});
  }
  restoreStates() {
    this.engine.depthCullingState.depthTest = !0, this.engine.stencilState.stencilTest = !0;
  }
  draw() {
    this.engine.drawElementsType(0, 0, 6);
  }
  _isRenderTargetTexture(e) {
    return e.renderTarget !== void 0;
  }
  render(e, t = null) {
    if (!e.effect.isReady())
      return;
    this.setViewport();
    const i = t === null ? null : this._isRenderTargetTexture(t) ? t.renderTarget : t;
    i && this.engine.bindFramebuffer(i), this.applyEffectWrapper(e), this.draw(), i && this.engine.unBindFramebuffer(i), this.restoreStates();
  }
  dispose() {
    const e = this._vertexBuffers[g.PositionKind];
    e && (e.dispose(), delete this._vertexBuffers[g.PositionKind]), this._indexBuffer && this.engine._releaseBuffer(this._indexBuffer), this._onContextRestoredObserver && (this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null);
  }
}
class oa {
  constructor(e) {
    this.onApplyObservable = new w();
    let t;
    const i = e.uniformNames || [];
    e.vertexShader ? t = {
      fragmentSource: e.fragmentShader,
      vertexSource: e.vertexShader,
      spectorName: e.name || "effectWrapper"
    } : (i.push("scale"), t = {
      fragmentSource: e.fragmentShader,
      vertex: "postprocess",
      spectorName: e.name || "effectWrapper"
    }, this.onApplyObservable.add(() => {
      this.effect.setFloat2("scale", 1, 1);
    }));
    const s = e.defines ? e.defines.join(`
`) : "";
    this._drawWrapper = new Ri(e.engine), e.useShaderStore ? (t.fragment = t.fragmentSource, t.vertex || (t.vertex = t.vertexSource), delete t.fragmentSource, delete t.vertexSource, this.effect = e.engine.createEffect(t, e.attributeNames || ["position"], i, e.samplerNames, s, void 0, e.onCompiled, void 0, void 0, e.shaderLanguage)) : (this.effect = new De(t, e.attributeNames || ["position"], i, e.samplerNames, e.engine, s, void 0, e.onCompiled, void 0, void 0, void 0, e.shaderLanguage), this._onContextRestoredObserver = e.engine.onContextRestoredObservable.add(() => {
      this.effect._pipelineContext = null, this.effect._wasPreviouslyReady = !1, this.effect._prepareEffect();
    }));
  }
  get effect() {
    return this._drawWrapper.effect;
  }
  set effect(e) {
    this._drawWrapper.effect = e;
  }
  dispose() {
    this._onContextRestoredObserver && (this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null), this.effect.dispose();
  }
}
const Ur = "passPixelShader", kr = `varying vec2 vUV;
uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{
gl_FragColor=texture2D(textureSampler,vUV);
}`;
U.ShadersStore[Ur] = kr;
const pr = { name: Ur, shader: kr };
class $e {
  static _CreateDumpRenderer() {
    if (!$e._DumpToolsEngine) {
      const e = document.createElement("canvas"), t = new le(e, !1, {
        preserveDrawingBuffer: !0,
        depth: !1,
        stencil: !1,
        alpha: !0,
        premultipliedAlpha: !1,
        antialias: !1,
        failIfMajorPerformanceCaveat: !1
      });
      t.getCaps().parallelShaderCompile = void 0;
      const i = new aa(t), s = new oa({
        engine: t,
        name: pr.name,
        fragmentShader: pr.shader,
        samplerNames: ["textureSampler"]
      });
      $e._DumpToolsEngine = {
        canvas: e,
        engine: t,
        renderer: i,
        wrapper: s
      };
    }
    return $e._DumpToolsEngine;
  }
  static async DumpFramebuffer(e, t, i, s, r = "image/png", n) {
    const a = await i.readPixels(0, 0, e, t), o = new Uint8Array(a.buffer);
    $e.DumpData(e, t, o, s, r, n, !0);
  }
  static DumpDataAsync(e, t, i, s = "image/png", r, n = !1, a = !1, o) {
    return new Promise((h) => {
      $e.DumpData(e, t, i, (l) => h(l), s, r, n, a, o);
    });
  }
  static DumpData(e, t, i, s, r = "image/png", n, a = !1, o = !1, h) {
    const l = $e._CreateDumpRenderer();
    if (l.engine.setSize(e, t, !0), i instanceof Float32Array) {
      const d = new Uint8Array(i.length);
      let f = i.length;
      for (; f--; ) {
        const _ = i[f];
        d[f] = _ < 0 ? 0 : _ > 1 ? 1 : Math.round(_ * 255);
      }
      i = d;
    }
    const u = l.engine.createRawTexture(i, e, t, 5, !1, !a, 1);
    l.renderer.setViewport(), l.renderer.applyEffectWrapper(l.wrapper), l.wrapper.effect._bindTexture("textureSampler", u), l.renderer.draw(), o ? X.ToBlob(l.canvas, (d) => {
      const f = new FileReader();
      f.onload = (_) => {
        const E = _.target.result;
        s && s(E);
      }, f.readAsArrayBuffer(d);
    }, r, h) : X.EncodeScreenshotCanvasData(l.canvas, s, r, n, h), u.dispose();
  }
  static Dispose() {
    $e._DumpToolsEngine && ($e._DumpToolsEngine.wrapper.dispose(), $e._DumpToolsEngine.renderer.dispose(), $e._DumpToolsEngine.engine.dispose()), $e._DumpToolsEngine = null;
  }
}
const ha = () => {
  X.DumpData = $e.DumpData, X.DumpDataAsync = $e.DumpDataAsync, X.DumpFramebuffer = $e.DumpFramebuffer;
};
ha();
class _t extends B {
  constructor(e, t, i, s = !1, r = !0, n = 0, a = !1, o = B.TRILINEAR_SAMPLINGMODE, h = !0, l = !1, u = !1, d = 5, f = !1, _, E, m = !1, v = !1) {
    var S, y, A, C, b, M;
    let L;
    if (typeof s == "object") {
      const F = s;
      s = !!F.generateMipMaps, r = (S = F.doNotChangeAspectRatio) !== null && S !== void 0 ? S : !0, n = (y = F.type) !== null && y !== void 0 ? y : 0, a = !!F.isCube, o = (A = F.samplingMode) !== null && A !== void 0 ? A : B.TRILINEAR_SAMPLINGMODE, h = (C = F.generateDepthBuffer) !== null && C !== void 0 ? C : !0, l = !!F.generateStencilBuffer, u = !!F.isMulti, d = (b = F.format) !== null && b !== void 0 ? b : 5, f = !!F.delayAllocation, _ = F.samples, E = F.creationFlags, m = !!F.noColorAttachment, v = !!F.useSRGBBuffer, L = F.colorAttachment;
    }
    if (super(null, i, !s, void 0, o, void 0, void 0, void 0, void 0, d), this._unObserveRenderList = null, this._renderListHasChanged = (F, ue) => {
      var ce;
      const ie = this._renderList ? this._renderList.length : 0;
      (ue === 0 && ie > 0 || ie === 0) && ((ce = this.getScene()) === null || ce === void 0 || ce.meshes.forEach((ee) => {
        ee._markSubMeshesAsLightDirty();
      }));
    }, this.renderParticles = !0, this.renderSprites = !1, this.forceLayerMaskCheck = !1, this.ignoreCameraViewport = !1, this.onBeforeBindObservable = new w(), this.onAfterUnbindObservable = new w(), this.onBeforeRenderObservable = new w(), this.onAfterRenderObservable = new w(), this.onClearObservable = new w(), this.onResizeObservable = new w(), this._cleared = !1, this.skipInitialClear = !1, this._currentRefreshId = -1, this._refreshRate = 1, this._samples = 1, this._canRescale = !0, this._renderTarget = null, this.boundingBoxPosition = p.Zero(), i = this.getScene(), !i)
      return;
    const k = this.getScene().getEngine();
    this._coordinatesMode = B.PROJECTION_MODE, this.renderList = new Array(), this.name = e, this.isRenderTarget = !0, this._initialSizeParameter = t, this._renderPassIds = [], this._isCubeData = a, this._processSizeParameter(t), this.renderPassId = this._renderPassIds[0], this._resizeObserver = k.onResizeObservable.add(() => {
    }), this._generateMipMaps = !!s, this._doNotChangeAspectRatio = r, this._renderingManager = new ze(i), this._renderingManager._useSceneAutoClearSetup = !0, !u && (this._renderTargetOptions = {
      generateMipMaps: s,
      type: n,
      format: (M = this._format) !== null && M !== void 0 ? M : void 0,
      samplingMode: this.samplingMode,
      generateDepthBuffer: h,
      generateStencilBuffer: l,
      samples: _,
      creationFlags: E,
      noColorAttachment: m,
      useSRGBBuffer: v,
      colorAttachment: L
    }, this.samplingMode === B.NEAREST_SAMPLINGMODE && (this.wrapU = B.CLAMP_ADDRESSMODE, this.wrapV = B.CLAMP_ADDRESSMODE), f || (a ? (this._renderTarget = i.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions), this.coordinatesMode = B.INVCUBIC_MODE, this._textureMatrix = x.Identity()) : this._renderTarget = i.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, _ !== void 0 && (this.samples = _)));
  }
  get renderList() {
    return this._renderList;
  }
  set renderList(e) {
    this._unObserveRenderList && (this._unObserveRenderList(), this._unObserveRenderList = null), e && (this._unObserveRenderList = br(e, this._renderListHasChanged)), this._renderList = e;
  }
  get postProcesses() {
    return this._postProcesses;
  }
  get _prePassEnabled() {
    return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
  }
  set onAfterUnbind(e) {
    this._onAfterUnbindObserver && this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(e);
  }
  set onBeforeRender(e) {
    this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);
  }
  set onAfterRender(e) {
    this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);
  }
  set onClear(e) {
    this._onClearObserver && this.onClearObservable.remove(this._onClearObserver), this._onClearObserver = this.onClearObservable.add(e);
  }
  get renderPassIds() {
    return this._renderPassIds;
  }
  get currentRefreshId() {
    return this._currentRefreshId;
  }
  setMaterialForRendering(e, t) {
    let i;
    Array.isArray(e) ? i = e : i = [e];
    for (let s = 0; s < i.length; ++s)
      for (let r = 0; r < this._renderPassIds.length; ++r)
        i[s].setMaterialForRenderPass(this._renderPassIds[r], t !== void 0 ? Array.isArray(t) ? t[r] : t : void 0);
  }
  get renderTargetOptions() {
    return this._renderTargetOptions;
  }
  get renderTarget() {
    return this._renderTarget;
  }
  _onRatioRescale() {
    this._sizeRatio && this.resize(this._initialSizeParameter);
  }
  set boundingBoxSize(e) {
    if (this._boundingBoxSize && this._boundingBoxSize.equals(e))
      return;
    this._boundingBoxSize = e;
    const t = this.getScene();
    t && t.markAllMaterialsAsDirty(1);
  }
  get boundingBoxSize() {
    return this._boundingBoxSize;
  }
  get depthStencilTexture() {
    var e, t;
    return (t = (e = this._renderTarget) === null || e === void 0 ? void 0 : e._depthStencilTexture) !== null && t !== void 0 ? t : null;
  }
  createDepthStencilTexture(e = 0, t = !0, i = !1, s = 1, r = 14) {
    var n;
    (n = this._renderTarget) === null || n === void 0 || n.createDepthStencilTexture(e, t, i, s, r);
  }
  _releaseRenderPassId() {
    if (this._scene) {
      const e = this._scene.getEngine();
      for (let t = 0; t < this._renderPassIds.length; ++t)
        e.releaseRenderPassId(this._renderPassIds[t]);
    }
    this._renderPassIds = [];
  }
  _createRenderPassId() {
    this._releaseRenderPassId();
    const e = this._scene.getEngine(), t = this._isCubeData ? 6 : this.getRenderLayers() || 1;
    for (let i = 0; i < t; ++i)
      this._renderPassIds[i] = e.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`);
  }
  _processSizeParameter(e) {
    if (e.ratio) {
      this._sizeRatio = e.ratio;
      const t = this._getEngine();
      this._size = {
        width: this._bestReflectionRenderTargetDimension(t.getRenderWidth(), this._sizeRatio),
        height: this._bestReflectionRenderTargetDimension(t.getRenderHeight(), this._sizeRatio)
      };
    } else
      this._size = e;
    this._createRenderPassId();
  }
  get samples() {
    var e, t;
    return (t = (e = this._renderTarget) === null || e === void 0 ? void 0 : e.samples) !== null && t !== void 0 ? t : this._samples;
  }
  set samples(e) {
    this._renderTarget && (this._samples = this._renderTarget.setSamples(e));
  }
  resetRefreshCounter() {
    this._currentRefreshId = -1;
  }
  get refreshRate() {
    return this._refreshRate;
  }
  set refreshRate(e) {
    this._refreshRate = e, this.resetRefreshCounter();
  }
  addPostProcess(e) {
    if (!this._postProcessManager) {
      const t = this.getScene();
      if (!t)
        return;
      this._postProcessManager = new ts(t), this._postProcesses = new Array();
    }
    this._postProcesses.push(e), this._postProcesses[0].autoClear = !1;
  }
  clearPostProcesses(e = !1) {
    if (!!this._postProcesses) {
      if (e)
        for (const t of this._postProcesses)
          t.dispose();
      this._postProcesses = [];
    }
  }
  removePostProcess(e) {
    if (!this._postProcesses)
      return;
    const t = this._postProcesses.indexOf(e);
    t !== -1 && (this._postProcesses.splice(t, 1), this._postProcesses.length > 0 && (this._postProcesses[0].autoClear = !1));
  }
  _shouldRender() {
    return this._currentRefreshId === -1 ? (this._currentRefreshId = 1, !0) : this.refreshRate === this._currentRefreshId ? (this._currentRefreshId = 1, !0) : (this._currentRefreshId++, !1);
  }
  getRenderSize() {
    return this.getRenderWidth();
  }
  getRenderWidth() {
    return this._size.width ? this._size.width : this._size;
  }
  getRenderHeight() {
    return this._size.width ? this._size.height : this._size;
  }
  getRenderLayers() {
    const e = this._size.layers;
    return e || 0;
  }
  disableRescaling() {
    this._canRescale = !1;
  }
  get canRescale() {
    return this._canRescale;
  }
  scale(e) {
    const t = Math.max(1, this.getRenderSize() * e);
    this.resize(t);
  }
  getReflectionTextureMatrix() {
    return this.isCube ? this._textureMatrix : super.getReflectionTextureMatrix();
  }
  resize(e) {
    var t;
    const i = this.isCube;
    (t = this._renderTarget) === null || t === void 0 || t.dispose(), this._renderTarget = null;
    const s = this.getScene();
    !s || (this._processSizeParameter(e), i ? this._renderTarget = s.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions) : this._renderTarget = s.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions), this._texture = this._renderTarget.texture, this._renderTargetOptions.samples !== void 0 && (this.samples = this._renderTargetOptions.samples), this.onResizeObservable.hasObservers() && this.onResizeObservable.notifyObservers(this));
  }
  render(e = !1, t = !1) {
    this._render(e, t);
  }
  isReadyForRendering() {
    return this._render(!1, !1, !0);
  }
  _render(e = !1, t = !1, i = !1) {
    var s;
    const r = this.getScene();
    if (!r)
      return i;
    const n = r.getEngine();
    if (this.useCameraPostProcesses !== void 0 && (e = this.useCameraPostProcesses), this._waitingRenderList) {
      this.renderList = [];
      for (let u = 0; u < this._waitingRenderList.length; u++) {
        const d = this._waitingRenderList[u], f = r.getMeshById(d);
        f && this.renderList.push(f);
      }
      this._waitingRenderList = void 0;
    }
    if (this.renderListPredicate) {
      this.renderList ? this.renderList.length = 0 : this.renderList = [];
      const u = this.getScene();
      if (!u)
        return i;
      const d = u.meshes;
      for (let f = 0; f < d.length; f++) {
        const _ = d[f];
        this.renderListPredicate(_) && this.renderList.push(_);
      }
    }
    const a = n.currentRenderPassId;
    this.onBeforeBindObservable.notifyObservers(this);
    const o = (s = this.activeCamera) !== null && s !== void 0 ? s : r.activeCamera, h = r.activeCamera;
    o && (o !== r.activeCamera && (r.setTransformMatrix(o.getViewMatrix(), o.getProjectionMatrix(!0)), r.activeCamera = o), n.setViewport(o.viewport, this.getRenderWidth(), this.getRenderHeight())), this._defaultRenderListPrepared = !1;
    let l = i;
    if (i) {
      r.getViewMatrix() || r.updateTransformMatrix();
      const u = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;
      for (let d = 0; d < u && l; d++) {
        let f = null;
        const _ = this.renderList ? this.renderList : r.getActiveMeshes().data, E = this.renderList ? this.renderList.length : r.getActiveMeshes().length;
        n.currentRenderPassId = this._renderPassIds[d], this.onBeforeRenderObservable.notifyObservers(d), this.getCustomRenderList && (f = this.getCustomRenderList(d, _, E)), f || (f = _), this._doNotChangeAspectRatio || r.updateTransformMatrix(!0);
        for (let m = 0; m < f.length && l; ++m) {
          const v = f[m];
          if (!(!v.isEnabled() || v.isBlocked || !v.isVisible || !v.subMeshes)) {
            if (this.customIsReadyFunction) {
              if (!this.customIsReadyFunction(v, this.refreshRate, i)) {
                l = !1;
                continue;
              }
            } else if (!v.isReady(!0)) {
              l = !1;
              continue;
            }
          }
        }
        this.onAfterRenderObservable.notifyObservers(d), (this.is2DArray || this.isCube) && (r.incrementRenderId(), r.resetCachedMaterial());
      }
    } else if (this.is2DArray)
      for (let u = 0; u < this.getRenderLayers(); u++)
        this._renderToTarget(0, e, t, u, o), r.incrementRenderId(), r.resetCachedMaterial();
    else if (this.isCube)
      for (let u = 0; u < 6; u++)
        this._renderToTarget(u, e, t, void 0, o), r.incrementRenderId(), r.resetCachedMaterial();
    else
      this._renderToTarget(0, e, t, void 0, o);
    return this.onAfterUnbindObservable.notifyObservers(this), n.currentRenderPassId = a, h && (r.activeCamera = h, (r.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== r.activeCamera) && r.setTransformMatrix(r.activeCamera.getViewMatrix(), r.activeCamera.getProjectionMatrix(!0)), n.setViewport(r.activeCamera.viewport)), r.resetCachedMaterial(), l;
  }
  _bestReflectionRenderTargetDimension(e, t) {
    const s = e * t, r = I.NearestPOT(s + 128 * 128 / (128 + s));
    return Math.min(I.FloorPOT(e), r);
  }
  _prepareRenderingManager(e, t, i, s) {
    const r = this.getScene();
    if (!r)
      return;
    this._renderingManager.reset();
    const n = r.getRenderId();
    for (let a = 0; a < t; a++) {
      const o = e[a];
      if (o && !o.isBlocked) {
        if (this.customIsReadyFunction) {
          if (!this.customIsReadyFunction(o, this.refreshRate, !1)) {
            this.resetRefreshCounter();
            continue;
          }
        } else if (!o.isReady(this.refreshRate === 0)) {
          this.resetRefreshCounter();
          continue;
        }
        if (!o._internalAbstractMeshDataInfo._currentLODIsUpToDate && r.activeCamera && (o._internalAbstractMeshDataInfo._currentLOD = r.customLODSelector ? r.customLODSelector(o, this.activeCamera || r.activeCamera) : o.getLOD(this.activeCamera || r.activeCamera), o._internalAbstractMeshDataInfo._currentLODIsUpToDate = !0), !o._internalAbstractMeshDataInfo._currentLOD)
          continue;
        let h = o._internalAbstractMeshDataInfo._currentLOD;
        h._preActivateForIntermediateRendering(n);
        let l;
        if (s && i ? l = (o.layerMask & i.layerMask) === 0 : l = !1, o.isEnabled() && o.isVisible && o.subMeshes && !l && (h !== o && h._activate(n, !0), o._activate(n, !0) && o.subMeshes.length)) {
          o.isAnInstance ? o._internalAbstractMeshDataInfo._actAsRegularMesh && (h = o) : h._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !1, h._internalAbstractMeshDataInfo._isActiveIntermediate = !0;
          for (let u = 0; u < h.subMeshes.length; u++) {
            const d = h.subMeshes[u];
            this._renderingManager.dispatch(d, h);
          }
        }
      }
    }
    for (let a = 0; a < r.particleSystems.length; a++) {
      const o = r.particleSystems[a], h = o.emitter;
      !o.isStarted() || !h || !h.position || !h.isEnabled() || e.indexOf(h) >= 0 && this._renderingManager.dispatchParticles(o);
    }
  }
  _bindFrameBuffer(e = 0, t = 0) {
    const i = this.getScene();
    if (!i)
      return;
    const s = i.getEngine();
    this._renderTarget && s.bindFramebuffer(this._renderTarget, this.isCube ? e : void 0, void 0, void 0, this.ignoreCameraViewport, 0, t);
  }
  _unbindFrameBuffer(e, t) {
    !this._renderTarget || e.unBindFramebuffer(this._renderTarget, this.isCube, () => {
      this.onAfterRenderObservable.notifyObservers(t);
    });
  }
  _prepareFrame(e, t, i, s) {
    this._postProcessManager ? this._prePassEnabled || this._postProcessManager._prepareFrame(this._texture, this._postProcesses) : (!s || !e.postProcessManager._prepareFrame(this._texture)) && this._bindFrameBuffer(t, i);
  }
  _renderToTarget(e, t, i, s = 0, r = null) {
    var n, a, o, h, l, u;
    const d = this.getScene();
    if (!d)
      return;
    const f = d.getEngine();
    if ((n = f._debugPushGroup) === null || n === void 0 || n.call(f, `render to face #${e} layer #${s}`, 1), this._prepareFrame(d, e, s, t), this.is2DArray ? (f.currentRenderPassId = this._renderPassIds[s], this.onBeforeRenderObservable.notifyObservers(s)) : (f.currentRenderPassId = this._renderPassIds[e], this.onBeforeRenderObservable.notifyObservers(e)), f.snapshotRendering && f.snapshotRenderingMode === 1)
      this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(f) : this.skipInitialClear || f.clear(this.clearColor || d.clearColor, !0, !0, !0);
    else {
      let E = null;
      const m = this.renderList ? this.renderList : d.getActiveMeshes().data, v = this.renderList ? this.renderList.length : d.getActiveMeshes().length;
      this.getCustomRenderList && (E = this.getCustomRenderList(this.is2DArray ? s : e, m, v)), E ? this._prepareRenderingManager(E, E.length, r, this.forceLayerMaskCheck) : (this._defaultRenderListPrepared || (this._prepareRenderingManager(m, v, r, !this.renderList || this.forceLayerMaskCheck), this._defaultRenderListPrepared = !0), E = m);
      for (const y of d._beforeRenderTargetClearStage)
        y.action(this, e, s);
      this.onClearObservable.hasObservers() ? this.onClearObservable.notifyObservers(f) : this.skipInitialClear || f.clear(this.clearColor || d.clearColor, !0, !0, !0), this._doNotChangeAspectRatio || d.updateTransformMatrix(!0);
      for (const y of d._beforeRenderTargetDrawStage)
        y.action(this, e, s);
      this._renderingManager.render(this.customRenderFunction, E, this.renderParticles, this.renderSprites);
      for (const y of d._afterRenderTargetDrawStage)
        y.action(this, e, s);
      const S = (o = (a = this._texture) === null || a === void 0 ? void 0 : a.generateMipMaps) !== null && o !== void 0 ? o : !1;
      this._texture && (this._texture.generateMipMaps = !1), this._postProcessManager ? this._postProcessManager._finalizeFrame(!1, (h = this._renderTarget) !== null && h !== void 0 ? h : void 0, e, this._postProcesses, this.ignoreCameraViewport) : t && d.postProcessManager._finalizeFrame(!1, (l = this._renderTarget) !== null && l !== void 0 ? l : void 0, e);
      for (const y of d._afterRenderTargetPostProcessStage)
        y.action(this, e, s);
      this._texture && (this._texture.generateMipMaps = S), this._doNotChangeAspectRatio || d.updateTransformMatrix(!0), i && $e.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), f);
    }
    this._unbindFrameBuffer(f, e), this._texture && this.isCube && e === 5 && f.generateMipMapsForCubemap(this._texture), (u = f._debugPopGroup) === null || u === void 0 || u.call(f, 1);
  }
  setRenderingOrder(e, t = null, i = null, s = null) {
    this._renderingManager.setRenderingOrder(e, t, i, s);
  }
  setRenderingAutoClearDepthStencil(e, t) {
    this._renderingManager.setRenderingAutoClearDepthStencil(e, t), this._renderingManager._useSceneAutoClearSetup = !1;
  }
  clone() {
    const e = this.getSize(), t = new _t(this.name, e, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
    return t.hasAlpha = this.hasAlpha, t.level = this.level, t.coordinatesMode = this.coordinatesMode, this.renderList && (t.renderList = this.renderList.slice(0)), t;
  }
  serialize() {
    if (!this.name)
      return null;
    const e = super.serialize();
    if (e.renderTargetSize = this.getRenderSize(), e.renderList = [], this.renderList)
      for (let t = 0; t < this.renderList.length; t++)
        e.renderList.push(this.renderList[t].id);
    return e;
  }
  disposeFramebufferObjects() {
    var e;
    (e = this._renderTarget) === null || e === void 0 || e.dispose(!0);
  }
  releaseInternalTexture() {
    var e;
    (e = this._renderTarget) === null || e === void 0 || e.releaseTextures(), this._texture = null;
  }
  dispose() {
    var e;
    this.onResizeObservable.clear(), this.onClearObservable.clear(), this.onAfterRenderObservable.clear(), this.onAfterUnbindObservable.clear(), this.onBeforeBindObservable.clear(), this.onBeforeRenderObservable.clear(), this._postProcessManager && (this._postProcessManager.dispose(), this._postProcessManager = null), this._prePassRenderTarget && this._prePassRenderTarget.dispose(), this._releaseRenderPassId(), this.clearPostProcesses(!0), this._resizeObserver && (this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver), this._resizeObserver = null), this.renderList = null;
    const t = this.getScene();
    if (!t)
      return;
    let i = t.customRenderTargets.indexOf(this);
    i >= 0 && t.customRenderTargets.splice(i, 1);
    for (const s of t.cameras)
      i = s.customRenderTargets.indexOf(this), i >= 0 && s.customRenderTargets.splice(i, 1);
    (e = this._renderTarget) === null || e === void 0 || e.dispose(), this._renderTarget = null, this._texture = null, super.dispose();
  }
  _rebuild() {
    this.refreshRate === _t.REFRESHRATE_RENDER_ONCE && (this.refreshRate = _t.REFRESHRATE_RENDER_ONCE), this._postProcessManager && this._postProcessManager._rebuild();
  }
  freeRenderingGroups() {
    this._renderingManager && this._renderingManager.freeRenderingGroups();
  }
  getViewCount() {
    return 1;
  }
}
_t.REFRESHRATE_RENDER_ONCE = 0;
_t.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
_t.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
B._CreateRenderTargetTexture = (c, e, t, i, s) => new _t(c, e, t, i);
class Se {
  constructor(e, t, i, s, r, n, a = 1, o, h, l = null, u = 0, d = "postprocess", f, _ = !1, E = 5, m = Ke.GLSL) {
    this._parentContainer = null, this.width = -1, this.height = -1, this.nodeMaterialSource = null, this._outputTexture = null, this.autoClear = !0, this.alphaMode = 0, this.animations = new Array(), this.enablePixelPerfectMode = !1, this.forceFullscreenViewport = !0, this.scaleMode = 1, this.alwaysForcePOT = !1, this._samples = 1, this.adaptScaleToCurrentViewport = !1, this._reusable = !1, this._renderId = 0, this.externalTextureSamplerBinding = !1, this._textures = new Qe(2), this._textureCache = [], this._currentRenderTextureInd = 0, this._scaleRatio = new Te(1, 1), this._texelSize = Te.Zero(), this.onActivateObservable = new w(), this.onSizeChangedObservable = new w(), this.onApplyObservable = new w(), this.onBeforeRenderObservable = new w(), this.onAfterRenderObservable = new w(), this.name = e, n != null ? (this._camera = n, this._scene = n.getScene(), n.attachPostProcess(this), this._engine = this._scene.getEngine(), this._scene.postProcesses.push(this), this.uniqueId = this._scene.getUniqueId()) : o && (this._engine = o, this._engine.postProcesses.push(this)), this._options = r, this.renderTargetSamplingMode = a || 1, this._reusable = h || !1, this._textureType = u, this._textureFormat = E, this._shaderLanguage = m, this._samplers = s || [], this._samplers.push("textureSampler"), this._fragmentUrl = t, this._vertexUrl = d, this._parameters = i || [], this._parameters.push("scale"), this._indexParameters = f, this._drawWrapper = new Ri(this._engine), _ || this.updateEffect(l);
  }
  static RegisterShaderCodeProcessing(e, t) {
    if (!t) {
      delete Se._CustomShaderCodeProcessing[e != null ? e : ""];
      return;
    }
    Se._CustomShaderCodeProcessing[e != null ? e : ""] = t;
  }
  static _GetShaderCodeProcessing(e) {
    var t;
    return (t = Se._CustomShaderCodeProcessing[e]) !== null && t !== void 0 ? t : Se._CustomShaderCodeProcessing[""];
  }
  get samples() {
    return this._samples;
  }
  set samples(e) {
    this._samples = Math.min(e, this._engine.getCaps().maxMSAASamples), this._textures.forEach((t) => {
      t.setSamples(this._samples);
    });
  }
  getEffectName() {
    return this._fragmentUrl;
  }
  set onActivate(e) {
    this._onActivateObserver && this.onActivateObservable.remove(this._onActivateObserver), e && (this._onActivateObserver = this.onActivateObservable.add(e));
  }
  set onSizeChanged(e) {
    this._onSizeChangedObserver && this.onSizeChangedObservable.remove(this._onSizeChangedObserver), this._onSizeChangedObserver = this.onSizeChangedObservable.add(e);
  }
  set onApply(e) {
    this._onApplyObserver && this.onApplyObservable.remove(this._onApplyObserver), this._onApplyObserver = this.onApplyObservable.add(e);
  }
  set onBeforeRender(e) {
    this._onBeforeRenderObserver && this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver), this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(e);
  }
  set onAfterRender(e) {
    this._onAfterRenderObserver && this.onAfterRenderObservable.remove(this._onAfterRenderObserver), this._onAfterRenderObserver = this.onAfterRenderObservable.add(e);
  }
  get inputTexture() {
    return this._textures.data[this._currentRenderTextureInd];
  }
  set inputTexture(e) {
    this._forcedOutputTexture = e;
  }
  restoreDefaultInputTexture() {
    this._forcedOutputTexture && (this._forcedOutputTexture = null, this.markTextureDirty());
  }
  getCamera() {
    return this._camera;
  }
  get texelSize() {
    return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.texelSize : (this._forcedOutputTexture && this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height), this._texelSize);
  }
  getClassName() {
    return "PostProcess";
  }
  getEngine() {
    return this._engine;
  }
  getEffect() {
    return this._drawWrapper.effect;
  }
  shareOutputWith(e) {
    return this._disposeTextures(), this._shareOutputWithPostProcess = e, this;
  }
  useOwnOutput() {
    this._textures.length == 0 && (this._textures = new Qe(2)), this._shareOutputWithPostProcess = null;
  }
  updateEffect(e = null, t = null, i = null, s, r, n, a, o) {
    var h, l;
    const u = Se._GetShaderCodeProcessing(this.name);
    if (u != null && u.defineCustomBindings) {
      const d = (h = t == null ? void 0 : t.slice()) !== null && h !== void 0 ? h : [];
      d.push(...this._parameters);
      const f = (l = i == null ? void 0 : i.slice()) !== null && l !== void 0 ? l : [];
      f.push(...this._samplers), e = u.defineCustomBindings(this.name, e, d, f), t = d, i = f;
    }
    this._postProcessDefines = e, this._drawWrapper.effect = this._engine.createEffect({ vertex: a != null ? a : this._vertexUrl, fragment: o != null ? o : this._fragmentUrl }, {
      attributes: ["position"],
      uniformsNames: t || this._parameters,
      uniformBuffersNames: [],
      samplers: i || this._samplers,
      defines: e !== null ? e : "",
      fallbacks: null,
      onCompiled: r != null ? r : null,
      onError: n != null ? n : null,
      indexParameters: s || this._indexParameters,
      processCodeAfterIncludes: u != null && u.processCodeAfterIncludes ? (d, f) => u.processCodeAfterIncludes(this.name, d, f) : null,
      processFinalCode: u != null && u.processFinalCode ? (d, f) => u.processFinalCode(this.name, d, f) : null,
      shaderLanguage: this._shaderLanguage
    }, this._engine);
  }
  isReusable() {
    return this._reusable;
  }
  markTextureDirty() {
    this.width = -1;
  }
  _createRenderTargetTexture(e, t, i = 0) {
    for (let r = 0; r < this._textureCache.length; r++)
      if (this._textureCache[r].texture.width === e.width && this._textureCache[r].texture.height === e.height && this._textureCache[r].postProcessChannel === i && this._textureCache[r].texture._generateDepthBuffer === t.generateDepthBuffer && this._textureCache[r].texture.samples === t.samples)
        return this._textureCache[r].texture;
    const s = this._engine.createRenderTargetTexture(e, t);
    return this._textureCache.push({ texture: s, postProcessChannel: i, lastUsedRenderId: -1 }), s;
  }
  _flushTextureCache() {
    const e = this._renderId;
    for (let t = this._textureCache.length - 1; t >= 0; t--)
      if (e - this._textureCache[t].lastUsedRenderId > 100) {
        let i = !1;
        for (let s = 0; s < this._textures.length; s++)
          if (this._textures.data[s] === this._textureCache[t].texture) {
            i = !0;
            break;
          }
        i || (this._textureCache[t].texture.dispose(), this._textureCache.splice(t, 1));
      }
  }
  _resize(e, t, i, s, r) {
    this._textures.length > 0 && this._textures.reset(), this.width = e, this.height = t;
    let n = null;
    for (let h = 0; h < i._postProcesses.length; h++)
      if (i._postProcesses[h] !== null) {
        n = i._postProcesses[h];
        break;
      }
    const a = { width: this.width, height: this.height }, o = {
      generateMipMaps: s,
      generateDepthBuffer: r || n === this,
      generateStencilBuffer: (r || n === this) && this._engine.isStencilEnable,
      samplingMode: this.renderTargetSamplingMode,
      type: this._textureType,
      format: this._textureFormat,
      samples: this._samples
    };
    this._textures.push(this._createRenderTargetTexture(a, o, 0)), this._reusable && this._textures.push(this._createRenderTargetTexture(a, o, 1)), this._texelSize.copyFromFloats(1 / this.width, 1 / this.height), this.onSizeChangedObservable.notifyObservers(this);
  }
  activate(e, t = null, i) {
    var s, r;
    e = e || this._camera;
    const n = e.getScene(), a = n.getEngine(), o = a.getCaps().maxTextureSize;
    let h = (t ? t.width : this._engine.getRenderWidth(!0)) * this._options | 0;
    const l = (t ? t.height : this._engine.getRenderHeight(!0)) * this._options | 0, u = e.parent;
    u && (u.leftCamera == e || u.rightCamera == e) && (h /= 2);
    let d = this._options.width || h, f = this._options.height || l;
    const _ = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
    if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
      if (this.adaptScaleToCurrentViewport) {
        const m = a.currentViewport;
        m && (d *= m.width, f *= m.height);
      }
      (_ || this.alwaysForcePOT) && (this._options.width || (d = a.needPOTTextures ? I.GetExponentOfTwo(d, o, this.scaleMode) : d), this._options.height || (f = a.needPOTTextures ? I.GetExponentOfTwo(f, o, this.scaleMode) : f)), (this.width !== d || this.height !== f) && this._resize(d, f, e, _, i), this._textures.forEach((m) => {
        m.samples !== this.samples && this._engine.updateRenderTargetTextureSampleCount(m, this.samples);
      }), this._flushTextureCache(), this._renderId++;
    }
    let E;
    if (this._shareOutputWithPostProcess)
      E = this._shareOutputWithPostProcess.inputTexture;
    else if (this._forcedOutputTexture)
      E = this._forcedOutputTexture, this.width = this._forcedOutputTexture.width, this.height = this._forcedOutputTexture.height;
    else {
      E = this.inputTexture;
      let m;
      for (let v = 0; v < this._textureCache.length; v++)
        if (this._textureCache[v].texture === E) {
          m = this._textureCache[v];
          break;
        }
      m && (m.lastUsedRenderId = this._renderId);
    }
    return this.enablePixelPerfectMode ? (this._scaleRatio.copyFromFloats(h / d, l / f), this._engine.bindFramebuffer(E, 0, h, l, this.forceFullscreenViewport)) : (this._scaleRatio.copyFromFloats(1, 1), this._engine.bindFramebuffer(E, 0, void 0, void 0, this.forceFullscreenViewport)), (r = (s = this._engine)._debugInsertMarker) === null || r === void 0 || r.call(s, `post process ${this.name} input`), this.onActivateObservable.notifyObservers(e), this.autoClear && this.alphaMode === 0 && this._engine.clear(this.clearColor ? this.clearColor : n.clearColor, n._allowPostProcessClearColor, !0, !0), this._reusable && (this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2), E;
  }
  get isSupported() {
    return this._drawWrapper.effect.isSupported;
  }
  get aspectRatio() {
    return this._shareOutputWithPostProcess ? this._shareOutputWithPostProcess.aspectRatio : this._forcedOutputTexture ? this._forcedOutputTexture.width / this._forcedOutputTexture.height : this.width / this.height;
  }
  isReady() {
    var e, t;
    return (t = (e = this._drawWrapper.effect) === null || e === void 0 ? void 0 : e.isReady()) !== null && t !== void 0 ? t : !1;
  }
  apply() {
    var e, t, i;
    if (!(!((e = this._drawWrapper.effect) === null || e === void 0) && e.isReady()))
      return null;
    this._engine.enableEffect(this._drawWrapper), this._engine.setState(!1), this._engine.setDepthBuffer(!1), this._engine.setDepthWrite(!1), this._engine.setAlphaMode(this.alphaMode), this.alphaConstants && this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
    let s;
    return this._shareOutputWithPostProcess ? s = this._shareOutputWithPostProcess.inputTexture : this._forcedOutputTexture ? s = this._forcedOutputTexture : s = this.inputTexture, this.externalTextureSamplerBinding || this._drawWrapper.effect._bindTexture("textureSampler", s == null ? void 0 : s.texture), this._drawWrapper.effect.setVector2("scale", this._scaleRatio), this.onApplyObservable.notifyObservers(this._drawWrapper.effect), (i = (t = Se._GetShaderCodeProcessing(this.name)) === null || t === void 0 ? void 0 : t.bindCustomBindings) === null || i === void 0 || i.call(t, this.name, this._drawWrapper.effect), this._drawWrapper.effect;
  }
  _disposeTextures() {
    if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
      this._disposeTextureCache();
      return;
    }
    this._disposeTextureCache(), this._textures.dispose();
  }
  _disposeTextureCache() {
    for (let e = this._textureCache.length - 1; e >= 0; e--)
      this._textureCache[e].texture.dispose();
    this._textureCache.length = 0;
  }
  setPrePassRenderer(e) {
    return this._prePassEffectConfiguration ? (this._prePassEffectConfiguration = e.addEffectConfiguration(this._prePassEffectConfiguration), this._prePassEffectConfiguration.enabled = !0, !0) : !1;
  }
  dispose(e) {
    e = e || this._camera, this._disposeTextures();
    let t;
    if (this._scene && (t = this._scene.postProcesses.indexOf(this), t !== -1 && this._scene.postProcesses.splice(t, 1)), this._parentContainer) {
      const i = this._parentContainer.postProcesses.indexOf(this);
      i > -1 && this._parentContainer.postProcesses.splice(i, 1), this._parentContainer = null;
    }
    if (t = this._engine.postProcesses.indexOf(this), t !== -1 && this._engine.postProcesses.splice(t, 1), !!e) {
      if (e.detachPostProcess(this), t = e._postProcesses.indexOf(this), t === 0 && e._postProcesses.length > 0) {
        const i = this._camera._getFirstPostProcess();
        i && i.markTextureDirty();
      }
      this.onActivateObservable.clear(), this.onAfterRenderObservable.clear(), this.onApplyObservable.clear(), this.onBeforeRenderObservable.clear(), this.onSizeChangedObservable.clear();
    }
  }
  serialize() {
    const e = ae.Serialize(this), t = this.getCamera() || this._scene && this._scene.activeCamera;
    return e.customType = "BABYLON." + this.getClassName(), e.cameraId = t ? t.id : null, e.reusable = this._reusable, e.textureType = this._textureType, e.fragmentUrl = this._fragmentUrl, e.parameters = this._parameters, e.samplers = this._samplers, e.options = this._options, e.defines = this._postProcessDefines, e.textureFormat = this._textureFormat, e.vertexUrl = this._vertexUrl, e.indexParameters = this._indexParameters, e;
  }
  clone() {
    const e = this.serialize();
    e._engine = this._engine, e.cameraId = null;
    const t = Se.Parse(e, this._scene, "");
    return t ? (t.onActivateObservable = this.onActivateObservable.clone(), t.onSizeChangedObservable = this.onSizeChangedObservable.clone(), t.onApplyObservable = this.onApplyObservable.clone(), t.onBeforeRenderObservable = this.onBeforeRenderObservable.clone(), t.onAfterRenderObservable = this.onAfterRenderObservable.clone(), t._prePassEffectConfiguration = this._prePassEffectConfiguration, t) : null;
  }
  static Parse(e, t, i) {
    const s = ci(e.customType);
    if (!s || !s._Parse)
      return null;
    const r = t ? t.getCameraById(e.cameraId) : null;
    return s._Parse(e, r, t, i);
  }
  static _Parse(e, t, i, s) {
    return ae.Parse(() => new Se(e.name, e.fragmentUrl, e.parameters, e.samplers, e.options, t, e.renderTargetSamplingMode, e._engine, e.reusable, e.defines, e.textureType, e.vertexUrl, e.indexParameters, !1, e.textureFormat), e, i, s);
  }
}
Se._CustomShaderCodeProcessing = {};
T([
  R()
], Se.prototype, "uniqueId", void 0);
T([
  R()
], Se.prototype, "name", void 0);
T([
  R()
], Se.prototype, "width", void 0);
T([
  R()
], Se.prototype, "height", void 0);
T([
  R()
], Se.prototype, "renderTargetSamplingMode", void 0);
T([
  Fr()
], Se.prototype, "clearColor", void 0);
T([
  R()
], Se.prototype, "autoClear", void 0);
T([
  R()
], Se.prototype, "alphaMode", void 0);
T([
  R()
], Se.prototype, "alphaConstants", void 0);
T([
  R()
], Se.prototype, "enablePixelPerfectMode", void 0);
T([
  R()
], Se.prototype, "forceFullscreenViewport", void 0);
T([
  R()
], Se.prototype, "scaleMode", void 0);
T([
  R()
], Se.prototype, "alwaysForcePOT", void 0);
T([
  R("samples")
], Se.prototype, "_samples", void 0);
T([
  R()
], Se.prototype, "adaptScaleToCurrentViewport", void 0);
st("BABYLON.PostProcess", Se);
const la = "kernelBlurVaryingDeclaration", ca = "varying vec2 sampleCoord{X};";
U.IncludesShadersStore[la] = ca;
const ua = "packingFunctions", da = `vec4 pack(float depth)
{
const vec4 bit_shift=vec4(255.0*255.0*255.0,255.0*255.0,255.0,1.0);
const vec4 bit_mask=vec4(0.0,1.0/255.0,1.0/255.0,1.0/255.0);
vec4 res=fract(depth*bit_shift);
res-=res.xxyz*bit_mask;
return res;
}
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}`;
U.IncludesShadersStore[ua] = da;
const fa = "kernelBlurFragment", _a = `#ifdef DOF
factor=sampleCoC(sampleCoord{X}); 
computedWeight=KERNEL_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCoord{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCoord{X})*computedWeight;
#endif
`;
U.IncludesShadersStore[fa] = _a;
const ga = "kernelBlurFragment2", pa = `#ifdef DOF
factor=sampleCoC(sampleCenter+delta*KERNEL_DEP_OFFSET{X});
computedWeight=KERNEL_DEP_WEIGHT{X}*factor;
sumOfWeights+=computedWeight;
#else
computedWeight=KERNEL_DEP_WEIGHT{X};
#endif
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X}))*computedWeight;
#else
blend+=texture2D(textureSampler,sampleCenter+delta*KERNEL_DEP_OFFSET{X})*computedWeight;
#endif
`;
U.IncludesShadersStore[ga] = pa;
const ma = "kernelBlurPixelShader", Ea = `uniform sampler2D textureSampler;
uniform vec2 delta;
varying vec2 sampleCenter;
#ifdef DOF
uniform sampler2D circleOfConfusionSampler;
float sampleCoC(in vec2 offset) {
float coc=texture2D(circleOfConfusionSampler,offset).r;
return coc; 
}
#endif
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
#ifdef PACKEDFLOAT
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
float computedWeight=0.0;
#ifdef PACKEDFLOAT
float blend=0.;
#else
vec4 blend=vec4(0.);
#endif
#ifdef DOF
float sumOfWeights=CENTER_WEIGHT; 
float factor=0.0;
#ifdef PACKEDFLOAT
blend+=unpack(texture2D(textureSampler,sampleCenter))*CENTER_WEIGHT;
#else
blend+=texture2D(textureSampler,sampleCenter)*CENTER_WEIGHT;
#endif
#endif
#include<kernelBlurFragment>[0..varyingCount]
#include<kernelBlurFragment2>[0..depCount]
#ifdef PACKEDFLOAT
gl_FragColor=pack(blend);
#else
gl_FragColor=blend;
#endif
#ifdef DOF
gl_FragColor/=sumOfWeights;
#endif
}`;
U.ShadersStore[ma] = Ea;
const va = "kernelBlurVertex", Ta = "sampleCoord{X}=sampleCenter+delta*KERNEL_OFFSET{X};";
U.IncludesShadersStore[va] = Ta;
const ba = "kernelBlurVertexShader", Sa = `attribute vec2 position;
uniform vec2 delta;
varying vec2 sampleCenter;
#include<kernelBlurVaryingDeclaration>[0..varyingCount]
const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
sampleCenter=(position*madd+madd);
#include<kernelBlurVertex>[0..varyingCount]
gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
U.ShadersStore[ba] = Sa;
class Jt extends Se {
  constructor(e, t, i, s, r, n = B.BILINEAR_SAMPLINGMODE, a, o, h = 0, l = "", u = !1, d = 5) {
    super(e, "kernelBlur", ["delta", "direction"], ["circleOfConfusionSampler"], s, r, n, a, o, null, h, "kernelBlur", { varyingCount: 0, depCount: 0 }, !0, d), this._blockCompilation = u, this._packedFloat = !1, this._staticDefines = "", this._staticDefines = l, this.direction = t, this.onApplyObservable.add((f) => {
      this._outputTexture ? f.setFloat2("delta", 1 / this._outputTexture.width * this.direction.x, 1 / this._outputTexture.height * this.direction.y) : f.setFloat2("delta", 1 / this.width * this.direction.x, 1 / this.height * this.direction.y);
    }), this.kernel = i;
  }
  set kernel(e) {
    this._idealKernel !== e && (e = Math.max(e, 1), this._idealKernel = e, this._kernel = this._nearestBestKernel(e), this._blockCompilation || this._updateParameters());
  }
  get kernel() {
    return this._idealKernel;
  }
  set packedFloat(e) {
    this._packedFloat !== e && (this._packedFloat = e, this._blockCompilation || this._updateParameters());
  }
  get packedFloat() {
    return this._packedFloat;
  }
  getClassName() {
    return "BlurPostProcess";
  }
  updateEffect(e = null, t = null, i = null, s, r, n) {
    this._updateParameters(r, n);
  }
  _updateParameters(e, t) {
    const i = this._kernel, s = (i - 1) / 2;
    let r = [], n = [], a = 0;
    for (let m = 0; m < i; m++) {
      const v = m / (i - 1), S = this._gaussianWeight(v * 2 - 1);
      r[m] = m - s, n[m] = S, a += S;
    }
    for (let m = 0; m < n.length; m++)
      n[m] /= a;
    const o = [], h = [], l = [];
    for (let m = 0; m <= s; m += 2) {
      const v = Math.min(m + 1, Math.floor(s));
      if (m === v)
        l.push({ o: r[m], w: n[m] });
      else {
        const y = v === s, A = n[m] + n[v] * (y ? 0.5 : 1), C = r[m] + 1 / (1 + n[m] / n[v]);
        C === 0 ? (l.push({ o: r[m], w: n[m] }), l.push({ o: r[m + 1], w: n[m + 1] })) : (l.push({ o: C, w: A }), l.push({ o: -C, w: A }));
      }
    }
    for (let m = 0; m < l.length; m++)
      h[m] = l[m].o, o[m] = l[m].w;
    r = h, n = o;
    const u = this.getEngine().getCaps().maxVaryingVectors, d = Math.max(u, 0) - 1;
    let f = Math.min(r.length, d), _ = "";
    _ += this._staticDefines, this._staticDefines.indexOf("DOF") != -1 && (_ += `#define CENTER_WEIGHT ${this._glslFloat(n[f - 1])}\r
`, f--);
    for (let m = 0; m < f; m++)
      _ += `#define KERNEL_OFFSET${m} ${this._glslFloat(r[m])}\r
`, _ += `#define KERNEL_WEIGHT${m} ${this._glslFloat(n[m])}\r
`;
    let E = 0;
    for (let m = d; m < r.length; m++)
      _ += `#define KERNEL_DEP_OFFSET${E} ${this._glslFloat(r[m])}\r
`, _ += `#define KERNEL_DEP_WEIGHT${E} ${this._glslFloat(n[m])}\r
`, E++;
    this.packedFloat && (_ += "#define PACKEDFLOAT 1"), this._blockCompilation = !1, super.updateEffect(_, null, null, {
      varyingCount: f,
      depCount: E
    }, e, t);
  }
  _nearestBestKernel(e) {
    const t = Math.round(e);
    for (const i of [t, t - 1, t + 1, t - 2, t + 2])
      if (i % 2 !== 0 && Math.floor(i / 2) % 2 === 0 && i > 0)
        return Math.max(i, 3);
    return Math.max(t, 3);
  }
  _gaussianWeight(e) {
    const t = 0.3333333333333333, i = Math.sqrt(2 * Math.PI) * t, s = -(e * e / (2 * t * t));
    return 1 / i * Math.exp(s);
  }
  _glslFloat(e, t = 8) {
    return e.toFixed(t).replace(/0+$/, "");
  }
  static _Parse(e, t, i, s) {
    return ae.Parse(() => new Jt(e.name, e.direction, e.kernel, e.options, t, e.renderTargetSamplingMode, i.getEngine(), e.reusable, e.textureType, void 0, !1), e, i, s);
  }
}
T([
  R("kernel")
], Jt.prototype, "_kernel", void 0);
T([
  R("packedFloat")
], Jt.prototype, "_packedFloat", void 0);
T([
  Cn()
], Jt.prototype, "direction", void 0);
st("BABYLON.BlurPostProcess", Jt);
class qs {
  constructor() {
    this._defines = {}, this._currentRank = 32, this._maxRank = -1, this._mesh = null;
  }
  unBindMesh() {
    this._mesh = null;
  }
  addFallback(e, t) {
    this._defines[e] || (e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e), this._defines[e] = new Array()), this._defines[e].push(t);
  }
  addCPUSkinningFallback(e, t) {
    this._mesh = t, e < this._currentRank && (this._currentRank = e), e > this._maxRank && (this._maxRank = e);
  }
  get hasMoreFallbacks() {
    return this._currentRank <= this._maxRank;
  }
  reduce(e, t) {
    if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
      this._mesh.computeBonesUsingShaders = !1, e = e.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0"), t._bonesComputationForcedToCPU = !0;
      const i = this._mesh.getScene();
      for (let s = 0; s < i.meshes.length; s++) {
        const r = i.meshes[s];
        if (!r.material) {
          !this._mesh.material && r.computeBonesUsingShaders && r.numBoneInfluencers > 0 && (r.computeBonesUsingShaders = !1);
          continue;
        }
        if (!(!r.computeBonesUsingShaders || r.numBoneInfluencers === 0)) {
          if (r.material.getEffect() === t)
            r.computeBonesUsingShaders = !1;
          else if (r.subMeshes) {
            for (const n of r.subMeshes)
              if (n.effect === t) {
                r.computeBonesUsingShaders = !1;
                break;
              }
          }
        }
      }
    } else {
      const i = this._defines[this._currentRank];
      if (i)
        for (let s = 0; s < i.length; s++)
          e = e.replace("#define " + i[s], "");
      this._currentRank++;
    }
    return e;
  }
}
const xa = "bayerDitherFunctions", Ma = `float bayerDither2(vec2 _P) {
return mod(2.0*_P.y+_P.x+1.0,4.0);
}
float bayerDither4(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5*mod(_P,4.0)); 
return 4.0*bayerDither2(P1)+bayerDither2(P2);
}
float bayerDither8(vec2 _P) {
vec2 P1=mod(_P,2.0); 
vec2 P2=floor(0.5 *mod(_P,4.0)); 
vec2 P4=floor(0.25*mod(_P,8.0)); 
return 4.0*(4.0*bayerDither2(P1)+bayerDither2(P2))+bayerDither2(P4);
}
`;
U.IncludesShadersStore[xa] = Ma;
const Aa = "shadowMapFragmentExtraDeclaration", Ra = `#if SM_FLOAT==0
#include<packingFunctions>
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#include<bayerDitherFunctions>
uniform float softTransparentShadowSM;
#endif
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
uniform vec3 lightDataSM;
varying vec3 vPositionWSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
U.IncludesShadersStore[Aa] = Ra;
const ya = "clipPlaneFragmentDeclaration", Ca = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;
U.IncludesShadersStore[ya] = Ca;
const Ia = "clipPlaneFragment", Pa = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{
discard;
}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{
discard;
}
#endif
`;
U.IncludesShadersStore[Ia] = Pa;
const Da = "shadowMapFragment", Fa = `float depthSM=vDepthMetricSM;
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
#if SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
#ifdef USE_REVERSE_DEPTHBUFFER
depthSM=(-zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
depthSM=(zSM+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_FragDepth=clamp(1.0-depthSM,0.0,1.0);
#else
gl_FragDepth=clamp(depthSM,0.0,1.0); 
#endif
#elif SM_USEDISTANCE==1
depthSM=(length(vPositionWSM-lightDataSM)+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#if SM_ESM==1
depthSM=clamp(exp(-min(87.,biasAndScaleSM.z*depthSM)),0.,1.);
#endif
#if SM_FLOAT==1
gl_FragColor=vec4(depthSM,1.0,1.0,1.0);
#else
gl_FragColor=pack(depthSM);
#endif
return;`;
U.IncludesShadersStore[Da] = Fa;
const wa = "shadowMapPixelShader", Oa = `#include<shadowMapFragmentExtraDeclaration>
#ifdef ALPHATEXTURE
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEXTURE
float alphaFromAlphaTexture=texture2D(diffuseSampler,vUV).a;
#ifdef ALPHATESTVALUE
if (alphaFromAlphaTexture<ALPHATESTVALUE)
discard;
#endif
#endif
#if SM_SOFTTRANSPARENTSHADOW==1
#ifdef ALPHATEXTURE
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alphaFromAlphaTexture) discard;
#else
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM) discard;
#endif
#endif
#include<shadowMapFragment>
}`;
U.ShadersStore[wa] = Oa;
const La = "bonesDeclaration", Na = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;
attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;
attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform sampler2D boneSampler;
uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{
float offset=index *4.0;
float dx=1.0/boneTextureWidth;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));
return mat4(m0,m1,m2,m3);
}
#endif
#endif
#endif
`;
U.IncludesShadersStore[La] = Na;
const Ba = "bakedVertexAnimationDeclaration", Ua = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;
uniform vec2 bakedVertexAnimationTextureSizeInverted;
uniform vec4 bakedVertexAnimationSettings;
uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{
float offset=index*4.0;
float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;
float dx=bakedVertexAnimationTextureSizeInverted.x;
vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));
vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));
vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));
vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));
return mat4(m0,m1,m2,m3);
}
#endif
`;
U.IncludesShadersStore[Ba] = Ua;
const ka = "morphTargetsVertexGlobalDeclaration", Va = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
precision mediump sampler2DArray; 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];
uniform vec3 morphTargetTextureInfo;
uniform sampler2DArray morphTargets;
vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);
float x=vertexIndex-y*morphTargetTextureInfo.y;
vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);
return texture(morphTargets,textureUV).xyz;
}
#endif
#endif
`;
U.IncludesShadersStore[ka] = Va;
const Wa = "morphTargetsVertexDeclaration", za = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#endif
#endif
`;
U.IncludesShadersStore[Wa] = za;
const Ga = "helperFunctions", Xa = `const float PI=3.1415926535897932384626433832795;
const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;
const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;
const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);
const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {
vec3 i0=inMatrix[0];
vec3 i1=inMatrix[1];
vec3 i2=inMatrix[2];
mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);
return outMatrix;
}
mat3 inverseMat3(mat3 inMatrix) {
float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];
float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];
float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];
float b01=a22*a11-a12*a21;
float b11=-a22*a10+a12*a20;
float b21=a21*a10-a11*a20;
float det=a00*b01+a01*b11+a02*b21;
return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;
}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{
vec3 nearZeroSection=0.0773993808*color;
vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{
vec3 nearZeroSection=12.92*color;
vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;
float remainingSection=pow(0.947867299*(color+0.055),2.4);
return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;
float remainingSection=1.055*pow(color,0.41666)-0.055;
return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{
return value*value;
}
vec3 square(vec3 value)
{
return value*value;
}
float pow5(float value) {
float sq=value*value;
return sq*sq*value;
}
float getLuminance(vec3 color)
{
return clamp(dot(color,LuminanceEncodeApprox),0.,1.);
}
float getRand(vec2 seed) {
return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);
}
float dither(vec2 seed,float varianceAmount) {
float rand=getRand(seed);
float normVariance=varianceAmount/255.0;
float dither=mix(-normVariance,normVariance,rand);
return dither;
}
const float rgbdMaxRange=255.0;
vec4 toRGBD(vec3 color) {
float maxRGB=maxEps(max(color.r,max(color.g,color.b)));
float D =max(rgbdMaxRange/maxRGB,1.);
D =clamp(floor(D)/255.0,0.,1.);
vec3 rgb=color.rgb*D;
rgb=toGammaSpace(rgb);
return vec4(clamp(rgb,0.,1.),D); 
}
vec3 fromRGBD(vec4 rgbd) {
rgbd.rgb=toLinearSpace(rgbd.rgb);
return rgbd.rgb/rgbd.a;
}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {
vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;
vec3 halfSize=cubeSize*0.5;
vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;
vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;
vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);
float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);
vec3 intersectPositionWS=vertexPos+origVec*distance;
return intersectPositionWS-cubePos;
}
`;
U.IncludesShadersStore[Ga] = Xa;
const Ha = "sceneVertexDeclaration", Ka = `uniform mat4 viewProjection;
#ifdef MULTIVIEW
uniform mat4 viewProjectionR;
#endif
uniform mat4 view;
uniform mat4 projection;
uniform vec4 vEyePosition;
`;
U.IncludesShadersStore[Ha] = Ka;
const Ya = "meshVertexDeclaration", Za = `uniform mat4 world;
uniform float visibility;
`;
U.IncludesShadersStore[Ya] = Za;
const qa = "shadowMapVertexDeclaration", ja = `#include<sceneVertexDeclaration>
#include<meshVertexDeclaration>
`;
U.IncludesShadersStore[qa] = ja;
const Qa = "sceneUboDeclaration", $a = `layout(std140,column_major) uniform;
uniform Scene {
mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;
mat4 projection;
vec4 vEyePosition;
};
`;
U.IncludesShadersStore[Qa] = $a;
const Ja = "meshUboDeclaration", eo = `#ifdef WEBGL2
uniform mat4 world;
uniform float visibility;
#else
layout(std140,column_major) uniform;
uniform Mesh
{
mat4 world;
float visibility;
};
#endif
#define WORLD_UBO
`;
U.IncludesShadersStore[Ja] = eo;
const to = "shadowMapUboDeclaration", io = `layout(std140,column_major) uniform;
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
U.IncludesShadersStore[to] = io;
const so = "shadowMapVertexExtraDeclaration", ro = `#if SM_NORMALBIAS==1
uniform vec3 lightDataSM;
#endif
uniform vec3 biasAndScaleSM;
uniform vec2 depthValuesSM;
varying float vDepthMetricSM;
#if SM_USEDISTANCE==1
varying vec3 vPositionWSM;
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
varying float zSM;
#endif
`;
U.IncludesShadersStore[so] = ro;
const no = "clipPlaneVertexDeclaration", ao = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;
varying float fClipDistance6;
#endif
`;
U.IncludesShadersStore[no] = ao;
const oo = "morphTargetsVertexGlobal", ho = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
U.IncludesShadersStore[oo] = ho;
const lo = "morphTargetsVertex", co = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;
positionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];
vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];
vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
U.IncludesShadersStore[lo] = co;
const uo = "instancesVertex", fo = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
U.IncludesShadersStore[uo] = fo;
const _o = "bonesVertex", go = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
U.IncludesShadersStore[_o] = go;
const po = "bakedVertexAnimation", mo = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;
float VATEndFrame=BVASNAME.y;
float VATOffsetFrame=BVASNAME.z;
float VATSpeed=BVASNAME.w;
float totalFrames=VATEndFrame-VATStartFrame+1.0;
float time=bakedVertexAnimationTime*VATSpeed/totalFrames;
float frameCorrection=time<1.0 ? 0.0 : 1.0;
float numOfFrames=totalFrames-frameCorrection;
float VATFrameNum=fract(time)*numOfFrames;
VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);
VATFrameNum=floor(VATFrameNum);
VATFrameNum+=VATStartFrame+frameCorrection;
mat4 VATInfluence;
VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;
}
#endif
`;
U.IncludesShadersStore[po] = mo;
const Eo = "shadowMapVertexNormalBias", vo = `#if SM_NORMALBIAS==1
#if SM_DIRECTIONINLIGHTDATA==1
vec3 worldLightDirSM=normalize(-lightDataSM.xyz);
#else
vec3 directionToLightSM=lightDataSM.xyz-worldPos.xyz;
vec3 worldLightDirSM=normalize(directionToLightSM);
#endif
float ndlSM=dot(vNormalW,worldLightDirSM);
float sinNLSM=sqrt(1.0-ndlSM*ndlSM);
float normalBiasSM=biasAndScaleSM.y*sinNLSM;
worldPos.xyz-=vNormalW*normalBiasSM;
#endif
`;
U.IncludesShadersStore[Eo] = vo;
const To = "shadowMapVertexMetric", bo = `#if SM_USEDISTANCE==1
vPositionWSM=worldPos.xyz;
#endif
#if SM_DEPTHTEXTURE==1
#ifdef IS_NDC_HALF_ZRANGE
#define BIASFACTOR 0.5
#else
#define BIASFACTOR 1.0
#endif
#ifdef USE_REVERSE_DEPTHBUFFER
gl_Position.z-=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#else
gl_Position.z+=biasAndScaleSM.x*gl_Position.w*BIASFACTOR;
#endif
#endif
#if defined(SM_DEPTHCLAMP) && SM_DEPTHCLAMP==1
zSM=gl_Position.z;
gl_Position.z=0.0;
#elif SM_USEDISTANCE==0
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetricSM=(-gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#else
vDepthMetricSM=(gl_Position.z+depthValuesSM.x)/depthValuesSM.y+biasAndScaleSM.x;
#endif
#endif
`;
U.IncludesShadersStore[To] = bo;
const So = "clipPlaneVertex", xo = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;
U.IncludesShadersStore[So] = xo;
const Mo = "shadowMapVertexShader", Ao = `attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#endif
#include<helperFunctions>
#include<__decl__shadowMapVertex>
#ifdef ALPHATEXTURE
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
#include<shadowMapVertexExtraDeclaration>
#include<clipPlaneVertexDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normWorldSM=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vec3 vNormalW=normalUpdated/vec3(dot(normWorldSM[0],normWorldSM[0]),dot(normWorldSM[1],normWorldSM[1]),dot(normWorldSM[2],normWorldSM[2]));
vNormalW=normalize(normWorldSM*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normWorldSM=transposeMat3(inverseMat3(normWorldSM));
#endif
vec3 vNormalW=normalize(normWorldSM*normalUpdated);
#endif
#endif
#include<shadowMapVertexNormalBias>
gl_Position=viewProjection*worldPos;
#include<shadowMapVertexMetric>
#ifdef ALPHATEXTURE
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
#include<clipPlaneVertex>
}`;
U.ShadersStore[Mo] = Ao;
const Ro = "depthBoxBlurPixelShader", yo = `varying vec2 vUV;
uniform sampler2D textureSampler;
uniform vec2 screenSize;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
vec4 colorDepth=vec4(0.0);
for (int x=-OFFSET; x<=OFFSET; x++)
for (int y=-OFFSET; y<=OFFSET; y++)
colorDepth+=texture2D(textureSampler,vUV+vec2(x,y)/screenSize);
gl_FragColor=(colorDepth/float((OFFSET*2+1)*(OFFSET*2+1)));
}`;
U.ShadersStore[Ro] = yo;
const Co = "shadowMapFragmentSoftTransparentShadow", Io = `#if SM_SOFTTRANSPARENTSHADOW==1
if ((bayerDither8(floor(mod(gl_FragCoord.xy,8.0))))/64.0>=softTransparentShadowSM*alpha) discard;
#endif
`;
U.IncludesShadersStore[Co] = Io;
class G {
  constructor(e, t, i, s) {
    this.onBeforeShadowMapRenderObservable = new w(), this.onAfterShadowMapRenderObservable = new w(), this.onBeforeShadowMapRenderMeshObservable = new w(), this.onAfterShadowMapRenderMeshObservable = new w(), this._bias = 5e-5, this._normalBias = 0, this._blurBoxOffset = 1, this._blurScale = 2, this._blurKernel = 1, this._useKernelBlur = !1, this._filter = G.FILTER_NONE, this._filteringQuality = G.QUALITY_HIGH, this._contactHardeningLightSizeUVRatio = 0.1, this._darkness = 0, this._transparencyShadow = !1, this.enableSoftTransparentShadow = !1, this.useOpacityTextureForTransparentShadow = !1, this.frustumEdgeFalloff = 0, this.forceBackFacesOnly = !1, this._lightDirection = p.Zero(), this._viewMatrix = x.Zero(), this._projectionMatrix = x.Zero(), this._transformMatrix = x.Zero(), this._cachedPosition = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cachedDirection = new p(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._currentFaceIndex = 0, this._currentFaceIndexCache = 0, this._defaultTextureMatrix = x.Identity(), this._mapSize = e, this._light = t, this._scene = t.getScene(), this._camera = s != null ? s : null;
    let r = t._shadowGenerators;
    r || (r = t._shadowGenerators = /* @__PURE__ */ new Map()), r.set(this._camera, this), this.id = t.id, this._useUBO = this._scene.getEngine().supportsUniformBuffers, this._useUBO && (this._sceneUBOs = [], this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for Shadow Generator (light "${this._light.name}")`))), G._SceneComponentInitialization(this._scene);
    const n = this._scene.getEngine().getCaps();
    i ? n.textureFloatRender && n.textureFloatLinearFiltering ? this._textureType = 1 : n.textureHalfFloatRender && n.textureHalfFloatLinearFiltering ? this._textureType = 2 : this._textureType = 0 : n.textureHalfFloatRender && n.textureHalfFloatLinearFiltering ? this._textureType = 2 : n.textureFloatRender && n.textureFloatLinearFiltering ? this._textureType = 1 : this._textureType = 0, this._initializeGenerator(), this._applyFilterValues();
  }
  get bias() {
    return this._bias;
  }
  set bias(e) {
    this._bias = e;
  }
  get normalBias() {
    return this._normalBias;
  }
  set normalBias(e) {
    this._normalBias = e;
  }
  get blurBoxOffset() {
    return this._blurBoxOffset;
  }
  set blurBoxOffset(e) {
    this._blurBoxOffset !== e && (this._blurBoxOffset = e, this._disposeBlurPostProcesses());
  }
  get blurScale() {
    return this._blurScale;
  }
  set blurScale(e) {
    this._blurScale !== e && (this._blurScale = e, this._disposeBlurPostProcesses());
  }
  get blurKernel() {
    return this._blurKernel;
  }
  set blurKernel(e) {
    this._blurKernel !== e && (this._blurKernel = e, this._disposeBlurPostProcesses());
  }
  get useKernelBlur() {
    return this._useKernelBlur;
  }
  set useKernelBlur(e) {
    this._useKernelBlur !== e && (this._useKernelBlur = e, this._disposeBlurPostProcesses());
  }
  get depthScale() {
    return this._depthScale !== void 0 ? this._depthScale : this._light.getDepthScale();
  }
  set depthScale(e) {
    this._depthScale = e;
  }
  _validateFilter(e) {
    return e;
  }
  get filter() {
    return this._filter;
  }
  set filter(e) {
    if (e = this._validateFilter(e), this._light.needCube()) {
      if (e === G.FILTER_BLUREXPONENTIALSHADOWMAP) {
        this.useExponentialShadowMap = !0;
        return;
      } else if (e === G.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP) {
        this.useCloseExponentialShadowMap = !0;
        return;
      } else if (e === G.FILTER_PCF || e === G.FILTER_PCSS) {
        this.usePoissonSampling = !0;
        return;
      }
    }
    if ((e === G.FILTER_PCF || e === G.FILTER_PCSS) && !this._scene.getEngine()._features.supportShadowSamplers) {
      this.usePoissonSampling = !0;
      return;
    }
    this._filter !== e && (this._filter = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty());
  }
  get usePoissonSampling() {
    return this.filter === G.FILTER_POISSONSAMPLING;
  }
  set usePoissonSampling(e) {
    const t = this._validateFilter(G.FILTER_POISSONSAMPLING);
    !e && this.filter !== G.FILTER_POISSONSAMPLING || (this.filter = e ? t : G.FILTER_NONE);
  }
  get useExponentialShadowMap() {
    return this.filter === G.FILTER_EXPONENTIALSHADOWMAP;
  }
  set useExponentialShadowMap(e) {
    const t = this._validateFilter(G.FILTER_EXPONENTIALSHADOWMAP);
    !e && this.filter !== G.FILTER_EXPONENTIALSHADOWMAP || (this.filter = e ? t : G.FILTER_NONE);
  }
  get useBlurExponentialShadowMap() {
    return this.filter === G.FILTER_BLUREXPONENTIALSHADOWMAP;
  }
  set useBlurExponentialShadowMap(e) {
    const t = this._validateFilter(G.FILTER_BLUREXPONENTIALSHADOWMAP);
    !e && this.filter !== G.FILTER_BLUREXPONENTIALSHADOWMAP || (this.filter = e ? t : G.FILTER_NONE);
  }
  get useCloseExponentialShadowMap() {
    return this.filter === G.FILTER_CLOSEEXPONENTIALSHADOWMAP;
  }
  set useCloseExponentialShadowMap(e) {
    const t = this._validateFilter(G.FILTER_CLOSEEXPONENTIALSHADOWMAP);
    !e && this.filter !== G.FILTER_CLOSEEXPONENTIALSHADOWMAP || (this.filter = e ? t : G.FILTER_NONE);
  }
  get useBlurCloseExponentialShadowMap() {
    return this.filter === G.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP;
  }
  set useBlurCloseExponentialShadowMap(e) {
    const t = this._validateFilter(G.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP);
    !e && this.filter !== G.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP || (this.filter = e ? t : G.FILTER_NONE);
  }
  get usePercentageCloserFiltering() {
    return this.filter === G.FILTER_PCF;
  }
  set usePercentageCloserFiltering(e) {
    const t = this._validateFilter(G.FILTER_PCF);
    !e && this.filter !== G.FILTER_PCF || (this.filter = e ? t : G.FILTER_NONE);
  }
  get filteringQuality() {
    return this._filteringQuality;
  }
  set filteringQuality(e) {
    this._filteringQuality !== e && (this._filteringQuality = e, this._disposeBlurPostProcesses(), this._applyFilterValues(), this._light._markMeshesAsLightDirty());
  }
  get useContactHardeningShadow() {
    return this.filter === G.FILTER_PCSS;
  }
  set useContactHardeningShadow(e) {
    const t = this._validateFilter(G.FILTER_PCSS);
    !e && this.filter !== G.FILTER_PCSS || (this.filter = e ? t : G.FILTER_NONE);
  }
  get contactHardeningLightSizeUVRatio() {
    return this._contactHardeningLightSizeUVRatio;
  }
  set contactHardeningLightSizeUVRatio(e) {
    this._contactHardeningLightSizeUVRatio = e;
  }
  get darkness() {
    return this._darkness;
  }
  set darkness(e) {
    this.setDarkness(e);
  }
  getDarkness() {
    return this._darkness;
  }
  setDarkness(e) {
    return e >= 1 ? this._darkness = 1 : e <= 0 ? this._darkness = 0 : this._darkness = e, this;
  }
  get transparencyShadow() {
    return this._transparencyShadow;
  }
  set transparencyShadow(e) {
    this.setTransparencyShadow(e);
  }
  setTransparencyShadow(e) {
    return this._transparencyShadow = e, this;
  }
  getShadowMap() {
    return this._shadowMap;
  }
  getShadowMapForRendering() {
    return this._shadowMap2 ? this._shadowMap2 : this._shadowMap;
  }
  getClassName() {
    return G.CLASSNAME;
  }
  addShadowCaster(e, t = !0) {
    if (!this._shadowMap)
      return this;
    if (this._shadowMap.renderList || (this._shadowMap.renderList = []), this._shadowMap.renderList.indexOf(e) === -1 && this._shadowMap.renderList.push(e), t)
      for (const i of e.getChildMeshes())
        this._shadowMap.renderList.indexOf(i) === -1 && this._shadowMap.renderList.push(i);
    return this;
  }
  removeShadowCaster(e, t = !0) {
    if (!this._shadowMap || !this._shadowMap.renderList)
      return this;
    const i = this._shadowMap.renderList.indexOf(e);
    if (i !== -1 && this._shadowMap.renderList.splice(i, 1), t)
      for (const s of e.getChildren())
        this.removeShadowCaster(s);
    return this;
  }
  getLight() {
    return this._light;
  }
  _getCamera() {
    var e;
    return (e = this._camera) !== null && e !== void 0 ? e : this._scene.activeCamera;
  }
  get mapSize() {
    return this._mapSize;
  }
  set mapSize(e) {
    this._mapSize = e, this._light._markMeshesAsLightDirty(), this.recreateShadowMap();
  }
  _initializeGenerator() {
    this._light._markMeshesAsLightDirty(), this._initializeShadowMap();
  }
  _createTargetRenderTexture() {
    const e = this._scene.getEngine();
    e._features.supportDepthStencilTexture ? (this._shadowMap = new _t(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube(), void 0, !1, !1), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0)) : this._shadowMap = new _t(this._light.name + "_shadowMap", this._mapSize, this._scene, !1, !0, this._textureType, this._light.needCube());
  }
  _initializeShadowMap() {
    if (this._createTargetRenderTexture(), this._shadowMap === null)
      return;
    this._shadowMap.wrapU = B.CLAMP_ADDRESSMODE, this._shadowMap.wrapV = B.CLAMP_ADDRESSMODE, this._shadowMap.anisotropicFilteringLevel = 1, this._shadowMap.updateSamplingMode(B.BILINEAR_SAMPLINGMODE), this._shadowMap.renderParticles = !1, this._shadowMap.ignoreCameraViewport = !0, this._storedUniqueId && (this._shadowMap.uniqueId = this._storedUniqueId), this._shadowMap.customRenderFunction = this._renderForShadowMap.bind(this), this._shadowMap.customIsReadyFunction = () => !0;
    const e = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.add(() => {
      var s;
      this._currentSceneUBO = this._scene.getSceneUniformBuffer(), (s = e._debugPushGroup) === null || s === void 0 || s.call(e, `shadow map generation for pass id ${e.currentRenderPassId}`, 1);
    }), this._shadowMap.onBeforeRenderObservable.add((s) => {
      this._sceneUBOs && this._scene.setSceneUniformBuffer(this._sceneUBOs[0]), this._currentFaceIndex = s, this._filter === G.FILTER_PCF && e.setColorWrite(!1), this.getTransformMatrix(), this._scene.setTransformMatrix(this._viewMatrix, this._projectionMatrix), this._useUBO && (this._scene.getSceneUniformBuffer().unbindEffect(), this._scene.finalizeSceneUbo());
    }), this._shadowMap.onAfterUnbindObservable.add(() => {
      var s, r;
      if (this._sceneUBOs && this._scene.setSceneUniformBuffer(this._currentSceneUBO), this._scene.updateTransformMatrix(), this._filter === G.FILTER_PCF && e.setColorWrite(!0), !this.useBlurExponentialShadowMap && !this.useBlurCloseExponentialShadowMap) {
        (s = e._debugPopGroup) === null || s === void 0 || s.call(e, 1);
        return;
      }
      const n = this.getShadowMapForRendering();
      n && (this._scene.postProcessManager.directRender(this._blurPostProcesses, n.renderTarget, !0), e.unBindFramebuffer(n.renderTarget, !0), (r = e._debugPopGroup) === null || r === void 0 || r.call(e, 1));
    });
    const t = new ge(0, 0, 0, 0), i = new ge(1, 1, 1, 1);
    this._shadowMap.onClearObservable.add((s) => {
      this._filter === G.FILTER_PCF ? s.clear(i, !1, !0, !1) : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? s.clear(t, !0, !0, !1) : s.clear(i, !0, !0, !1);
    }), this._shadowMap.onResizeObservable.add((s) => {
      this._storedUniqueId = this._shadowMap.uniqueId, this._mapSize = s.getRenderSize(), this._light._markMeshesAsLightDirty(), this.recreateShadowMap();
    });
    for (let s = ze.MIN_RENDERINGGROUPS; s < ze.MAX_RENDERINGGROUPS; s++)
      this._shadowMap.setRenderingAutoClearDepthStencil(s, !1);
  }
  _initializeBlurRTTAndPostProcesses() {
    const e = this._scene.getEngine(), t = this._mapSize / this.blurScale;
    (!this.useKernelBlur || this.blurScale !== 1) && (this._shadowMap2 = new _t(this._light.name + "_shadowMap2", t, this._scene, !1, !0, this._textureType, void 0, void 0, !1), this._shadowMap2.wrapU = B.CLAMP_ADDRESSMODE, this._shadowMap2.wrapV = B.CLAMP_ADDRESSMODE, this._shadowMap2.updateSamplingMode(B.BILINEAR_SAMPLINGMODE)), this.useKernelBlur ? (this._kernelBlurXPostprocess = new Jt(this._light.name + "KernelBlurX", new Te(1, 0), this.blurKernel, 1, null, B.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.width = t, this._kernelBlurXPostprocess.height = t, this._kernelBlurXPostprocess.externalTextureSamplerBinding = !0, this._kernelBlurXPostprocess.onApplyObservable.add((i) => {
      i.setTexture("textureSampler", this._shadowMap);
    }), this._kernelBlurYPostprocess = new Jt(this._light.name + "KernelBlurY", new Te(0, 1), this.blurKernel, 1, null, B.BILINEAR_SAMPLINGMODE, e, !1, this._textureType), this._kernelBlurXPostprocess.autoClear = !1, this._kernelBlurYPostprocess.autoClear = !1, this._textureType === 0 && (this._kernelBlurXPostprocess.packedFloat = !0, this._kernelBlurYPostprocess.packedFloat = !0), this._blurPostProcesses = [this._kernelBlurXPostprocess, this._kernelBlurYPostprocess]) : (this._boxBlurPostprocess = new Se(this._light.name + "DepthBoxBlur", "depthBoxBlur", ["screenSize", "boxOffset"], [], 1, null, B.BILINEAR_SAMPLINGMODE, e, !1, "#define OFFSET " + this._blurBoxOffset, this._textureType), this._boxBlurPostprocess.externalTextureSamplerBinding = !0, this._boxBlurPostprocess.onApplyObservable.add((i) => {
      i.setFloat2("screenSize", t, t), i.setTexture("textureSampler", this._shadowMap);
    }), this._boxBlurPostprocess.autoClear = !1, this._blurPostProcesses = [this._boxBlurPostprocess]);
  }
  _renderForShadowMap(e, t, i, s) {
    let r;
    if (s.length)
      for (r = 0; r < s.length; r++)
        this._renderSubMeshForShadowMap(s.data[r]);
    for (r = 0; r < e.length; r++)
      this._renderSubMeshForShadowMap(e.data[r]);
    for (r = 0; r < t.length; r++)
      this._renderSubMeshForShadowMap(t.data[r]);
    if (this._transparencyShadow)
      for (r = 0; r < i.length; r++)
        this._renderSubMeshForShadowMap(i.data[r], !0);
    else
      for (r = 0; r < i.length; r++)
        i.data[r].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1;
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(e, t, i) {
    t.setMatrix("viewProjection", this.getTransformMatrix());
  }
  _renderSubMeshForShadowMap(e, t = !1) {
    var i, s;
    const r = e.getRenderingMesh(), n = e.getEffectiveMesh(), a = this._scene, o = a.getEngine(), h = e.getMaterial();
    if (n._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !h || e.verticesCount === 0 || e._renderId === a.getRenderId())
      return;
    const l = n._getWorldMatrixDeterminant() < 0;
    let u = (i = r.overrideMaterialSideOrientation) !== null && i !== void 0 ? i : h.sideOrientation;
    l && (u = u === 0 ? 1 : 0);
    const d = u === 0;
    o.setState(h.backFaceCulling, void 0, void 0, d, h.cullBackFaces);
    const f = r._getInstancesRenderList(e._id, !!e.getReplacementMesh());
    if (f.mustReturn)
      return;
    const _ = o.getCaps().instancedArrays && (f.visibleInstances[e._id] !== null && f.visibleInstances[e._id] !== void 0 || r.hasThinInstances);
    if (!(this.customAllowRendering && !this.customAllowRendering(e)))
      if (this.isReady(e, _, t)) {
        e._renderId = a.getRenderId();
        const E = h.shadowDepthWrapper, m = (s = E == null ? void 0 : E.getEffect(e, this, o.currentRenderPassId)) !== null && s !== void 0 ? s : e._getDrawWrapper(), v = Ri.GetEffect(m);
        o.enableEffect(m), _ || r._bind(e, v, h.fillMode), this.getTransformMatrix(), v.setFloat3("biasAndScaleSM", this.bias, this.normalBias, this.depthScale), this.getLight().getTypeID() === he.LIGHTTYPEID_DIRECTIONALLIGHT ? v.setVector3("lightDataSM", this._cachedDirection) : v.setVector3("lightDataSM", this._cachedPosition);
        const S = this._getCamera();
        if (S && v.setFloat2("depthValuesSM", this.getLight().getDepthMinZ(S), this.getLight().getDepthMinZ(S) + this.getLight().getDepthMaxZ(S)), t && this.enableSoftTransparentShadow && v.setFloat("softTransparentShadowSM", n.visibility * h.alpha), E)
          e._setMainDrawWrapperOverride(m), E.standalone ? E.baseMaterial.bindForSubMesh(n.getWorldMatrix(), r, e) : h.bindForSubMesh(n.getWorldMatrix(), r, e), e._setMainDrawWrapperOverride(null);
        else {
          if (this.useOpacityTextureForTransparentShadow) {
            const A = h.opacityTexture;
            A && (v.setTexture("diffuseSampler", A), v.setMatrix("diffuseMatrix", A.getTextureMatrix() || this._defaultTextureMatrix));
          } else if (h.needAlphaTesting() || h.needAlphaBlending()) {
            const A = h.getAlphaTestTexture();
            A && (v.setTexture("diffuseSampler", A), v.setMatrix("diffuseMatrix", A.getTextureMatrix() || this._defaultTextureMatrix));
          }
          if (r.useBones && r.computeBonesUsingShaders && r.skeleton) {
            const A = r.skeleton;
            if (A.isUsingTextureForMatrices) {
              const C = A.getTransformMatrixTexture(r);
              if (!C)
                return;
              v.setTexture("boneSampler", C), v.setFloat("boneTextureWidth", 4 * (A.bones.length + 1));
            } else
              v.setMatrices("mBones", A.getTransformMatrices(r));
          }
          te.BindMorphTargetParameters(r, v), r.morphTargetManager && r.morphTargetManager.isUsingTextureForTargets && r.morphTargetManager._bind(v), cs(v, h, a);
        }
        !this._useUBO && !E && this._bindCustomEffectForRenderSubMeshForShadowMap(e, v, n), te.BindSceneUniformBuffer(v, this._scene.getSceneUniformBuffer()), this._scene.getSceneUniformBuffer().bindUniformBuffer();
        const y = n.getWorldMatrix();
        _ && (n.getMeshUniformBuffer().bindToEffect(v, "Mesh"), n.transferToEffect(y)), this.forceBackFacesOnly && o.setState(!0, 0, !1, !0, h.cullBackFaces), this.onBeforeShadowMapRenderMeshObservable.notifyObservers(r), this.onBeforeShadowMapRenderObservable.notifyObservers(v), r._processRendering(n, e, v, h.fillMode, f, _, (A, C) => {
          n !== r && !A ? (r.getMeshUniformBuffer().bindToEffect(v, "Mesh"), r.transferToEffect(C)) : (n.getMeshUniformBuffer().bindToEffect(v, "Mesh"), n.transferToEffect(A ? C : y));
        }), this.forceBackFacesOnly && o.setState(!0, 0, !1, !1, h.cullBackFaces), this.onAfterShadowMapRenderObservable.notifyObservers(v), this.onAfterShadowMapRenderMeshObservable.notifyObservers(r);
      } else
        this._shadowMap && this._shadowMap.resetRefreshCounter();
  }
  _applyFilterValues() {
    !this._shadowMap || (this.filter === G.FILTER_NONE || this.filter === G.FILTER_PCSS ? this._shadowMap.updateSamplingMode(B.NEAREST_SAMPLINGMODE) : this._shadowMap.updateSamplingMode(B.BILINEAR_SAMPLINGMODE));
  }
  forceCompilation(e, t) {
    const i = {
      useInstances: !1,
      ...t
    }, s = this.getShadowMap();
    if (!s) {
      e && e(this);
      return;
    }
    const r = s.renderList;
    if (!r) {
      e && e(this);
      return;
    }
    const n = new Array();
    for (const h of r)
      n.push(...h.subMeshes);
    if (n.length === 0) {
      e && e(this);
      return;
    }
    let a = 0;
    const o = () => {
      var h, l;
      if (!(!this._scene || !this._scene.getEngine())) {
        for (; this.isReady(n[a], i.useInstances, (l = (h = n[a].getMaterial()) === null || h === void 0 ? void 0 : h.needAlphaBlendingForMesh(n[a].getMesh())) !== null && l !== void 0 ? l : !1); )
          if (a++, a >= n.length) {
            e && e(this);
            return;
          }
        setTimeout(o, 16);
      }
    };
    o();
  }
  forceCompilationAsync(e) {
    return new Promise((t) => {
      this.forceCompilation(() => {
        t();
      }, e);
    });
  }
  _isReadyCustomDefines(e, t, i) {
  }
  _prepareShadowDefines(e, t, i, s) {
    i.push("#define SM_LIGHTTYPE_" + this._light.getClassName().toUpperCase()), i.push("#define SM_FLOAT " + (this._textureType !== 0 ? "1" : "0")), i.push("#define SM_ESM " + (this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? "1" : "0")), i.push("#define SM_DEPTHTEXTURE " + (this.usePercentageCloserFiltering || this.useContactHardeningShadow ? "1" : "0"));
    const r = e.getMesh();
    return i.push("#define SM_NORMALBIAS " + (this.normalBias && r.isVerticesDataPresent(g.NormalKind) ? "1" : "0")), i.push("#define SM_DIRECTIONINLIGHTDATA " + (this.getLight().getTypeID() === he.LIGHTTYPEID_DIRECTIONALLIGHT ? "1" : "0")), i.push("#define SM_USEDISTANCE " + (this._light.needCube() ? "1" : "0")), i.push("#define SM_SOFTTRANSPARENTSHADOW " + (this.enableSoftTransparentShadow && s ? "1" : "0")), this._isReadyCustomDefines(i, e, t), i;
  }
  isReady(e, t, i) {
    var s;
    const r = e.getMaterial(), n = r == null ? void 0 : r.shadowDepthWrapper;
    if (!r)
      return !1;
    const a = [];
    if (this._prepareShadowDefines(e, t, a, i), n) {
      if (!n.isReadyForSubMesh(e, a, this, t, this._scene.getEngine().currentRenderPassId))
        return !1;
    } else {
      const o = e._getDrawWrapper(void 0, !0);
      let h = o.effect, l = o.defines;
      const u = [g.PositionKind], d = e.getMesh();
      this.normalBias && d.isVerticesDataPresent(g.NormalKind) && (u.push(g.NormalKind), a.push("#define NORMAL"), d.nonUniformScaling && a.push("#define NONUNIFORMSCALING"));
      const f = r == null ? void 0 : r.needAlphaTesting(), _ = r == null ? void 0 : r.needAlphaBlending();
      if (r && (f || _)) {
        let y = null;
        if (this.useOpacityTextureForTransparentShadow ? y = r.opacityTexture : y = r.getAlphaTestTexture(), y) {
          if (!y.isReady())
            return !1;
          const A = (s = r.alphaCutOff) !== null && s !== void 0 ? s : G.DEFAULT_ALPHA_CUTOFF;
          a.push("#define ALPHATEXTURE"), f && a.push(`#define ALPHATESTVALUE ${A}${A % 1 === 0 ? "." : ""}`), d.isVerticesDataPresent(g.UVKind) && (u.push(g.UVKind), a.push("#define UV1")), d.isVerticesDataPresent(g.UV2Kind) && y.coordinatesIndex === 1 && (u.push(g.UV2Kind), a.push("#define UV2"));
        }
      }
      const E = new qs();
      if (d.useBones && d.computeBonesUsingShaders && d.skeleton) {
        u.push(g.MatricesIndicesKind), u.push(g.MatricesWeightsKind), d.numBoneInfluencers > 4 && (u.push(g.MatricesIndicesExtraKind), u.push(g.MatricesWeightsExtraKind));
        const y = d.skeleton;
        a.push("#define NUM_BONE_INFLUENCERS " + d.numBoneInfluencers), d.numBoneInfluencers > 0 && E.addCPUSkinningFallback(0, d), y.isUsingTextureForMatrices ? a.push("#define BONETEXTURE") : a.push("#define BonesPerMesh " + (y.bones.length + 1));
      } else
        a.push("#define NUM_BONE_INFLUENCERS 0");
      const m = d.morphTargetManager;
      let v = 0;
      if (m && m.numInfluencers > 0 && (a.push("#define MORPHTARGETS"), v = m.numInfluencers, a.push("#define NUM_MORPH_INFLUENCERS " + v), m.isUsingTextureForTargets && a.push("#define MORPHTARGETS_TEXTURE"), te.PrepareAttributesForMorphTargetsInfluencers(u, d, v)), Ys(r, this._scene, a), t && (a.push("#define INSTANCES"), te.PushAttributesForInstances(u), e.getRenderingMesh().hasThinInstances && a.push("#define THIN_INSTANCES")), this.customShaderOptions && this.customShaderOptions.defines)
        for (const y of this.customShaderOptions.defines)
          a.indexOf(y) === -1 && a.push(y);
      const S = a.join(`
`);
      if (l !== S) {
        l = S;
        let y = "shadowMap";
        const A = [
          "world",
          "mBones",
          "viewProjection",
          "diffuseMatrix",
          "lightDataSM",
          "depthValuesSM",
          "biasAndScaleSM",
          "morphTargetInfluences",
          "boneTextureWidth",
          "softTransparentShadowSM",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ], C = ["diffuseSampler", "boneSampler", "morphTargets"], b = ["Scene", "Mesh"];
        if (ls(A), this.customShaderOptions) {
          if (y = this.customShaderOptions.shaderName, this.customShaderOptions.attributes)
            for (const L of this.customShaderOptions.attributes)
              u.indexOf(L) === -1 && u.push(L);
          if (this.customShaderOptions.uniforms)
            for (const L of this.customShaderOptions.uniforms)
              A.indexOf(L) === -1 && A.push(L);
          if (this.customShaderOptions.samplers)
            for (const L of this.customShaderOptions.samplers)
              C.indexOf(L) === -1 && C.push(L);
        }
        const M = this._scene.getEngine();
        h = M.createEffect(y, {
          attributes: u,
          uniformsNames: A,
          uniformBuffersNames: b,
          samplers: C,
          defines: S,
          fallbacks: E,
          onCompiled: null,
          onError: null,
          indexParameters: { maxSimultaneousMorphTargets: v }
        }, M), o.setEffect(h, l);
      }
      if (!h.isReady())
        return !1;
    }
    return (this.useBlurExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (!this._blurPostProcesses || !this._blurPostProcesses.length) && this._initializeBlurRTTAndPostProcesses(), !(this._kernelBlurXPostprocess && !this._kernelBlurXPostprocess.isReady() || this._kernelBlurYPostprocess && !this._kernelBlurYPostprocess.isReady() || this._boxBlurPostprocess && !this._boxBlurPostprocess.isReady());
  }
  prepareDefines(e, t) {
    const i = this._scene, s = this._light;
    !i.shadowsEnabled || !s.shadowEnabled || (e["SHADOW" + t] = !0, this.useContactHardeningShadow ? (e["SHADOWPCSS" + t] = !0, this._filteringQuality === G.QUALITY_LOW ? e["SHADOWLOWQUALITY" + t] = !0 : this._filteringQuality === G.QUALITY_MEDIUM && (e["SHADOWMEDIUMQUALITY" + t] = !0)) : this.usePercentageCloserFiltering ? (e["SHADOWPCF" + t] = !0, this._filteringQuality === G.QUALITY_LOW ? e["SHADOWLOWQUALITY" + t] = !0 : this._filteringQuality === G.QUALITY_MEDIUM && (e["SHADOWMEDIUMQUALITY" + t] = !0)) : this.usePoissonSampling ? e["SHADOWPOISSON" + t] = !0 : this.useExponentialShadowMap || this.useBlurExponentialShadowMap ? e["SHADOWESM" + t] = !0 : (this.useCloseExponentialShadowMap || this.useBlurCloseExponentialShadowMap) && (e["SHADOWCLOSEESM" + t] = !0), s.needCube() && (e["SHADOWCUBE" + t] = !0));
  }
  bindShadowLight(e, t) {
    const i = this._light;
    if (!this._scene.shadowsEnabled || !i.shadowEnabled)
      return;
    const r = this._getCamera();
    if (!r)
      return;
    const n = this.getShadowMap();
    !n || (i.needCube() || t.setMatrix("lightMatrix" + e, this.getTransformMatrix()), this._filter === G.FILTER_PCF ? (t.setDepthStencilTexture("shadowSampler" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), n.getSize().width, 1 / n.getSize().width, this.frustumEdgeFalloff, e)) : this._filter === G.FILTER_PCSS ? (t.setDepthStencilTexture("shadowSampler" + e, this.getShadowMapForRendering()), t.setTexture("depthSampler" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / n.getSize().width, this._contactHardeningLightSizeUVRatio * n.getSize().width, this.frustumEdgeFalloff, e)) : (t.setTexture("shadowSampler" + e, this.getShadowMapForRendering()), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), this.blurScale / n.getSize().width, this.depthScale, this.frustumEdgeFalloff, e)), i._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(r), this.getLight().getDepthMinZ(r) + this.getLight().getDepthMaxZ(r), e));
  }
  getTransformMatrix() {
    const e = this._scene;
    if (this._currentRenderId === e.getRenderId() && this._currentFaceIndexCache === this._currentFaceIndex)
      return this._transformMatrix;
    this._currentRenderId = e.getRenderId(), this._currentFaceIndexCache = this._currentFaceIndex;
    let t = this._light.position;
    if (this._light.computeTransformedInformation() && (t = this._light.transformedPosition), p.NormalizeToRef(this._light.getShadowDirection(this._currentFaceIndex), this._lightDirection), Math.abs(p.Dot(this._lightDirection, p.Up())) === 1 && (this._lightDirection.z = 1e-13), this._light.needProjectionMatrixCompute() || !this._cachedPosition || !this._cachedDirection || !t.equals(this._cachedPosition) || !this._lightDirection.equals(this._cachedDirection)) {
      this._cachedPosition.copyFrom(t), this._cachedDirection.copyFrom(this._lightDirection), x.LookAtLHToRef(t, t.add(this._lightDirection), p.Up(), this._viewMatrix);
      const i = this.getShadowMap();
      if (i) {
        const s = i.renderList;
        s && this._light.setShadowProjectionMatrix(this._projectionMatrix, this._viewMatrix, s);
      }
      this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
    }
    return this._transformMatrix;
  }
  recreateShadowMap() {
    const e = this._shadowMap;
    if (!e)
      return;
    const t = e.renderList;
    if (this._disposeRTTandPostProcesses(), this._initializeGenerator(), this.filter = this._filter, this._applyFilterValues(), t) {
      this._shadowMap.renderList || (this._shadowMap.renderList = []);
      for (const i of t)
        this._shadowMap.renderList.push(i);
    } else
      this._shadowMap.renderList = null;
  }
  _disposeBlurPostProcesses() {
    this._shadowMap2 && (this._shadowMap2.dispose(), this._shadowMap2 = null), this._boxBlurPostprocess && (this._boxBlurPostprocess.dispose(), this._boxBlurPostprocess = null), this._kernelBlurXPostprocess && (this._kernelBlurXPostprocess.dispose(), this._kernelBlurXPostprocess = null), this._kernelBlurYPostprocess && (this._kernelBlurYPostprocess.dispose(), this._kernelBlurYPostprocess = null), this._blurPostProcesses = [];
  }
  _disposeRTTandPostProcesses() {
    this._shadowMap && (this._shadowMap.dispose(), this._shadowMap = null), this._disposeBlurPostProcesses();
  }
  _disposeSceneUBOs() {
    if (this._sceneUBOs) {
      for (const e of this._sceneUBOs)
        e.dispose();
      this._sceneUBOs = [];
    }
  }
  dispose() {
    if (this._disposeRTTandPostProcesses(), this._disposeSceneUBOs(), this._light) {
      if (this._light._shadowGenerators) {
        const e = this._light._shadowGenerators.entries();
        for (let t = e.next(); t.done !== !0; t = e.next()) {
          const [i, s] = t.value;
          s === this && this._light._shadowGenerators.delete(i);
        }
        this._light._shadowGenerators.size === 0 && (this._light._shadowGenerators = null);
      }
      this._light._markMeshesAsLightDirty();
    }
    this.onBeforeShadowMapRenderMeshObservable.clear(), this.onBeforeShadowMapRenderObservable.clear(), this.onAfterShadowMapRenderMeshObservable.clear(), this.onAfterShadowMapRenderObservable.clear();
  }
  serialize() {
    var e;
    const t = {}, i = this.getShadowMap();
    if (!i)
      return t;
    if (t.className = this.getClassName(), t.lightId = this._light.id, t.cameraId = (e = this._camera) === null || e === void 0 ? void 0 : e.id, t.id = this.id, t.mapSize = i.getRenderSize(), t.forceBackFacesOnly = this.forceBackFacesOnly, t.darkness = this.getDarkness(), t.transparencyShadow = this._transparencyShadow, t.frustumEdgeFalloff = this.frustumEdgeFalloff, t.bias = this.bias, t.normalBias = this.normalBias, t.usePercentageCloserFiltering = this.usePercentageCloserFiltering, t.useContactHardeningShadow = this.useContactHardeningShadow, t.contactHardeningLightSizeUVRatio = this.contactHardeningLightSizeUVRatio, t.filteringQuality = this.filteringQuality, t.useExponentialShadowMap = this.useExponentialShadowMap, t.useBlurExponentialShadowMap = this.useBlurExponentialShadowMap, t.useCloseExponentialShadowMap = this.useBlurExponentialShadowMap, t.useBlurCloseExponentialShadowMap = this.useBlurExponentialShadowMap, t.usePoissonSampling = this.usePoissonSampling, t.depthScale = this.depthScale, t.blurBoxOffset = this.blurBoxOffset, t.blurKernel = this.blurKernel, t.blurScale = this.blurScale, t.useKernelBlur = this.useKernelBlur, t.renderList = [], i.renderList)
      for (let s = 0; s < i.renderList.length; s++) {
        const r = i.renderList[s];
        t.renderList.push(r.id);
      }
    return t;
  }
  static Parse(e, t, i) {
    const s = t.getLightById(e.lightId), r = e.cameraId !== void 0 ? t.getCameraById(e.cameraId) : null, n = i ? i(e.mapSize, s, r) : new G(e.mapSize, s, void 0, r), a = n.getShadowMap();
    for (let o = 0; o < e.renderList.length; o++)
      t.getMeshesById(e.renderList[o]).forEach(function(l) {
        !a || (a.renderList || (a.renderList = []), a.renderList.push(l));
      });
    return e.id !== void 0 && (n.id = e.id), n.forceBackFacesOnly = !!e.forceBackFacesOnly, e.darkness !== void 0 && n.setDarkness(e.darkness), e.transparencyShadow && n.setTransparencyShadow(!0), e.frustumEdgeFalloff !== void 0 && (n.frustumEdgeFalloff = e.frustumEdgeFalloff), e.bias !== void 0 && (n.bias = e.bias), e.normalBias !== void 0 && (n.normalBias = e.normalBias), e.usePercentageCloserFiltering ? n.usePercentageCloserFiltering = !0 : e.useContactHardeningShadow ? n.useContactHardeningShadow = !0 : e.usePoissonSampling ? n.usePoissonSampling = !0 : e.useExponentialShadowMap ? n.useExponentialShadowMap = !0 : e.useBlurExponentialShadowMap ? n.useBlurExponentialShadowMap = !0 : e.useCloseExponentialShadowMap ? n.useCloseExponentialShadowMap = !0 : e.useBlurCloseExponentialShadowMap ? n.useBlurCloseExponentialShadowMap = !0 : e.useVarianceShadowMap ? n.useExponentialShadowMap = !0 : e.useBlurVarianceShadowMap && (n.useBlurExponentialShadowMap = !0), e.contactHardeningLightSizeUVRatio !== void 0 && (n.contactHardeningLightSizeUVRatio = e.contactHardeningLightSizeUVRatio), e.filteringQuality !== void 0 && (n.filteringQuality = e.filteringQuality), e.depthScale && (n.depthScale = e.depthScale), e.blurScale && (n.blurScale = e.blurScale), e.blurBoxOffset && (n.blurBoxOffset = e.blurBoxOffset), e.useKernelBlur && (n.useKernelBlur = e.useKernelBlur), e.blurKernel && (n.blurKernel = e.blurKernel), n;
  }
}
G.CLASSNAME = "ShadowGenerator";
G.FILTER_NONE = 0;
G.FILTER_EXPONENTIALSHADOWMAP = 1;
G.FILTER_POISSONSAMPLING = 2;
G.FILTER_BLUREXPONENTIALSHADOWMAP = 3;
G.FILTER_CLOSEEXPONENTIALSHADOWMAP = 4;
G.FILTER_BLURCLOSEEXPONENTIALSHADOWMAP = 5;
G.FILTER_PCF = 6;
G.FILTER_PCSS = 7;
G.QUALITY_HIGH = 0;
G.QUALITY_MEDIUM = 1;
G.QUALITY_LOW = 2;
G.DEFAULT_ALPHA_CUTOFF = 0.5;
G._SceneComponentInitialization = (c) => {
  throw Q("ShadowGeneratorSceneComponent");
};
const Po = "depthPixelShader", Do = `#ifdef ALPHATEST
varying vec2 vUV;
uniform sampler2D diffuseSampler;
#endif
#include<clipPlaneFragmentDeclaration>
varying float vDepthMetric;
#ifdef PACKED
#include<packingFunctions>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void)
{
#include<clipPlaneFragment>
#ifdef ALPHATEST
if (texture2D(diffuseSampler,vUV).a<0.4)
discard;
#endif
#ifdef NONLINEARDEPTH
#ifdef PACKED
gl_FragColor=pack(gl_FragCoord.z);
#else
gl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);
#endif
#else
#ifdef PACKED
gl_FragColor=pack(vDepthMetric);
#else
gl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);
#endif
#endif
}`;
U.ShadersStore[Po] = Do;
const Fo = "instancesDeclaration", wo = `#ifdef INSTANCES
attribute vec4 world0;
attribute vec4 world1;
attribute vec4 world2;
attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;
attribute vec4 previousWorld1;
attribute vec4 previousWorld2;
attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
U.IncludesShadersStore[Fo] = wo;
const Oo = "depthVertexShader", Lo = `attribute vec3 position;
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#include<clipPlaneVertexDeclaration>
#include<instancesDeclaration>
uniform mat4 viewProjection;
uniform vec2 depthValues;
#if defined(ALPHATEST) || defined(NEED_UV)
varying vec2 vUV;
uniform mat4 diffuseMatrix;
#ifdef UV1
attribute vec2 uv;
#endif
#ifdef UV2
attribute vec2 uv2;
#endif
#endif
varying float vDepthMetric;
#define CUSTOM_VERTEX_DEFINITIONS
void main(void)
{
vec3 positionUpdated=position;
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#include<clipPlaneVertex>
gl_Position=viewProjection*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));
#else
vDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));
#endif
#if defined(ALPHATEST) || defined(BASIC_RENDER)
#ifdef UV1
vUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));
#endif
#ifdef UV2
vUV=vec2(diffuseMatrix*vec4(uv2,1.0,0.0));
#endif
#endif
}
`;
U.ShadersStore[Oo] = Lo;
class ds {
  constructor(e, t = 1, i = null, s = !1, r = B.TRILINEAR_SAMPLINGMODE) {
    this.enabled = !0, this.forceDepthWriteTransparentMeshes = !1, this.useOnlyInActiveCamera = !1, this._scene = e, this._storeNonLinearDepth = s, this.isPacked = t === 0, this.isPacked ? this._clearColor = new ge(1, 1, 1, 1) : this._clearColor = new ge(1, 0, 0, 1), ds._SceneComponentInitialization(this._scene);
    const n = e.getEngine();
    this._camera = i, r !== B.NEAREST_SAMPLINGMODE && (t === 1 && !n._caps.textureFloatLinearFiltering && (r = B.NEAREST_SAMPLINGMODE), t === 2 && !n._caps.textureHalfFloatLinearFiltering && (r = B.NEAREST_SAMPLINGMODE));
    const a = this.isPacked || !n._features.supportExtendedTextureFormats ? 5 : 6;
    this._depthMap = new _t("DepthRenderer", { width: n.getRenderWidth(), height: n.getRenderHeight() }, this._scene, !1, !0, t, !1, r, void 0, void 0, void 0, a), this._depthMap.wrapU = B.CLAMP_ADDRESSMODE, this._depthMap.wrapV = B.CLAMP_ADDRESSMODE, this._depthMap.refreshRate = 1, this._depthMap.renderParticles = !1, this._depthMap.renderList = null, this._depthMap.activeCamera = this._camera, this._depthMap.ignoreCameraViewport = !0, this._depthMap.useCameraPostProcesses = !1, this._depthMap.onClearObservable.add((h) => {
      h.clear(this._clearColor, !0, !0, !0);
    }), this._depthMap.onBeforeBindObservable.add(() => {
      var h;
      (h = n._debugPushGroup) === null || h === void 0 || h.call(n, "depth renderer", 1);
    }), this._depthMap.onAfterUnbindObservable.add(() => {
      var h;
      (h = n._debugPopGroup) === null || h === void 0 || h.call(n, 1);
    }), this._depthMap.customIsReadyFunction = (h, l, u) => {
      if ((u || l === 0) && h.subMeshes)
        for (let d = 0; d < h.subMeshes.length; ++d) {
          const f = h.subMeshes[d], _ = f.getRenderingMesh(), E = _._getInstancesRenderList(f._id, !!f.getReplacementMesh()), m = n.getCaps().instancedArrays && (E.visibleInstances[f._id] !== null && E.visibleInstances[f._id] !== void 0 || _.hasThinInstances);
          if (!this.isReady(f, m))
            return !1;
        }
      return !0;
    };
    const o = (h) => {
      var l, u;
      const d = h.getRenderingMesh(), f = h.getEffectiveMesh(), _ = this._scene, E = _.getEngine(), m = h.getMaterial();
      if (f._internalAbstractMeshDataInfo._isActiveIntermediate = !1, !m || f.infiniteDistance || m.disableDepthWrite || h.verticesCount === 0 || h._renderId === _.getRenderId())
        return;
      const v = f._getWorldMatrixDeterminant() < 0;
      let S = (l = d.overrideMaterialSideOrientation) !== null && l !== void 0 ? l : m.sideOrientation;
      v && (S = S === 0 ? 1 : 0);
      const y = S === 0;
      E.setState(m.backFaceCulling, 0, !1, y, m.cullBackFaces);
      const A = d._getInstancesRenderList(h._id, !!h.getReplacementMesh());
      if (A.mustReturn)
        return;
      const C = E.getCaps().instancedArrays && (A.visibleInstances[h._id] !== null && A.visibleInstances[h._id] !== void 0 || d.hasThinInstances), b = this._camera || _.activeCamera;
      if (this.isReady(h, C) && b) {
        h._renderId = _.getRenderId();
        const M = (u = f._internalAbstractMeshDataInfo._materialForRenderPass) === null || u === void 0 ? void 0 : u[E.currentRenderPassId];
        let L = h._getDrawWrapper();
        !L && M && (L = M._getDrawWrapper());
        const k = b.mode === q.ORTHOGRAPHIC_CAMERA;
        if (!L)
          return;
        const F = L.effect;
        E.enableEffect(L), C || d._bind(h, F, m.fillMode), M ? M.bindForSubMesh(f.getWorldMatrix(), f, h) : (F.setMatrix("viewProjection", _.getTransformMatrix()), F.setMatrix("world", f.getWorldMatrix()));
        let ue, ce;
        if (k ? (ue = !E.useReverseDepthBuffer && E.isNDCHalfZRange ? 0 : 1, ce = E.useReverseDepthBuffer && E.isNDCHalfZRange ? 0 : 1) : (ue = E.useReverseDepthBuffer && E.isNDCHalfZRange ? b.minZ : E.isNDCHalfZRange ? 0 : b.minZ, ce = E.useReverseDepthBuffer && E.isNDCHalfZRange ? 0 : b.maxZ), F.setFloat2("depthValues", ue, ue + ce), !M) {
          if (m.needAlphaTesting()) {
            const ie = m.getAlphaTestTexture();
            ie && (F.setTexture("diffuseSampler", ie), F.setMatrix("diffuseMatrix", ie.getTextureMatrix()));
          }
          if (d.useBones && d.computeBonesUsingShaders && d.skeleton) {
            const ie = d.skeleton;
            if (ie.isUsingTextureForMatrices) {
              const ee = ie.getTransformMatrixTexture(d);
              if (!ee)
                return;
              F.setTexture("boneSampler", ee), F.setFloat("boneTextureWidth", 4 * (ie.bones.length + 1));
            } else
              F.setMatrices("mBones", ie.getTransformMatrices(d));
          }
          cs(F, m, _), te.BindMorphTargetParameters(d, F), d.morphTargetManager && d.morphTargetManager.isUsingTextureForTargets && d.morphTargetManager._bind(F);
        }
        d._processRendering(f, h, F, m.fillMode, A, C, (ie, ee) => F.setMatrix("world", ee));
      }
    };
    this._depthMap.customRenderFunction = (h, l, u, d) => {
      let f;
      if (d.length)
        for (f = 0; f < d.length; f++)
          o(d.data[f]);
      for (f = 0; f < h.length; f++)
        o(h.data[f]);
      for (f = 0; f < l.length; f++)
        o(l.data[f]);
      if (this.forceDepthWriteTransparentMeshes)
        for (f = 0; f < u.length; f++)
          o(u.data[f]);
      else
        for (f = 0; f < u.length; f++)
          u.data[f].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate = !1;
    };
  }
  setMaterialForRendering(e, t) {
    this._depthMap.setMaterialForRendering(e, t);
  }
  isReady(e, t) {
    var i;
    const s = this._scene.getEngine(), r = e.getMesh(), n = r.getScene(), a = (i = r._internalAbstractMeshDataInfo._materialForRenderPass) === null || i === void 0 ? void 0 : i[s.currentRenderPassId];
    if (a)
      return a.isReadyForSubMesh(r, e, t);
    const o = e.getMaterial();
    if (!o || o.disableDepthWrite)
      return !1;
    const h = [], l = [g.PositionKind];
    if (o && o.needAlphaTesting() && o.getAlphaTestTexture() && (h.push("#define ALPHATEST"), r.isVerticesDataPresent(g.UVKind) && (l.push(g.UVKind), h.push("#define UV1")), r.isVerticesDataPresent(g.UV2Kind) && (l.push(g.UV2Kind), h.push("#define UV2"))), r.useBones && r.computeBonesUsingShaders) {
      l.push(g.MatricesIndicesKind), l.push(g.MatricesWeightsKind), r.numBoneInfluencers > 4 && (l.push(g.MatricesIndicesExtraKind), l.push(g.MatricesWeightsExtraKind)), h.push("#define NUM_BONE_INFLUENCERS " + r.numBoneInfluencers), h.push("#define BonesPerMesh " + (r.skeleton ? r.skeleton.bones.length + 1 : 0));
      const m = e.getRenderingMesh().skeleton;
      m != null && m.isUsingTextureForMatrices && h.push("#define BONETEXTURE");
    } else
      h.push("#define NUM_BONE_INFLUENCERS 0");
    const u = r.morphTargetManager;
    let d = 0;
    u && u.numInfluencers > 0 && (d = u.numInfluencers, h.push("#define MORPHTARGETS"), h.push("#define NUM_MORPH_INFLUENCERS " + d), u.isUsingTextureForTargets && h.push("#define MORPHTARGETS_TEXTURE"), te.PrepareAttributesForMorphTargetsInfluencers(l, r, d)), t && (h.push("#define INSTANCES"), te.PushAttributesForInstances(l), e.getRenderingMesh().hasThinInstances && h.push("#define THIN_INSTANCES")), this._storeNonLinearDepth && h.push("#define NONLINEARDEPTH"), this.isPacked && h.push("#define PACKED"), Ys(o, n, h);
    const f = e._getDrawWrapper(void 0, !0), _ = f.defines, E = h.join(`
`);
    if (_ !== E) {
      const m = [
        "world",
        "mBones",
        "boneTextureWidth",
        "viewProjection",
        "diffuseMatrix",
        "depthValues",
        "morphTargetInfluences",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ];
      ls(m), f.setEffect(s.createEffect("depth", l, m, ["diffuseSampler", "morphTargets", "boneSampler"], E, void 0, void 0, void 0, {
        maxSimultaneousMorphTargets: d
      }), E);
    }
    return f.effect.isReady();
  }
  getDepthMap() {
    return this._depthMap;
  }
  dispose() {
    const e = [];
    for (const t in this._scene._depthRenderer)
      this._scene._depthRenderer[t] === this && e.push(t);
    if (e.length > 0) {
      this._depthMap.dispose();
      for (const t of e)
        delete this._scene._depthRenderer[t];
    }
  }
}
ds._SceneComponentInitialization = (c) => {
  throw Q("DepthRendererSceneComponent");
};
const No = "minmaxReduxPixelShader", Bo = `varying vec2 vUV;
uniform sampler2D textureSampler;
#if defined(INITIAL)
uniform sampler2D sourceTexture;
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
float f1=texelFetch(sourceTexture,coord,0).r;
float f2=texelFetch(sourceTexture,coord+ivec2(1,0),0).r;
float f3=texelFetch(sourceTexture,coord+ivec2(1,1),0).r;
float f4=texelFetch(sourceTexture,coord+ivec2(0,1),0).r;
float minz=min(min(min(f1,f2),f3),f4);
#ifdef DEPTH_REDUX
float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);
#else
float maxz=max(max(max(f1,f2),f3),f4);
#endif
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(MAIN)
uniform vec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*(texSize-1.0));
vec2 f1=texelFetch(textureSampler,coord,0).rg;
vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;
vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;
vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;
float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);
float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(ONEBEFORELAST)
uniform ivec2 texSize;
void main(void)
{
ivec2 coord=ivec2(vUV*vec2(texSize-1));
vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;
vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;
vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;
vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;
float minz=min(f1.x,f2.x);
float maxz=max(f1.y,f2.y);
glFragColor=vec4(minz,maxz,0.,0.);
}
#elif defined(LAST)
void main(void)
{
glFragColor=vec4(0.);
if (true) { 
discard;
}
}
#endif
`;
U.ShadersStore[No] = Bo;
class Uo {
  constructor(e) {
    this.onAfterReductionPerformed = new w(), this._forceFullscreenViewport = !0, this._activated = !1, this._camera = e, this._postProcessManager = new ts(e.getScene()), this._onContextRestoredObserver = e.getEngine().onContextRestoredObservable.add(() => {
      this._postProcessManager._rebuild();
    });
  }
  get sourceTexture() {
    return this._sourceTexture;
  }
  setSourceTexture(e, t, i = 2, s = !0) {
    if (e === this._sourceTexture)
      return;
    this.dispose(!1), this._sourceTexture = e, this._reductionSteps = [], this._forceFullscreenViewport = s;
    const r = this._camera.getScene(), n = new Se(
      "Initial reduction phase",
      "minmaxRedux",
      ["texSize"],
      ["sourceTexture"],
      1,
      null,
      1,
      r.getEngine(),
      !1,
      "#define INITIAL" + (t ? `
#define DEPTH_REDUX` : ""),
      i,
      void 0,
      void 0,
      void 0,
      7
    );
    n.autoClear = !1, n.forceFullscreenViewport = s;
    let a = this._sourceTexture.getRenderWidth(), o = this._sourceTexture.getRenderHeight();
    n.onApply = ((l, u) => (d) => {
      d.setTexture("sourceTexture", this._sourceTexture), d.setFloat2("texSize", l, u);
    })(a, o), this._reductionSteps.push(n);
    let h = 1;
    for (; a > 1 || o > 1; ) {
      a = Math.max(Math.round(a / 2), 1), o = Math.max(Math.round(o / 2), 1);
      const l = new Se(
        "Reduction phase " + h,
        "minmaxRedux",
        ["texSize"],
        null,
        { width: a, height: o },
        null,
        1,
        r.getEngine(),
        !1,
        "#define " + (a == 1 && o == 1 ? "LAST" : a == 1 || o == 1 ? "ONEBEFORELAST" : "MAIN"),
        i,
        void 0,
        void 0,
        void 0,
        7
      );
      if (l.autoClear = !1, l.forceFullscreenViewport = s, l.onApply = ((u, d) => (f) => {
        u == 1 || d == 1 ? f.setInt2("texSize", u, d) : f.setFloat2("texSize", u, d);
      })(a, o), this._reductionSteps.push(l), h++, a == 1 && o == 1) {
        const u = (d, f, _) => {
          const E = new Float32Array(4 * d * f), m = { min: 0, max: 0 };
          return () => {
            r.getEngine()._readTexturePixels(_.inputTexture.texture, d, f, -1, 0, E, !1), m.min = E[0], m.max = E[1], this.onAfterReductionPerformed.notifyObservers(m);
          };
        };
        l.onAfterRenderObservable.add(u(a, o, l));
      }
    }
  }
  get refreshRate() {
    return this._sourceTexture ? this._sourceTexture.refreshRate : -1;
  }
  set refreshRate(e) {
    this._sourceTexture && (this._sourceTexture.refreshRate = e);
  }
  get activated() {
    return this._activated;
  }
  activate() {
    this._onAfterUnbindObserver || !this._sourceTexture || (this._onAfterUnbindObserver = this._sourceTexture.onAfterUnbindObservable.add(() => {
      var e, t;
      const i = this._camera.getScene().getEngine();
      (e = i._debugPushGroup) === null || e === void 0 || e.call(i, "min max reduction", 1), this._reductionSteps[0].activate(this._camera), this._postProcessManager.directRender(this._reductionSteps, this._reductionSteps[0].inputTexture, this._forceFullscreenViewport), i.unBindFramebuffer(this._reductionSteps[0].inputTexture, !1), (t = i._debugPopGroup) === null || t === void 0 || t.call(i, 1);
    }), this._activated = !0);
  }
  deactivate() {
    !this._onAfterUnbindObserver || !this._sourceTexture || (this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver), this._onAfterUnbindObserver = null, this._activated = !1);
  }
  dispose(e = !0) {
    if (e && (this.onAfterReductionPerformed.clear(), this._onContextRestoredObserver && (this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver), this._onContextRestoredObserver = null)), this.deactivate(), this._reductionSteps) {
      for (let t = 0; t < this._reductionSteps.length; ++t)
        this._reductionSteps[t].dispose();
      this._reductionSteps = null;
    }
    this._postProcessManager && e && this._postProcessManager.dispose(), this._sourceTexture = null;
  }
}
class ko extends Uo {
  constructor(e) {
    super(e);
  }
  get depthRenderer() {
    return this._depthRenderer;
  }
  setDepthRenderer(e = null, t = 2, i = !0) {
    const s = this._camera.getScene();
    this._depthRenderer && (delete s._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null), e === null && (s._depthRenderer || (s._depthRenderer = {}), e = this._depthRenderer = new ds(s, t, this._camera, !1, 1), e.enabled = !1, this._depthRendererId = "minmax" + this._camera.id, s._depthRenderer[this._depthRendererId] = e), super.setSourceTexture(e.getDepthMap(), !0, t, i);
  }
  setSourceTexture(e, t, i = 2, s = !0) {
    super.setSourceTexture(e, t, i, s);
  }
  activate() {
    this._depthRenderer && (this._depthRenderer.enabled = !0), super.activate();
  }
  deactivate() {
    super.deactivate(), this._depthRenderer && (this._depthRenderer.enabled = !1);
  }
  dispose(e = !0) {
    if (super.dispose(e), this._depthRenderer && e) {
      const t = this._depthRenderer.getDepthMap().getScene();
      t && delete t._depthRenderer[this._depthRendererId], this._depthRenderer.dispose(), this._depthRenderer = null;
    }
  }
}
const mr = p.Up(), Vo = p.Zero(), Fe = new p(), mi = new p(), Yi = new x();
class Le extends G {
  constructor(e, t, i, s) {
    if (!Le.IsSupported) {
      O.Error("CascadedShadowMap is not supported by the current engine.");
      return;
    }
    super(e, t, i, s), this.usePercentageCloserFiltering = !0;
  }
  _validateFilter(e) {
    return e === G.FILTER_NONE || e === G.FILTER_PCF || e === G.FILTER_PCSS ? e : (console.error('Unsupported filter "' + e + '"!'), G.FILTER_NONE);
  }
  get numCascades() {
    return this._numCascades;
  }
  set numCascades(e) {
    e = Math.min(Math.max(e, Le.MIN_CASCADES_COUNT), Le.MAX_CASCADES_COUNT), e !== this._numCascades && (this._numCascades = e, this.recreateShadowMap(), this._recreateSceneUBOs());
  }
  get freezeShadowCastersBoundingInfo() {
    return this._freezeShadowCastersBoundingInfo;
  }
  set freezeShadowCastersBoundingInfo(e) {
    this._freezeShadowCastersBoundingInfoObservable && e && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), !this._freezeShadowCastersBoundingInfoObservable && !e && (this._freezeShadowCastersBoundingInfoObservable = this._scene.onBeforeRenderObservable.add(this._computeShadowCastersBoundingInfo.bind(this))), this._freezeShadowCastersBoundingInfo = e, e && this._computeShadowCastersBoundingInfo();
  }
  _computeShadowCastersBoundingInfo() {
    if (this._scbiMin.copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._scbiMax.copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), this._shadowMap && this._shadowMap.renderList) {
      const e = this._shadowMap.renderList;
      for (let i = 0; i < e.length; i++) {
        const s = e[i];
        if (!s)
          continue;
        const r = s.getBoundingInfo(), n = r.boundingBox;
        this._scbiMin.minimizeInPlace(n.minimumWorld), this._scbiMax.maximizeInPlace(n.maximumWorld);
      }
      const t = this._scene.meshes;
      for (let i = 0; i < t.length; i++) {
        const s = t[i];
        if (!s || !s.isVisible || !s.isEnabled || !s.receiveShadows)
          continue;
        const r = s.getBoundingInfo(), n = r.boundingBox;
        this._scbiMin.minimizeInPlace(n.minimumWorld), this._scbiMax.maximizeInPlace(n.maximumWorld);
      }
    }
    this._shadowCastersBoundingInfo.reConstruct(this._scbiMin, this._scbiMax);
  }
  get shadowCastersBoundingInfo() {
    return this._shadowCastersBoundingInfo;
  }
  set shadowCastersBoundingInfo(e) {
    this._shadowCastersBoundingInfo = e;
  }
  setMinMaxDistance(e, t) {
    this._minDistance === e && this._maxDistance === t || (e > t && (e = 0, t = 1), e < 0 && (e = 0), t > 1 && (t = 1), this._minDistance = e, this._maxDistance = t, this._breaksAreDirty = !0);
  }
  get minDistance() {
    return this._minDistance;
  }
  get maxDistance() {
    return this._maxDistance;
  }
  getClassName() {
    return Le.CLASSNAME;
  }
  getCascadeMinExtents(e) {
    return e >= 0 && e < this._numCascades ? this._cascadeMinExtents[e] : null;
  }
  getCascadeMaxExtents(e) {
    return e >= 0 && e < this._numCascades ? this._cascadeMaxExtents[e] : null;
  }
  get shadowMaxZ() {
    return this._getCamera() ? this._shadowMaxZ : 0;
  }
  set shadowMaxZ(e) {
    const t = this._getCamera();
    if (!t) {
      this._shadowMaxZ = e;
      return;
    }
    this._shadowMaxZ === e || e < t.minZ || e > t.maxZ || (this._shadowMaxZ = e, this._light._markMeshesAsLightDirty(), this._breaksAreDirty = !0);
  }
  get debug() {
    return this._debug;
  }
  set debug(e) {
    this._debug = e, this._light._markMeshesAsLightDirty();
  }
  get depthClamp() {
    return this._depthClamp;
  }
  set depthClamp(e) {
    this._depthClamp = e;
  }
  get cascadeBlendPercentage() {
    return this._cascadeBlendPercentage;
  }
  set cascadeBlendPercentage(e) {
    this._cascadeBlendPercentage = e, this._light._markMeshesAsLightDirty();
  }
  get lambda() {
    return this._lambda;
  }
  set lambda(e) {
    const t = Math.min(Math.max(e, 0), 1);
    this._lambda != t && (this._lambda = t, this._breaksAreDirty = !0);
  }
  getCascadeViewMatrix(e) {
    return e >= 0 && e < this._numCascades ? this._viewMatrices[e] : null;
  }
  getCascadeProjectionMatrix(e) {
    return e >= 0 && e < this._numCascades ? this._projectionMatrices[e] : null;
  }
  getCascadeTransformMatrix(e) {
    return e >= 0 && e < this._numCascades ? this._transformMatrices[e] : null;
  }
  setDepthRenderer(e) {
    this._depthRenderer = e, this._depthReducer && this._depthReducer.setDepthRenderer(this._depthRenderer);
  }
  get autoCalcDepthBounds() {
    return this._autoCalcDepthBounds;
  }
  set autoCalcDepthBounds(e) {
    const t = this._getCamera();
    if (!!t) {
      if (this._autoCalcDepthBounds = e, !e) {
        this._depthReducer && this._depthReducer.deactivate(), this.setMinMaxDistance(0, 1);
        return;
      }
      this._depthReducer || (this._depthReducer = new ko(t), this._depthReducer.onAfterReductionPerformed.add((i) => {
        let s = i.min, r = i.max;
        s >= r && (s = 0, r = 1), (s != this._minDistance || r != this._maxDistance) && this.setMinMaxDistance(s, r);
      }), this._depthReducer.setDepthRenderer(this._depthRenderer)), this._depthReducer.activate();
    }
  }
  get autoCalcDepthBoundsRefreshRate() {
    var e, t, i;
    return (i = (t = (e = this._depthReducer) === null || e === void 0 ? void 0 : e.depthRenderer) === null || t === void 0 ? void 0 : t.getDepthMap().refreshRate) !== null && i !== void 0 ? i : -1;
  }
  set autoCalcDepthBoundsRefreshRate(e) {
    var t;
    !((t = this._depthReducer) === null || t === void 0) && t.depthRenderer && (this._depthReducer.depthRenderer.getDepthMap().refreshRate = e);
  }
  splitFrustum() {
    this._breaksAreDirty = !0;
  }
  _splitFrustum() {
    const e = this._getCamera();
    if (!e)
      return;
    const t = e.minZ, i = e.maxZ, s = i - t, r = this._minDistance, n = this._shadowMaxZ < i && this._shadowMaxZ >= t ? Math.min((this._shadowMaxZ - t) / (i - t), this._maxDistance) : this._maxDistance, a = t + r * s, o = t + n * s, h = o - a, l = o / a;
    for (let u = 0; u < this._cascades.length; ++u) {
      const d = (u + 1) / this._numCascades, f = a * l ** d, _ = a + h * d, E = this._lambda * (f - _) + _;
      this._cascades[u].prevBreakDistance = u === 0 ? r : this._cascades[u - 1].breakDistance, this._cascades[u].breakDistance = (E - t) / s, this._viewSpaceFrustumsZ[u] = E, this._frustumLengths[u] = (this._cascades[u].breakDistance - this._cascades[u].prevBreakDistance) * s;
    }
    this._breaksAreDirty = !1;
  }
  _computeMatrices() {
    const e = this._scene;
    if (!this._getCamera())
      return;
    p.NormalizeToRef(this._light.getShadowDirection(0), this._lightDirection), Math.abs(p.Dot(this._lightDirection, p.Up())) === 1 && (this._lightDirection.z = 1e-13), this._cachedDirection.copyFrom(this._lightDirection);
    const i = e.getEngine().useReverseDepthBuffer;
    for (let s = 0; s < this._numCascades; ++s) {
      this._computeFrustumInWorldSpace(s), this._computeCascadeFrustum(s), this._cascadeMaxExtents[s].subtractToRef(this._cascadeMinExtents[s], Fe), this._frustumCenter[s].addToRef(this._lightDirection.scale(this._cascadeMinExtents[s].z), this._shadowCameraPos[s]), x.LookAtLHToRef(this._shadowCameraPos[s], this._frustumCenter[s], mr, this._viewMatrices[s]);
      let r = 0, n = Fe.z;
      const a = this._shadowCastersBoundingInfo;
      a.update(this._viewMatrices[s]), n = Math.min(n, a.boundingBox.maximumWorld.z), !this._depthClamp || this.filter === G.FILTER_PCSS ? r = Math.min(r, a.boundingBox.minimumWorld.z) : r = Math.max(r, a.boundingBox.minimumWorld.z), x.OrthoOffCenterLHToRef(this._cascadeMinExtents[s].x, this._cascadeMaxExtents[s].x, this._cascadeMinExtents[s].y, this._cascadeMaxExtents[s].y, i ? n : r, i ? r : n, this._projectionMatrices[s], e.getEngine().isNDCHalfZRange), this._cascadeMinExtents[s].z = r, this._cascadeMaxExtents[s].z = n, this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s], this._transformMatrices[s]), p.TransformCoordinatesToRef(Vo, this._transformMatrices[s], Fe), Fe.scaleInPlace(this._mapSize / 2), mi.copyFromFloats(Math.round(Fe.x), Math.round(Fe.y), Math.round(Fe.z)), mi.subtractInPlace(Fe).scaleInPlace(2 / this._mapSize), x.TranslationToRef(mi.x, mi.y, 0, Yi), this._projectionMatrices[s].multiplyToRef(Yi, this._projectionMatrices[s]), this._viewMatrices[s].multiplyToRef(this._projectionMatrices[s], this._transformMatrices[s]), this._transformMatrices[s].copyToArray(this._transformMatricesAsArray, s * 16);
    }
  }
  _computeFrustumInWorldSpace(e) {
    const t = this._getCamera();
    if (!t)
      return;
    const i = this._cascades[e].prevBreakDistance, s = this._cascades[e].breakDistance, r = this._scene.getEngine().isNDCHalfZRange;
    t.getViewMatrix();
    const n = x.Invert(t.getTransformationMatrix()), a = this._scene.getEngine().useReverseDepthBuffer ? 4 : 0;
    for (let o = 0; o < Le._FrustumCornersNDCSpace.length; ++o)
      Fe.copyFrom(Le._FrustumCornersNDCSpace[(o + a) % Le._FrustumCornersNDCSpace.length]), r && Fe.z === -1 && (Fe.z = 0), p.TransformCoordinatesToRef(Fe, n, this._frustumCornersWorldSpace[e][o]);
    for (let o = 0; o < Le._FrustumCornersNDCSpace.length / 2; ++o)
      Fe.copyFrom(this._frustumCornersWorldSpace[e][o + 4]).subtractInPlace(this._frustumCornersWorldSpace[e][o]), mi.copyFrom(Fe).scaleInPlace(i), Fe.scaleInPlace(s), Fe.addInPlace(this._frustumCornersWorldSpace[e][o]), this._frustumCornersWorldSpace[e][o + 4].copyFrom(Fe), this._frustumCornersWorldSpace[e][o].addInPlace(mi);
  }
  _computeCascadeFrustum(e) {
    if (this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE), this._cascadeMaxExtents[e].copyFromFloats(Number.MIN_VALUE, Number.MIN_VALUE, Number.MIN_VALUE), this._frustumCenter[e].copyFromFloats(0, 0, 0), !!this._getCamera()) {
      for (let i = 0; i < this._frustumCornersWorldSpace[e].length; ++i)
        this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][i]);
      if (this._frustumCenter[e].scaleInPlace(1 / this._frustumCornersWorldSpace[e].length), this.stabilizeCascades) {
        let i = 0;
        for (let s = 0; s < this._frustumCornersWorldSpace[e].length; ++s) {
          const r = this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e], Fe).length();
          i = Math.max(i, r);
        }
        i = Math.ceil(i * 16) / 16, this._cascadeMaxExtents[e].copyFromFloats(i, i, i), this._cascadeMinExtents[e].copyFromFloats(-i, -i, -i);
      } else {
        const i = this._frustumCenter[e];
        this._frustumCenter[e].addToRef(this._lightDirection, Fe), x.LookAtLHToRef(i, Fe, mr, Yi);
        for (let s = 0; s < this._frustumCornersWorldSpace[e].length; ++s)
          p.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][s], Yi, Fe), this._cascadeMinExtents[e].minimizeInPlace(Fe), this._cascadeMaxExtents[e].maximizeInPlace(Fe);
      }
    }
  }
  _recreateSceneUBOs() {
    if (this._disposeSceneUBOs(), this._sceneUBOs)
      for (let e = 0; e < this._numCascades; ++e)
        this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`));
  }
  static get IsSupported() {
    const e = fe.LastCreatedEngine;
    return e ? e._features.supportCSM : !1;
  }
  _initializeGenerator() {
    var e, t, i, s, r, n, a, o, h, l, u, d, f, _, E, m, v, S, y, A;
    this.penumbraDarkness = (e = this.penumbraDarkness) !== null && e !== void 0 ? e : 1, this._numCascades = (t = this._numCascades) !== null && t !== void 0 ? t : Le.DEFAULT_CASCADES_COUNT, this.stabilizeCascades = (i = this.stabilizeCascades) !== null && i !== void 0 ? i : !1, this._freezeShadowCastersBoundingInfoObservable = (s = this._freezeShadowCastersBoundingInfoObservable) !== null && s !== void 0 ? s : null, this.freezeShadowCastersBoundingInfo = (r = this.freezeShadowCastersBoundingInfo) !== null && r !== void 0 ? r : !1, this._scbiMin = (n = this._scbiMin) !== null && n !== void 0 ? n : new p(0, 0, 0), this._scbiMax = (a = this._scbiMax) !== null && a !== void 0 ? a : new p(0, 0, 0), this._shadowCastersBoundingInfo = (o = this._shadowCastersBoundingInfo) !== null && o !== void 0 ? o : new ft(new p(0, 0, 0), new p(0, 0, 0)), this._breaksAreDirty = (h = this._breaksAreDirty) !== null && h !== void 0 ? h : !0, this._minDistance = (l = this._minDistance) !== null && l !== void 0 ? l : 0, this._maxDistance = (u = this._maxDistance) !== null && u !== void 0 ? u : 1, this._currentLayer = (d = this._currentLayer) !== null && d !== void 0 ? d : 0, this._shadowMaxZ = (E = (f = this._shadowMaxZ) !== null && f !== void 0 ? f : (_ = this._getCamera()) === null || _ === void 0 ? void 0 : _.maxZ) !== null && E !== void 0 ? E : 1e4, this._debug = (m = this._debug) !== null && m !== void 0 ? m : !1, this._depthClamp = (v = this._depthClamp) !== null && v !== void 0 ? v : !0, this._cascadeBlendPercentage = (S = this._cascadeBlendPercentage) !== null && S !== void 0 ? S : 0.1, this._lambda = (y = this._lambda) !== null && y !== void 0 ? y : 0.5, this._autoCalcDepthBounds = (A = this._autoCalcDepthBounds) !== null && A !== void 0 ? A : !1, this._recreateSceneUBOs(), super._initializeGenerator();
  }
  _createTargetRenderTexture() {
    const e = this._scene.getEngine(), t = { width: this._mapSize, height: this._mapSize, layers: this.numCascades };
    this._shadowMap = new _t(this._light.name + "_CSMShadowMap", t, this._scene, !1, !0, this._textureType, !1, void 0, !1, !1, void 0), this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer ? 516 : 513, !0);
  }
  _initializeShadowMap() {
    if (super._initializeShadowMap(), this._shadowMap === null)
      return;
    this._transformMatricesAsArray = new Float32Array(this._numCascades * 16), this._viewSpaceFrustumsZ = new Array(this._numCascades), this._frustumLengths = new Array(this._numCascades), this._lightSizeUVCorrection = new Array(this._numCascades * 2), this._depthCorrection = new Array(this._numCascades), this._cascades = [], this._viewMatrices = [], this._projectionMatrices = [], this._transformMatrices = [], this._cascadeMinExtents = [], this._cascadeMaxExtents = [], this._frustumCenter = [], this._shadowCameraPos = [], this._frustumCornersWorldSpace = [];
    for (let t = 0; t < this._numCascades; ++t) {
      this._cascades[t] = {
        prevBreakDistance: 0,
        breakDistance: 0
      }, this._viewMatrices[t] = x.Zero(), this._projectionMatrices[t] = x.Zero(), this._transformMatrices[t] = x.Zero(), this._cascadeMinExtents[t] = new p(), this._cascadeMaxExtents[t] = new p(), this._frustumCenter[t] = new p(), this._shadowCameraPos[t] = new p(), this._frustumCornersWorldSpace[t] = new Array(Le._FrustumCornersNDCSpace.length);
      for (let i = 0; i < Le._FrustumCornersNDCSpace.length; ++i)
        this._frustumCornersWorldSpace[t][i] = new p();
    }
    const e = this._scene.getEngine();
    this._shadowMap.onBeforeBindObservable.clear(), this._shadowMap.onBeforeRenderObservable.clear(), this._shadowMap.onBeforeRenderObservable.add((t) => {
      this._sceneUBOs && this._scene.setSceneUniformBuffer(this._sceneUBOs[t]), this._currentLayer = t, this._filter === G.FILTER_PCF && e.setColorWrite(!1), this._scene.setTransformMatrix(this.getCascadeViewMatrix(t), this.getCascadeProjectionMatrix(t)), this._useUBO && (this._scene.getSceneUniformBuffer().unbindEffect(), this._scene.finalizeSceneUbo());
    }), this._shadowMap.onBeforeBindObservable.add(() => {
      var t;
      this._currentSceneUBO = this._scene.getSceneUniformBuffer(), (t = e._debugPushGroup) === null || t === void 0 || t.call(e, `cascaded shadow map generation for pass id ${e.currentRenderPassId}`, 1), this._breaksAreDirty && this._splitFrustum(), this._computeMatrices();
    }), this._splitFrustum();
  }
  _bindCustomEffectForRenderSubMeshForShadowMap(e, t) {
    t.setMatrix("viewProjection", this.getCascadeTransformMatrix(this._currentLayer));
  }
  _isReadyCustomDefines(e) {
    e.push("#define SM_DEPTHCLAMP " + (this._depthClamp && this._filter !== G.FILTER_PCSS ? "1" : "0"));
  }
  prepareDefines(e, t) {
    super.prepareDefines(e, t);
    const i = this._scene, s = this._light;
    if (!i.shadowsEnabled || !s.shadowEnabled)
      return;
    e["SHADOWCSM" + t] = !0, e["SHADOWCSMDEBUG" + t] = this.debug, e["SHADOWCSMNUM_CASCADES" + t] = this.numCascades, e["SHADOWCSM_RIGHTHANDED" + t] = i.useRightHandedSystem;
    const r = this._getCamera();
    r && this._shadowMaxZ < r.maxZ && (e["SHADOWCSMUSESHADOWMAXZ" + t] = !0), this.cascadeBlendPercentage === 0 && (e["SHADOWCSMNOBLEND" + t] = !0);
  }
  bindShadowLight(e, t) {
    const i = this._light;
    if (!this._scene.shadowsEnabled || !i.shadowEnabled)
      return;
    const r = this._getCamera();
    if (!r)
      return;
    const n = this.getShadowMap();
    if (!n)
      return;
    const a = n.getSize().width;
    if (t.setMatrices("lightMatrix" + e, this._transformMatricesAsArray), t.setArray("viewFrustumZ" + e, this._viewSpaceFrustumsZ), t.setFloat("cascadeBlendFactor" + e, this.cascadeBlendPercentage === 0 ? 1e4 : 1 / this.cascadeBlendPercentage), t.setArray("frustumLengths" + e, this._frustumLengths), this._filter === G.FILTER_PCF)
      t.setDepthStencilTexture("shadowSampler" + e, n), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a, 1 / a, this.frustumEdgeFalloff, e);
    else if (this._filter === G.FILTER_PCSS) {
      for (let o = 0; o < this._numCascades; ++o)
        this._lightSizeUVCorrection[o * 2 + 0] = o === 0 ? 1 : (this._cascadeMaxExtents[0].x - this._cascadeMinExtents[0].x) / (this._cascadeMaxExtents[o].x - this._cascadeMinExtents[o].x), this._lightSizeUVCorrection[o * 2 + 1] = o === 0 ? 1 : (this._cascadeMaxExtents[0].y - this._cascadeMinExtents[0].y) / (this._cascadeMaxExtents[o].y - this._cascadeMinExtents[o].y), this._depthCorrection[o] = o === 0 ? 1 : (this._cascadeMaxExtents[o].z - this._cascadeMinExtents[o].z) / (this._cascadeMaxExtents[0].z - this._cascadeMinExtents[0].z);
      t.setDepthStencilTexture("shadowSampler" + e, n), t.setTexture("depthSampler" + e, n), t.setArray2("lightSizeUVCorrection" + e, this._lightSizeUVCorrection), t.setArray("depthCorrection" + e, this._depthCorrection), t.setFloat("penumbraDarkness" + e, this.penumbraDarkness), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), 1 / a, this._contactHardeningLightSizeUVRatio * a, this.frustumEdgeFalloff, e);
    } else
      t.setTexture("shadowSampler" + e, n), i._uniformBuffer.updateFloat4("shadowsInfo", this.getDarkness(), a, 1 / a, this.frustumEdgeFalloff, e);
    i._uniformBuffer.updateFloat2("depthValues", this.getLight().getDepthMinZ(r), this.getLight().getDepthMinZ(r) + this.getLight().getDepthMaxZ(r), e);
  }
  getTransformMatrix() {
    return this.getCascadeTransformMatrix(0);
  }
  dispose() {
    super.dispose(), this._freezeShadowCastersBoundingInfoObservable && (this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable), this._freezeShadowCastersBoundingInfoObservable = null), this._depthReducer && (this._depthReducer.dispose(), this._depthReducer = null);
  }
  serialize() {
    const e = super.serialize(), t = this.getShadowMap();
    if (!t)
      return e;
    if (e.numCascades = this._numCascades, e.debug = this._debug, e.stabilizeCascades = this.stabilizeCascades, e.lambda = this._lambda, e.cascadeBlendPercentage = this.cascadeBlendPercentage, e.depthClamp = this._depthClamp, e.autoCalcDepthBounds = this.autoCalcDepthBounds, e.shadowMaxZ = this._shadowMaxZ, e.penumbraDarkness = this.penumbraDarkness, e.freezeShadowCastersBoundingInfo = this._freezeShadowCastersBoundingInfo, e.minDistance = this.minDistance, e.maxDistance = this.maxDistance, e.renderList = [], t.renderList)
      for (let i = 0; i < t.renderList.length; i++) {
        const s = t.renderList[i];
        e.renderList.push(s.id);
      }
    return e;
  }
  static Parse(e, t) {
    const i = G.Parse(e, t, (s, r, n) => new Le(s, r, void 0, n));
    return e.numCascades !== void 0 && (i.numCascades = e.numCascades), e.debug !== void 0 && (i.debug = e.debug), e.stabilizeCascades !== void 0 && (i.stabilizeCascades = e.stabilizeCascades), e.lambda !== void 0 && (i.lambda = e.lambda), e.cascadeBlendPercentage !== void 0 && (i.cascadeBlendPercentage = e.cascadeBlendPercentage), e.depthClamp !== void 0 && (i.depthClamp = e.depthClamp), e.autoCalcDepthBounds !== void 0 && (i.autoCalcDepthBounds = e.autoCalcDepthBounds), e.shadowMaxZ !== void 0 && (i.shadowMaxZ = e.shadowMaxZ), e.penumbraDarkness !== void 0 && (i.penumbraDarkness = e.penumbraDarkness), e.freezeShadowCastersBoundingInfo !== void 0 && (i.freezeShadowCastersBoundingInfo = e.freezeShadowCastersBoundingInfo), e.minDistance !== void 0 && e.maxDistance !== void 0 && i.setMinMaxDistance(e.minDistance, e.maxDistance), i;
  }
}
Le._FrustumCornersNDCSpace = [
  new p(-1, 1, -1),
  new p(1, 1, -1),
  new p(1, -1, -1),
  new p(-1, -1, -1),
  new p(-1, 1, 1),
  new p(1, 1, 1),
  new p(1, -1, 1),
  new p(-1, -1, 1)
];
Le.CLASSNAME = "CascadedShadowGenerator";
Le.DEFAULT_CASCADES_COUNT = 4;
Le.MIN_CASCADES_COUNT = 2;
Le.MAX_CASCADES_COUNT = 4;
Le._SceneComponentInitialization = (c) => {
  throw Q("ShadowGeneratorSceneComponent");
};
as.AddParser(Z.NAME_SHADOWGENERATOR, (c, e) => {
  if (c.shadowGenerators !== void 0 && c.shadowGenerators !== null)
    for (let t = 0, i = c.shadowGenerators.length; t < i; t++) {
      const s = c.shadowGenerators[t];
      s.className === Le.CLASSNAME ? Le.Parse(s, e) : G.Parse(s, e);
    }
});
class Wo {
  constructor(e) {
    this.name = Z.NAME_SHADOWGENERATOR, this.scene = e;
  }
  register() {
    this.scene._gatherRenderTargetsStage.registerStep(Z.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR, this, this._gatherRenderTargets);
  }
  rebuild() {
  }
  serialize(e) {
    e.shadowGenerators = [];
    const t = this.scene.lights;
    for (const i of t) {
      const s = i.getShadowGenerators();
      if (s) {
        const r = s.values();
        for (let n = r.next(); n.done !== !0; n = r.next()) {
          const a = n.value;
          e.shadowGenerators.push(a.serialize());
        }
      }
    }
  }
  addFromContainer(e) {
  }
  removeFromContainer(e, t) {
  }
  dispose() {
  }
  _gatherRenderTargets(e) {
    const t = this.scene;
    if (this.scene.shadowsEnabled)
      for (let i = 0; i < t.lights.length; i++) {
        const s = t.lights[i], r = s.getShadowGenerators();
        if (s.isEnabled() && s.shadowEnabled && r) {
          const n = r.values();
          for (let a = n.next(); a.done !== !0; a = n.next()) {
            const h = a.value.getShadowMap();
            t.textures.indexOf(h) !== -1 && e.push(h);
          }
        }
      }
  }
}
G._SceneComponentInitialization = (c) => {
  let e = c._getComponent(Z.NAME_SHADOWGENERATOR);
  e || (e = new Wo(c), c._addComponent(e));
};
const zo = {
  enableShadows: !0
};
function Er(c = zo) {
  const { enableShadows: e, shadowTransparency: t, intensity: i, scene: s } = c, r = new Pt("DirectionalLight", new p(-0.3, -1, 0.4), s);
  r.position = new p(-50, 65, -50), r.intensity = 0.65 * i;
  const n = new us("HemisphericLight", new p(1, 1, 0), s);
  return n.intensity = 0.4 * i, e && (r.shadowMinZ = 1, r.shadowMaxZ = 70, r.shadowGenerator = new G(2048, r), r.shadowGenerator.useCloseExponentialShadowMap = !0, r.shadowGenerator.darkness = t), { directional: r, hemispheric: n };
}
function Vr(c) {
  let t = [0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18, 16, 18, 19, 20, 21, 22, 20, 22, 23];
  const i = [
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0,
    0,
    -1,
    0
  ], s = [];
  let r = [];
  const n = c.width || c.size || 1, a = c.height || c.size || 1, o = c.depth || c.size || 1, h = c.wrap || !1;
  let l = c.topBaseAt === void 0 ? 1 : c.topBaseAt, u = c.bottomBaseAt === void 0 ? 0 : c.bottomBaseAt;
  l = (l + 4) % 4, u = (u + 4) % 4;
  const d = [2, 0, 3, 1], f = [2, 0, 1, 3];
  let _ = d[l], E = f[u], m = [
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    -1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    1,
    -1,
    -1,
    -1,
    -1,
    1,
    -1,
    -1,
    1,
    1,
    -1,
    1,
    -1,
    1,
    1,
    -1,
    1,
    1,
    1,
    1,
    -1,
    1,
    1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    1
  ];
  if (h) {
    t = [2, 3, 0, 2, 0, 1, 4, 5, 6, 4, 6, 7, 9, 10, 11, 9, 11, 8, 12, 14, 15, 12, 13, 14], m = [
      -1,
      1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      -1,
      -1
    ];
    let M = [
      [1, 1, 1],
      [-1, 1, 1],
      [-1, 1, -1],
      [1, 1, -1]
    ], L = [
      [-1, -1, 1],
      [1, -1, 1],
      [1, -1, -1],
      [-1, -1, -1]
    ];
    const k = [17, 18, 19, 16], F = [22, 23, 20, 21];
    for (; _ > 0; )
      M.unshift(M.pop()), k.unshift(k.pop()), _--;
    for (; E > 0; )
      L.unshift(L.pop()), F.unshift(F.pop()), E--;
    M = M.flat(), L = L.flat(), m = m.concat(M).concat(L), t.push(k[0], k[2], k[3], k[0], k[1], k[2]), t.push(F[0], F[2], F[3], F[0], F[1], F[2]);
  }
  const v = [n / 2, a / 2, o / 2];
  r = m.reduce((M, L, k) => M.concat(L * v[k % 3]), []);
  const S = c.sideOrientation === 0 ? 0 : c.sideOrientation || J.DEFAULTSIDE, y = c.faceUV || new Array(6), A = c.faceColors, C = [];
  for (let M = 0; M < 6; M++)
    y[M] === void 0 && (y[M] = new Ae(0, 0, 1, 1)), A && A[M] === void 0 && (A[M] = new ge(1, 1, 1, 1));
  for (let M = 0; M < 6; M++)
    if (s.push(y[M].z, ut.UseOpenGLOrientationForUV ? 1 - y[M].w : y[M].w), s.push(y[M].x, ut.UseOpenGLOrientationForUV ? 1 - y[M].w : y[M].w), s.push(y[M].x, ut.UseOpenGLOrientationForUV ? 1 - y[M].y : y[M].y), s.push(y[M].z, ut.UseOpenGLOrientationForUV ? 1 - y[M].y : y[M].y), A)
      for (let L = 0; L < 4; L++)
        C.push(A[M].r, A[M].g, A[M].b, A[M].a);
  J._ComputeSides(S, r, t, i, s, c.frontUVs, c.backUVs);
  const b = new J();
  if (b.indices = t, b.positions = r, b.normals = i, b.uvs = s, A) {
    const M = S === J.DOUBLESIDE ? C.concat(C) : C;
    b.colors = M;
  }
  return b;
}
function Ei(c, e = {}, t = null) {
  const i = new W(c, t);
  return e.sideOrientation = W._GetDefaultSideOrientation(e.sideOrientation), i._originalBuilderSideOrientation = e.sideOrientation, Vr(e).applyToMesh(i, e.updatable), i;
}
J.CreateBox = Vr;
W.CreateBox = (c, e, t = null, i, s) => Ei(c, {
  size: e,
  sideOrientation: s,
  updatable: i
}, t);
class vr {
  constructor() {
    this.previousWorldMatrices = {}, this.previousBones = {};
  }
  static AddUniforms(e) {
    e.push("previousWorld", "previousViewProjection", "mPreviousBones");
  }
  static AddSamplers(e) {
  }
  bindForSubMesh(e, t, i, s, r) {
    if (t.prePassRenderer && t.prePassRenderer.enabled && t.prePassRenderer.currentRTisSceneRT && t.prePassRenderer.getIndex(2) !== -1) {
      this.previousWorldMatrices[i.uniqueId] || (this.previousWorldMatrices[i.uniqueId] = s.clone()), this.previousViewProjection || (this.previousViewProjection = t.getTransformMatrix().clone(), this.currentViewProjection = t.getTransformMatrix().clone());
      const n = t.getEngine();
      this.currentViewProjection.updateFlag !== t.getTransformMatrix().updateFlag ? (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection), this.currentViewProjection.copyFrom(t.getTransformMatrix())) : this._lastUpdateFrameId !== n.frameId && (this._lastUpdateFrameId = n.frameId, this.previousViewProjection.copyFrom(this.currentViewProjection)), e.setMatrix("previousWorld", this.previousWorldMatrices[i.uniqueId]), e.setMatrix("previousViewProjection", this.previousViewProjection), this.previousWorldMatrices[i.uniqueId] = s.clone();
    }
  }
}
class Wr extends P {
  constructor(e, t, i = !0) {
    super(e, t), this._normalMatrix = new x(), this._storeEffectOnSubMeshes = i;
  }
  getEffect() {
    return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();
  }
  isReady(e, t) {
    return e ? !this._storeEffectOnSubMeshes || !e.subMeshes || e.subMeshes.length === 0 ? !0 : this.isReadyForSubMesh(e, e.subMeshes[0], t) : !1;
  }
  _isReadyForSubMesh(e) {
    const t = e.materialDefines;
    return !!(!this.checkReadyOnEveryCall && e.effect && t && t._renderId === this.getScene().getRenderId());
  }
  bindOnlyWorldMatrix(e) {
    this._activeEffect.setMatrix("world", e);
  }
  bindOnlyNormalMatrix(e) {
    this._activeEffect.setMatrix("normalMatrix", e);
  }
  bind(e, t) {
    !t || this.bindForSubMesh(e, t, t.subMeshes[0]);
  }
  _afterBind(e, t = null) {
    super._afterBind(e, t), this.getScene()._cachedEffect = t, t && (t._forceRebindOnNextCall = !1);
  }
  _mustRebind(e, t, i = 1) {
    return e.isCachedMaterialInvalid(this, t, i);
  }
}
class de {
  static get DiffuseTextureEnabled() {
    return this._DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(e) {
    this._DiffuseTextureEnabled !== e && (this._DiffuseTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get DetailTextureEnabled() {
    return this._DetailTextureEnabled;
  }
  static set DetailTextureEnabled(e) {
    this._DetailTextureEnabled !== e && (this._DetailTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get AmbientTextureEnabled() {
    return this._AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(e) {
    this._AmbientTextureEnabled !== e && (this._AmbientTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get OpacityTextureEnabled() {
    return this._OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(e) {
    this._OpacityTextureEnabled !== e && (this._OpacityTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get ReflectionTextureEnabled() {
    return this._ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(e) {
    this._ReflectionTextureEnabled !== e && (this._ReflectionTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get EmissiveTextureEnabled() {
    return this._EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(e) {
    this._EmissiveTextureEnabled !== e && (this._EmissiveTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get SpecularTextureEnabled() {
    return this._SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(e) {
    this._SpecularTextureEnabled !== e && (this._SpecularTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get BumpTextureEnabled() {
    return this._BumpTextureEnabled;
  }
  static set BumpTextureEnabled(e) {
    this._BumpTextureEnabled !== e && (this._BumpTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get LightmapTextureEnabled() {
    return this._LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(e) {
    this._LightmapTextureEnabled !== e && (this._LightmapTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get RefractionTextureEnabled() {
    return this._RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(e) {
    this._RefractionTextureEnabled !== e && (this._RefractionTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get ColorGradingTextureEnabled() {
    return this._ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(e) {
    this._ColorGradingTextureEnabled !== e && (this._ColorGradingTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get FresnelEnabled() {
    return this._FresnelEnabled;
  }
  static set FresnelEnabled(e) {
    this._FresnelEnabled !== e && (this._FresnelEnabled = e, I.MarkAllMaterialsAsDirty(4));
  }
  static get ClearCoatTextureEnabled() {
    return this._ClearCoatTextureEnabled;
  }
  static set ClearCoatTextureEnabled(e) {
    this._ClearCoatTextureEnabled !== e && (this._ClearCoatTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get ClearCoatBumpTextureEnabled() {
    return this._ClearCoatBumpTextureEnabled;
  }
  static set ClearCoatBumpTextureEnabled(e) {
    this._ClearCoatBumpTextureEnabled !== e && (this._ClearCoatBumpTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get ClearCoatTintTextureEnabled() {
    return this._ClearCoatTintTextureEnabled;
  }
  static set ClearCoatTintTextureEnabled(e) {
    this._ClearCoatTintTextureEnabled !== e && (this._ClearCoatTintTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get SheenTextureEnabled() {
    return this._SheenTextureEnabled;
  }
  static set SheenTextureEnabled(e) {
    this._SheenTextureEnabled !== e && (this._SheenTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get AnisotropicTextureEnabled() {
    return this._AnisotropicTextureEnabled;
  }
  static set AnisotropicTextureEnabled(e) {
    this._AnisotropicTextureEnabled !== e && (this._AnisotropicTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get ThicknessTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set ThicknessTextureEnabled(e) {
    this._ThicknessTextureEnabled !== e && (this._ThicknessTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get RefractionIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set RefractionIntensityTextureEnabled(e) {
    this._RefractionIntensityTextureEnabled !== e && (this._RefractionIntensityTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get TranslucencyIntensityTextureEnabled() {
    return this._ThicknessTextureEnabled;
  }
  static set TranslucencyIntensityTextureEnabled(e) {
    this._TranslucencyIntensityTextureEnabled !== e && (this._TranslucencyIntensityTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
  static get IridescenceTextureEnabled() {
    return this._IridescenceTextureEnabled;
  }
  static set IridescenceTextureEnabled(e) {
    this._IridescenceTextureEnabled !== e && (this._IridescenceTextureEnabled = e, I.MarkAllMaterialsAsDirty(1));
  }
}
de._DiffuseTextureEnabled = !0;
de._DetailTextureEnabled = !0;
de._AmbientTextureEnabled = !0;
de._OpacityTextureEnabled = !0;
de._ReflectionTextureEnabled = !0;
de._EmissiveTextureEnabled = !0;
de._SpecularTextureEnabled = !0;
de._BumpTextureEnabled = !0;
de._LightmapTextureEnabled = !0;
de._RefractionTextureEnabled = !0;
de._ColorGradingTextureEnabled = !0;
de._FresnelEnabled = !0;
de._ClearCoatTextureEnabled = !0;
de._ClearCoatBumpTextureEnabled = !0;
de._ClearCoatTintTextureEnabled = !0;
de._SheenTextureEnabled = !0;
de._AnisotropicTextureEnabled = !0;
de._ThicknessTextureEnabled = !0;
de._RefractionIntensityTextureEnabled = !0;
de._TranslucencyIntensityTextureEnabled = !0;
de._IridescenceTextureEnabled = !0;
const Go = "defaultFragmentDeclaration", Xo = `uniform vec4 vEyePosition;
uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;
uniform vec3 vAmbientColor;
uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;
uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;
uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;
uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;
uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;
uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;
uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
U.IncludesShadersStore[Go] = Xo;
const Ho = "defaultUboDeclaration", Ko = `layout(std140,column_major) uniform;
uniform Material
{
vec4 diffuseLeftColor;
vec4 diffuseRightColor;
vec4 opacityParts;
vec4 reflectionLeftColor;
vec4 reflectionRightColor;
vec4 refractionLeftColor;
vec4 refractionRightColor;
vec4 emissiveLeftColor;
vec4 emissiveRightColor;
vec2 vDiffuseInfos;
vec2 vAmbientInfos;
vec2 vOpacityInfos;
vec2 vReflectionInfos;
vec3 vReflectionPosition;
vec3 vReflectionSize;
vec2 vEmissiveInfos;
vec2 vLightmapInfos;
vec2 vSpecularInfos;
vec3 vBumpInfos;
mat4 diffuseMatrix;
mat4 ambientMatrix;
mat4 opacityMatrix;
mat4 reflectionMatrix;
mat4 emissiveMatrix;
mat4 lightmapMatrix;
mat4 specularMatrix;
mat4 bumpMatrix;
vec2 vTangentSpaceParams;
float pointSize;
float alphaCutOff;
mat4 refractionMatrix;
vec4 vRefractionInfos;
vec3 vRefractionPosition;
vec3 vRefractionSize;
vec4 vSpecularColor;
vec3 vEmissiveColor;
vec4 vDiffuseColor;
vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
U.IncludesShadersStore[Ho] = Ko;
const Yo = "prePassDeclaration", Zo = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
U.IncludesShadersStore[Yo] = Zo;
const qo = "oitDeclaration", jo = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;
layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;
uniform sampler2D oitDepthSampler;
uniform sampler2D oitFrontColorSampler;
#endif
`;
U.IncludesShadersStore[qo] = jo;
const Qo = "mainUVVaryingDeclaration", $o = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
U.IncludesShadersStore[Qo] = $o;
const Jo = "lightFragmentDeclaration", eh = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;
U.IncludesShadersStore[Jo] = eh;
const th = "lightUboDeclaration", ih = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};
uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float cascadeBlendFactor{X};
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
uniform highp sampler2DArray depthSampler{X};
uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];
uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);
vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};
uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
U.IncludesShadersStore[th] = ih;
const sh = "lightsFragmentFunctions", rh = `struct lightingInfo
{
vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};
lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 lightVectorW;
float attenuation=1.0;
if (lightData.w==0.)
{
vec3 direction=lightData.xyz-vPositionW;
attenuation=max(0.,1.0-length(direction)/range);
lightVectorW=normalize(direction);
}
else
{
lightVectorW=normalize(-lightData.xyz);
}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {
lightingInfo result;
vec3 direction=lightData.xyz-vPositionW;
vec3 lightVectorW=normalize(direction);
float attenuation=max(0.,1.0-length(direction)/range);
float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));
if (cosAngle>=lightDirection.w)
{
cosAngle=max(0.,pow(cosAngle,lightData.w));
attenuation*=cosAngle;
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor*attenuation;
#endif
return result;
}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;
}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {
lightingInfo result;
float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);
float specComp=max(0.,dot(vNormal,angleW));
specComp=pow(specComp,max(1.,glossiness));
result.specular=specComp*specularColor;
#endif
return result;
}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){
vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);
strq/=strq.w;
vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;
return textureColor;
}`;
U.IncludesShadersStore[sh] = rh;
const nh = "shadowsFragmentFunctions", ah = `#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{
const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);
return dot(color,bit_shift);
}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{
float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));
return mix(value,1.0,mask);
}
#define inline
float computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;
}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
depth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
float visibility=1.;
vec3 poissonDisk[4];
poissonDisk[0]=vec3(-1.0,1.0,-1.0);
poissonDisk[1]=vec3(1.0,-1.0,-1.0);
poissonDisk[2]=vec3(-1.0,-1.0,-1.0);
poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;
if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);
}
#define inline
float computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); 
return esm;
}
#define inline
float computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{
vec3 directionToLight=vPositionW-lightPosition;
float depth=length(directionToLight);
depth=(depth+depthValues.x)/(depthValues.y);
float shadowPixelDepth=clamp(depth,0.,1.0);
directionToLight=normalize(directionToLight);
directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return esm;
}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
vec3 uvLayer=vec3(uv.x,uv.y,layer);
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;
}
}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
float visibility=1.;
vec2 poissonDisk[4];
poissonDisk[0]=vec2(-0.94201624,-0.39906216);
poissonDisk[1]=vec2(0.94558609,-0.76890725);
poissonDisk[2]=vec2(-0.094184101,-0.92938870);
poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec2 uv=0.5*clipSpace.xy+vec2(0.5);
if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{
return 1.0;
}
else
{
float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);
return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);
}
}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float shadow=texture2D(shadowSampler,uvDepthLayer);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));
shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));
shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));
shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));
shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));
shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));
shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));
shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));
shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;
vec2 uvw1=1.+2.*st;
vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;
vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);
shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);
shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);
shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);
shadow=shadow/16.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;
vec2 uvw1=vec2(7.);
vec2 uvw2=1.+3.*st;
vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;
vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;
float shadow=0.;
shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);
shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);
shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);
shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);
shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);
shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);
shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);
shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);
shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);
shadow=shadow/144.;
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.)
);
const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);
vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);
vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec4 offset=vec4(poissonSamplers[i],0.);
offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);
shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));
shadow=mix(darkness,1.,shadow);
if (numBlocker<1.0) {
return 1.0;
}
else
{
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{
if (depthMetric>1.0 || depthMetric<0.0) {
return 1.0;
}
else
{
vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;
vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));
uvDepth.z=ZINCLIP;
float blockerDepth=0.0;
float sumBlockerDepth=0.0;
float numBlocker=0.0;
for (int i=0; i<searchTapCount; i ++) {
blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;
if (blockerDepth<depthMetric) {
sumBlockerDepth+=blockerDepth;
numBlocker++;
}
}
if (numBlocker<1.0) {
return 1.0;
}
else
{
float avgBlockerDepth=sumBlockerDepth/numBlocker;
float AAOffset=shadowMapSizeInverse*10.;
float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);
float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;
float random=getRand(vPositionFromLight.xy);
float rotationAngle=random*3.1415926;
vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));
float shadow=0.;
for (int i=0; i<pcfTapCount; i++) {
vec3 offset=poissonSamplers[i];
offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);
shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);
}
shadow/=float(pcfTapCount);
shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);
shadow=mix(darkness,1.,shadow);
return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);
}
}
}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);
}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{
return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);
}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{
return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);
}
#endif
#endif
`;
U.IncludesShadersStore[nh] = ah;
const oh = "samplerFragmentDeclaration", hh = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
U.IncludesShadersStore[oh] = hh;
const lh = "fresnelFunction", ch = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{
float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);
return clamp(fresnelTerm,0.,1.);
}
#endif
`;
U.IncludesShadersStore[lh] = ch;
const uh = "reflectionFunction", dh = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0); 
}
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{
float lon=atan(direction.z,direction.x);
float lat=acos(direction.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(1.0-s,t,0); 
}
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);
vec3 r=normalize(reflect(cameraToVertex,worldNormal));
r=vec3(reflectionMatrix*vec4(r,0));
float lon=atan(r.z,r.x);
float lat=acos(r.y);
vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;
float s=sphereCoords.x*0.5+0.5;
float t=sphereCoords.y;
return vec3(s,t,0);
}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(vec3(view*worldPos));
vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));
vec3 r=reflect(viewDir,viewNormal);
r=vec3(reflectionMatrix*vec4(r,0));
r.z=r.z-1.0;
float m=2.0*length(r);
return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);
}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=worldPos.xyz-eyePosition;
vec3 coords=normalize(reflect(viewDir,worldNormal));
return vec3(reflectionMatrix*vec4(coords,1));
}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{
vec3 viewDir=normalize(worldPos.xyz-eyePosition);
vec3 coords=reflect(viewDir,worldNormal);
coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);
coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;
}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*(view*worldPos));
}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{
return vec3(reflectionMatrix*vec4(positionW,1.));
}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);
return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
U.IncludesShadersStore[uh] = dh;
const fh = "imageProcessingDeclaration", _h = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;
uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;
uniform vec4 vCameraColorCurveNeutral;
uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;
U.IncludesShadersStore[fh] = _h;
const gh = "imageProcessingFunctions", ph = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{
float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);
float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;
sliceUV.x+=sliceInteger*sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice0Color=texture2D(colorTransform,sliceUV);
sliceUV.x+=sliceSize;
sliceUV=saturate(sliceUV);
vec4 slice1Color=texture2D(colorTransform,sliceUV);
vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;
}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);
const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);
vec3 RRTAndODTFit(vec3 v)
{
vec3 a=v*(v+0.0245786)-0.000090537;
vec3 b=v*(0.983729*v+0.4329510)+0.238081;
return a/b;
}
vec3 ACESFitted(vec3 color)
{
color=ACESInputMat*color;
color=RRTAndODTFit(color);
color=ACESOutputMat*color;
color=saturate(color);
return color;
}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;
viewportXY=viewportXY*2.0-1.0;
vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);
float vignetteTerm=dot(vignetteXY1,vignetteXY1);
float vignette=pow(vignetteTerm,vignetteSettings2.w);
vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);
result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;
result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);
result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);
if (contrast<1.0) {
result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);
} else {
result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);
}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);
vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));
vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;
result.rgb*=colorCurve.rgb;
result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);
float dither=mix(-ditherIntensity,ditherIntensity,rand);
result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;
}`;
U.IncludesShadersStore[gh] = ph;
const mh = "bumpFragmentMainFunctions", Eh = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);
}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{
return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);
}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{
vec3 dp1=dFdx(p);
vec3 dp2=dFdy(p);
vec2 duv1=dFdx(uv);
vec2 duv2=dFdy(uv);
vec3 dp2perp=cross(dp2,normal);
vec3 dp1perp=cross(normal,dp1);
vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;
vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;
tangent*=tangentSpaceParams.x;
bitangent*=tangentSpaceParams.y;
float det=max(dot(tangent,tangent),dot(bitangent,bitangent));
float invmax=det==0.0 ? 0.0 : inversesqrt(det);
return mat3(tangent*invmax,bitangent*invmax,normal);
}
#endif
`;
U.IncludesShadersStore[mh] = Eh;
const vh = "bumpFragmentFunctions", Th = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;
const float maxSamples=15.;
const int iMaxSamples=15;
vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {
float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;
parallaxLimit*=parallaxScale;
vec2 vOffsetDir=normalize(vViewDirCoT.xy);
vec2 vMaxOffset=vOffsetDir*parallaxLimit;
float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));
float stepSize=1.0/numSamples;
float currRayHeight=1.0;
vec2 vCurrOffset=vec2(0,0);
vec2 vLastOffset=vec2(0,0);
float lastSampledHeight=1.0;
float currSampledHeight=1.0;
bool keepWorking=true;
for (int i=0; i<iMaxSamples; i++)
{
currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;
if (!keepWorking)
{
}
else if (currSampledHeight>currRayHeight)
{
float delta1=currSampledHeight-currRayHeight;
float delta2=(currRayHeight+stepSize)-lastSampledHeight;
float ratio=delta1/(delta1+delta2);
vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;
keepWorking=false;
}
else
{
currRayHeight-=stepSize;
vLastOffset=vCurrOffset;
vCurrOffset+=stepSize*vMaxOffset;
lastSampledHeight=currSampledHeight;
}
}
return vCurrOffset;
}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{
float height=texture2D(bumpSampler,vBumpUV).w;
vec2 texCoordOffset=heightScale*viewDir.xy*height;
return -texCoordOffset;
}
#endif
`;
U.IncludesShadersStore[vh] = Th;
const bh = "logDepthDeclaration", Sh = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;
varying float vFragmentDepth;
#endif
`;
U.IncludesShadersStore[bh] = Sh;
const xh = "fogFragmentDeclaration", Mh = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;
uniform vec3 vFogColor;
varying vec3 vFogDistance;
float CalcFogFactor()
{
float fogCoeff=1.0;
float fogStart=vFogInfos.y;
float fogEnd=vFogInfos.z;
float fogDensity=vFogInfos.w;
float fogDistance=length(vFogDistance);
if (FOGMODE_LINEAR==vFogInfos.x)
{
fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);
}
else if (FOGMODE_EXP==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDensity);
}
else if (FOGMODE_EXP2==vFogInfos.x)
{
fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);
}
return clamp(fogCoeff,0.0,1.0);
}
#endif
`;
U.IncludesShadersStore[xh] = Mh;
const Ah = "bumpFragment", Rh = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;
mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;
mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);
vec2 detailNormalRG=detailColor.wy*2.0-1.0;
float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));
vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);
normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;
vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;
bumpNormal+=vec3(0.0,0.0,1.0);
detailNormal*=vec3(-1.0,-1.0,1.0);
vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;
normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
U.IncludesShadersStore[Ah] = Rh;
const yh = "depthPrePass", Ch = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);
return;
#endif
`;
U.IncludesShadersStore[yh] = Ch;
const Ih = "lightFragment", Ph = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);
info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {
index{X}=i;
break;
}
}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];
float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};
if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{
index{X}+=1;
float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;
shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
U.IncludesShadersStore[Ih] = Ph;
const Dh = "logDepthFragment", Fh = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;
U.IncludesShadersStore[Dh] = Fh;
const wh = "fogFragment", Oh = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;
U.IncludesShadersStore[wh] = Oh;
const Lh = "oitFragment", Nh = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));
vec2 full=unpackHalf2x16(halfFloat);
fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);
vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;
vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);
depth.rg=vec2(-MAX_DEPTH);
frontColor=lastFrontColor;
backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;
float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;
float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;
}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);
return;
}
#endif
`;
U.IncludesShadersStore[Lh] = Nh;
const Bh = "defaultPixelShader", Uh = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#define RECIPROCAL_PI2 0.15915494
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
vec4 baseColor=vec4(1.,1.,1.,1.);
vec3 diffuseColor=vDiffuseColor.rgb;
float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;
vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);
specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;
if (dot(refractionVector,viewDirectionW)<1.0) {
refractionColor=textureCube(refractionCubeSampler,refractionVector);
}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;
refractionCoords.y=1.0-refractionCoords.y;
refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;
reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);
refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);
alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);
alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);
emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);
diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);
color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;
gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;
vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;
vec2 velocity=abs(a-b);
velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;
gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
gl_FragData[PREPASS_NORMAL_INDEX]=vec4((view*vec4(normalW,0.0)).rgb,writeGeometryInfo); 
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularMapColor)*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularColor,1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {
frontColor.rgb+=color.rgb*color.a*alphaMultiplier;
frontColor.a=1.0-alphaMultiplier*(1.0-color.a);
} else {
backColor+=color;
}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
U.ShadersStore[Bh] = Uh;
const kh = "defaultVertexDeclaration", Vh = `uniform mat4 viewProjection;
uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;
uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
uniform mat4 detailMatrix;
#endif
#define ADDITIONAL_VERTEX_DECLARATION
`;
U.IncludesShadersStore[kh] = Vh;
const Wh = "uvAttributeDeclaration", zh = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
U.IncludesShadersStore[Wh] = zh;
const Gh = "prePassVertexDeclaration", Xh = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;
varying vec4 vCurrentPosition;
varying vec4 vPreviousPosition;
#endif
#endif
`;
U.IncludesShadersStore[Gh] = Xh;
const Hh = "samplerVertexDeclaration", Kh = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
U.IncludesShadersStore[Hh] = Kh;
const Yh = "bumpVertexDeclaration", Zh = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
U.IncludesShadersStore[Yh] = Zh;
const qh = "fogVertexDeclaration", jh = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`;
U.IncludesShadersStore[qh] = jh;
const Qh = "lightVxFragmentDeclaration", $h = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};
uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};
uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};
uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
U.IncludesShadersStore[Qh] = $h;
const Jh = "lightVxUboDeclaration", el = `#ifdef LIGHT{X}
uniform Light{X}
{
vec4 vLightData;
vec4 vLightDiffuse;
vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;
vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;
vec2 depthValues;
} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];
varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];
varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};
varying float vDepthMetric{X};
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
U.IncludesShadersStore[Jh] = el;
const tl = "prePassVertex", il = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;
previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
U.IncludesShadersStore[tl] = il;
const sl = "uvVariableDeclaration", rl = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
U.IncludesShadersStore[sl] = rl;
const nl = "samplerVertexImplementation", al = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));
}
#ifdef UV2
else if (v_INFONAME_==1.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));
}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));
}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));
}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));
}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{
v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));
}
#endif
#endif
`;
U.IncludesShadersStore[nl] = al;
const ol = "bumpVertex", hl = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);
vec3 tbnTangent=normalize(tangentUpdated.xyz);
vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;
vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
U.IncludesShadersStore[ol] = hl;
const ll = "fogVertex", cl = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;
U.IncludesShadersStore[ll] = cl;
const ul = "shadowsVertex", dl = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {
vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
U.IncludesShadersStore[ul] = dl;
const fl = "vertexColorMixing", _l = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
U.IncludesShadersStore[fl] = _l;
const gl = "pointCloudVertex", pl = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;
U.IncludesShadersStore[gl] = pl;
const ml = "logDepthVertex", El = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;
gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;
U.IncludesShadersStore[ml] = El;
const vl = "defaultVertexShader", Tl = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));
vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {
gl_Position=viewProjection*worldPos;
} else {
gl_Position=viewProjectionR*worldPos;
}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
U.ShadersStore[vl] = Tl;
const bl = new RegExp("^([gimus]+)!");
class qt {
  constructor(e) {
    this._plugins = [], this._activePlugins = [], this._activePluginsForExtraEvents = [], this._material = e, this._scene = e.getScene(), this._engine = this._scene.getEngine();
  }
  _addPlugin(e) {
    for (let s = 0; s < this._plugins.length; ++s)
      if (this._plugins[s].name === e.name)
        throw `Plugin "${e.name}" already added to the material "${this._material.name}"!`;
    if (this._material._uniformBufferLayoutBuilt)
      throw `The plugin "${e.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
    const t = e.getClassName();
    qt._MaterialPluginClassToMainDefine[t] || (qt._MaterialPluginClassToMainDefine[t] = "MATERIALPLUGIN_" + ++qt._MaterialPluginCounter), this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this), this._plugins.push(e), this._plugins.sort((s, r) => s.priority - r.priority), this._codeInjectionPoints = {};
    const i = {};
    i[qt._MaterialPluginClassToMainDefine[t]] = {
      type: "boolean",
      default: !0
    };
    for (const s of this._plugins)
      s.collectDefines(i), this._collectPointNames("vertex", s.getCustomCode("vertex")), this._collectPointNames("fragment", s.getCustomCode("fragment"));
    this._defineNamesFromPlugins = i;
  }
  _activatePlugin(e) {
    this._activePlugins.indexOf(e) === -1 && (this._activePlugins.push(e), this._activePlugins.sort((t, i) => t.priority - i.priority), this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this), this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this), this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this), this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this), e.registerForExtraEvents && (this._activePluginsForExtraEvents.push(e), this._activePluginsForExtraEvents.sort((t, i) => t.priority - i.priority), this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this), this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this), this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this)));
  }
  getPlugin(e) {
    for (let t = 0; t < this._plugins.length; ++t)
      if (this._plugins[t].name === e)
        return this._plugins[t];
    return null;
  }
  _handlePluginEventIsReadyForSubMesh(e) {
    let t = !0;
    for (const i of this._activePlugins)
      t = t && i.isReadyForSubMesh(e.defines, this._scene, this._engine, e.subMesh);
    e.isReadyForSubMesh = t;
  }
  _handlePluginEventPrepareDefinesBeforeAttributes(e) {
    for (const t of this._activePlugins)
      t.prepareDefinesBeforeAttributes(e.defines, this._scene, e.mesh);
  }
  _handlePluginEventPrepareDefines(e) {
    for (const t of this._activePlugins)
      t.prepareDefines(e.defines, this._scene, e.mesh);
  }
  _handlePluginEventHardBindForSubMesh(e) {
    for (const t of this._activePluginsForExtraEvents)
      t.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh);
  }
  _handlePluginEventBindForSubMesh(e) {
    for (const t of this._activePlugins)
      t.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, e.subMesh);
  }
  _handlePluginEventHasRenderTargetTextures(e) {
    let t = !1;
    for (const i of this._activePluginsForExtraEvents)
      if (t = i.hasRenderTargetTextures(), t)
        break;
    e.hasRenderTargetTextures = t;
  }
  _handlePluginEventFillRenderTargetTextures(e) {
    for (const t of this._activePluginsForExtraEvents)
      t.fillRenderTargetTextures(e.renderTargets);
  }
  _handlePluginEvent(e, t) {
    switch (e) {
      case je.GetActiveTextures: {
        const i = t;
        for (const s of this._activePlugins)
          s.getActiveTextures(i.activeTextures);
        break;
      }
      case je.GetAnimatables: {
        const i = t;
        for (const s of this._activePlugins)
          s.getAnimatables(i.animatables);
        break;
      }
      case je.HasTexture: {
        const i = t;
        let s = !1;
        for (const r of this._activePlugins)
          if (s = r.hasTexture(i.texture), s)
            break;
        i.hasTexture = s;
        break;
      }
      case je.Disposed: {
        const i = t;
        for (const s of this._plugins)
          s.dispose(i.forceDisposeTextures);
        break;
      }
      case je.GetDefineNames: {
        const i = t;
        i.defineNames = this._defineNamesFromPlugins;
        break;
      }
      case je.PrepareEffect: {
        const i = t;
        for (const s of this._activePlugins)
          i.fallbackRank = s.addFallbacks(i.defines, i.fallbacks, i.fallbackRank), s.getAttributes(i.attributes, this._scene, i.mesh);
        this._uniformList.length > 0 && i.uniforms.push(...this._uniformList), this._samplerList.length > 0 && i.samplers.push(...this._samplerList), this._uboList.length > 0 && i.uniformBuffersNames.push(...this._uboList), i.customCode = this._injectCustomCode(i.customCode);
        break;
      }
      case je.PrepareUniformBuffer: {
        const i = t;
        this._uboDeclaration = "", this._vertexDeclaration = "", this._fragmentDeclaration = "", this._uniformList = [], this._samplerList = [], this._uboList = [];
        for (const s of this._plugins) {
          const r = s.getUniforms();
          if (r) {
            if (r.ubo)
              for (const n of r.ubo)
                i.ubo.addUniform(n.name, n.size), this._uboDeclaration += `${n.type} ${n.name};\r
`, this._uniformList.push(n.name);
            r.vertex && (this._vertexDeclaration += r.vertex + `\r
`), r.fragment && (this._fragmentDeclaration += r.fragment + `\r
`);
          }
          s.getSamplers(this._samplerList), s.getUniformBuffersNames(this._uboList);
        }
        break;
      }
    }
  }
  _collectPointNames(e, t) {
    if (!!t)
      for (const i in t)
        this._codeInjectionPoints[e] || (this._codeInjectionPoints[e] = {}), this._codeInjectionPoints[e][i] = !0;
  }
  _injectCustomCode(e) {
    return (t, i) => {
      var s;
      e && (i = e(t, i)), this._uboDeclaration && (i = i.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration)), this._vertexDeclaration && (i = i.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration)), this._fragmentDeclaration && (i = i.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration));
      const r = (s = this._codeInjectionPoints) === null || s === void 0 ? void 0 : s[t];
      if (!r)
        return i;
      for (let n in r) {
        let a = "";
        for (const o of this._activePlugins) {
          const h = o.getCustomCode(t);
          h != null && h[n] && (a += h[n] + `\r
`);
        }
        if (a.length > 0)
          if (n.charAt(0) === "!") {
            n = n.substring(1);
            let o = "g";
            if (n.charAt(0) === "!")
              o = "", n = n.substring(1);
            else {
              const d = bl.exec(n);
              d && d.length >= 2 && (o = d[1], n = n.substring(o.length + 1));
            }
            o.indexOf("g") < 0 && (o += "g");
            const h = i, l = new RegExp(n, o);
            let u = l.exec(h);
            for (; u !== null; ) {
              let d = a;
              for (let f = 0; f < u.length; ++f)
                d = d.replace("$" + f, u[f]);
              i = i.replace(u[0], d), u = l.exec(h);
            }
          } else {
            const o = "#define " + n;
            i = i.replace(o, `\r
` + a + `\r
` + o);
          }
      }
      return i;
    };
  }
}
qt._MaterialPluginClassToMainDefine = {};
qt._MaterialPluginCounter = 0;
class fs {
  constructor(e, t, i, s, r = !0, n = !1) {
    this.priority = 500, this.registerForExtraEvents = !1, this._material = e, this.name = t, this.priority = i, e.pluginManager || (e.pluginManager = new qt(e)), this._pluginDefineNames = s, this._pluginManager = e.pluginManager, r && this._pluginManager._addPlugin(this), n && this._enable(!0), this.markAllDefinesAsDirty = e._dirtyCallbacks[63];
  }
  _enable(e) {
    e && this._pluginManager._activatePlugin(this);
  }
  getClassName() {
    return "MaterialPluginBase";
  }
  isReadyForSubMesh(e, t, i, s) {
    return !0;
  }
  hardBindForSubMesh(e, t, i, s) {
  }
  bindForSubMesh(e, t, i, s) {
  }
  dispose(e) {
  }
  getCustomCode(e) {
    return null;
  }
  collectDefines(e) {
    if (!!this._pluginDefineNames)
      for (const t of Object.keys(this._pluginDefineNames)) {
        if (t[0] === "_")
          continue;
        const i = typeof this._pluginDefineNames[t];
        e[t] = {
          type: i === "number" ? "number" : i === "string" ? "string" : i === "boolean" ? "boolean" : "object",
          default: this._pluginDefineNames[t]
        };
      }
  }
  prepareDefinesBeforeAttributes(e, t, i) {
  }
  prepareDefines(e, t, i) {
  }
  hasTexture(e) {
    return !1;
  }
  hasRenderTargetTextures() {
    return !1;
  }
  fillRenderTargetTextures(e) {
  }
  getActiveTextures(e) {
  }
  getAnimatables(e) {
  }
  addFallbacks(e, t, i) {
    return i;
  }
  getSamplers(e) {
  }
  getAttributes(e, t, i) {
  }
  getUniformBuffersNames(e) {
  }
  getUniforms() {
    return {};
  }
  copyTo(e) {
    ae.Clone(() => e, this);
  }
  serialize() {
    return ae.Serialize(this);
  }
  parse(e, t, i) {
    ae.Parse(() => this, e, t, i);
  }
}
T([
  R()
], fs.prototype, "name", void 0);
T([
  R()
], fs.prototype, "priority", void 0);
T([
  R()
], fs.prototype, "registerForExtraEvents", void 0);
class Sl extends Hs {
  constructor() {
    super(...arguments), this.DETAIL = !1, this.DETAILDIRECTUV = 0, this.DETAIL_NORMALBLENDMETHOD = 0;
  }
}
class fi extends fs {
  constructor(e, t = !0) {
    super(e, "DetailMap", 140, new Sl(), t), this._texture = null, this.diffuseBlendLevel = 1, this.roughnessBlendLevel = 1, this.bumpLevel = 1, this._normalBlendMethod = P.MATERIAL_NORMALBLENDMETHOD_WHITEOUT, this._isEnabled = !1, this.isEnabled = !1, this._internalMarkAllSubMeshesAsTexturesDirty = e._dirtyCallbacks[1];
  }
  _markAllSubMeshesAsTexturesDirty() {
    this._enable(this._isEnabled), this._internalMarkAllSubMeshesAsTexturesDirty();
  }
  isReadyForSubMesh(e, t, i) {
    return this._isEnabled ? !(e._areTexturesDirty && t.texturesEnabled && i.getCaps().standardDerivatives && this._texture && de.DetailTextureEnabled && !this._texture.isReady()) : !0;
  }
  prepareDefines(e, t) {
    if (this._isEnabled) {
      e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
      const i = t.getEngine();
      e._areTexturesDirty && (i.getCaps().standardDerivatives && this._texture && de.DetailTextureEnabled && this._isEnabled ? (te.PrepareDefinesForMergedUV(this._texture, e, "DETAIL"), e.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod) : e.DETAIL = !1);
    } else
      e.DETAIL = !1;
  }
  bindForSubMesh(e, t) {
    if (!this._isEnabled)
      return;
    const i = this._material.isFrozen;
    (!e.useUbo || !i || !e.isSync) && this._texture && de.DetailTextureEnabled && (e.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel), te.BindTextureMatrix(this._texture, e, "detail")), t.texturesEnabled && this._texture && de.DetailTextureEnabled && e.setTexture("detailSampler", this._texture);
  }
  hasTexture(e) {
    return this._texture === e;
  }
  getActiveTextures(e) {
    this._texture && e.push(this._texture);
  }
  getAnimatables(e) {
    this._texture && this._texture.animations && this._texture.animations.length > 0 && e.push(this._texture);
  }
  dispose(e) {
    var t;
    e && ((t = this._texture) === null || t === void 0 || t.dispose());
  }
  getClassName() {
    return "DetailMapConfiguration";
  }
  getSamplers(e) {
    e.push("detailSampler");
  }
  getUniforms() {
    return {
      ubo: [
        { name: "vDetailInfos", size: 4, type: "vec4" },
        { name: "detailMatrix", size: 16, type: "mat4" }
      ]
    };
  }
}
T([
  vt("detailTexture"),
  be("_markAllSubMeshesAsTexturesDirty")
], fi.prototype, "texture", void 0);
T([
  R()
], fi.prototype, "diffuseBlendLevel", void 0);
T([
  R()
], fi.prototype, "roughnessBlendLevel", void 0);
T([
  R()
], fi.prototype, "bumpLevel", void 0);
T([
  R(),
  be("_markAllSubMeshesAsTexturesDirty")
], fi.prototype, "normalBlendMethod", void 0);
T([
  R(),
  be("_markAllSubMeshesAsTexturesDirty")
], fi.prototype, "isEnabled", void 0);
const Ds = { effect: null, subMesh: null };
class xl extends Hs {
  constructor(e) {
    super(e), this.MAINUV1 = !1, this.MAINUV2 = !1, this.MAINUV3 = !1, this.MAINUV4 = !1, this.MAINUV5 = !1, this.MAINUV6 = !1, this.DIFFUSE = !1, this.DIFFUSEDIRECTUV = 0, this.BAKED_VERTEX_ANIMATION_TEXTURE = !1, this.AMBIENT = !1, this.AMBIENTDIRECTUV = 0, this.OPACITY = !1, this.OPACITYDIRECTUV = 0, this.OPACITYRGB = !1, this.REFLECTION = !1, this.EMISSIVE = !1, this.EMISSIVEDIRECTUV = 0, this.SPECULAR = !1, this.SPECULARDIRECTUV = 0, this.BUMP = !1, this.BUMPDIRECTUV = 0, this.PARALLAX = !1, this.PARALLAXOCCLUSION = !1, this.SPECULAROVERALPHA = !1, this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.ALPHATEST = !1, this.DEPTHPREPASS = !1, this.ALPHAFROMDIFFUSE = !1, this.POINTSIZE = !1, this.FOG = !1, this.SPECULARTERM = !1, this.DIFFUSEFRESNEL = !1, this.OPACITYFRESNEL = !1, this.REFLECTIONFRESNEL = !1, this.REFRACTIONFRESNEL = !1, this.EMISSIVEFRESNEL = !1, this.FRESNEL = !1, this.NORMAL = !1, this.TANGENT = !1, this.UV1 = !1, this.UV2 = !1, this.UV3 = !1, this.UV4 = !1, this.UV5 = !1, this.UV6 = !1, this.VERTEXCOLOR = !1, this.VERTEXALPHA = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.BONETEXTURE = !1, this.BONES_VELOCITY_ENABLED = !1, this.INSTANCES = !1, this.THIN_INSTANCES = !1, this.INSTANCESCOLOR = !1, this.GLOSSINESS = !1, this.ROUGHNESS = !1, this.EMISSIVEASILLUMINATION = !1, this.LINKEMISSIVEWITHDIFFUSE = !1, this.REFLECTIONFRESNELFROMSPECULAR = !1, this.LIGHTMAP = !1, this.LIGHTMAPDIRECTUV = 0, this.OBJECTSPACE_NORMALMAP = !1, this.USELIGHTMAPASSHADOWMAP = !1, this.REFLECTIONMAP_3D = !1, this.REFLECTIONMAP_SPHERICAL = !1, this.REFLECTIONMAP_PLANAR = !1, this.REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFLECTIONMAP_CUBIC = !1, this.USE_LOCAL_REFRACTIONMAP_CUBIC = !1, this.REFLECTIONMAP_PROJECTION = !1, this.REFLECTIONMAP_SKYBOX = !1, this.REFLECTIONMAP_EXPLICIT = !1, this.REFLECTIONMAP_EQUIRECTANGULAR = !1, this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = !1, this.REFLECTIONMAP_OPPOSITEZ = !1, this.INVERTCUBICMAP = !1, this.LOGARITHMICDEPTH = !1, this.REFRACTION = !1, this.REFRACTIONMAP_3D = !1, this.REFLECTIONOVERALPHA = !1, this.TWOSIDEDLIGHTING = !1, this.SHADOWFLOAT = !1, this.MORPHTARGETS = !1, this.MORPHTARGETS_NORMAL = !1, this.MORPHTARGETS_TANGENT = !1, this.MORPHTARGETS_UV = !1, this.NUM_MORPH_INFLUENCERS = 0, this.MORPHTARGETS_TEXTURE = !1, this.NONUNIFORMSCALING = !1, this.PREMULTIPLYALPHA = !1, this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = !1, this.ALPHABLEND = !0, this.PREPASS = !1, this.PREPASS_IRRADIANCE = !1, this.PREPASS_IRRADIANCE_INDEX = -1, this.PREPASS_ALBEDO_SQRT = !1, this.PREPASS_ALBEDO_SQRT_INDEX = -1, this.PREPASS_DEPTH = !1, this.PREPASS_DEPTH_INDEX = -1, this.PREPASS_NORMAL = !1, this.PREPASS_NORMAL_INDEX = -1, this.PREPASS_POSITION = !1, this.PREPASS_POSITION_INDEX = -1, this.PREPASS_VELOCITY = !1, this.PREPASS_VELOCITY_INDEX = -1, this.PREPASS_REFLECTIVITY = !1, this.PREPASS_REFLECTIVITY_INDEX = -1, this.SCENE_MRT_COUNT = 0, this.RGBDLIGHTMAP = !1, this.RGBDREFLECTION = !1, this.RGBDREFRACTION = !1, this.IMAGEPROCESSING = !1, this.VIGNETTE = !1, this.VIGNETTEBLENDMODEMULTIPLY = !1, this.VIGNETTEBLENDMODEOPAQUE = !1, this.TONEMAPPING = !1, this.TONEMAPPING_ACES = !1, this.CONTRAST = !1, this.COLORCURVES = !1, this.COLORGRADING = !1, this.COLORGRADING3D = !1, this.SAMPLER3DGREENDEPTH = !1, this.SAMPLER3DBGRMAP = !1, this.DITHER = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.MULTIVIEW = !1, this.ORDER_INDEPENDENT_TRANSPARENCY = !1, this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !1, this.CAMERA_ORTHOGRAPHIC = !1, this.CAMERA_PERSPECTIVE = !1, this.IS_REFLECTION_LINEAR = !1, this.IS_REFRACTION_LINEAR = !1, this.EXPOSURE = !1, this.rebuild();
  }
  setReflectionMode(e) {
    const t = [
      "REFLECTIONMAP_CUBIC",
      "REFLECTIONMAP_EXPLICIT",
      "REFLECTIONMAP_PLANAR",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_PROJECTION",
      "REFLECTIONMAP_SKYBOX",
      "REFLECTIONMAP_SPHERICAL",
      "REFLECTIONMAP_EQUIRECTANGULAR",
      "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
      "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
    ];
    for (const i of t)
      this[i] = i === e;
  }
}
class N extends Wr {
  constructor(e, t) {
    super(e, t), this._diffuseTexture = null, this._ambientTexture = null, this._opacityTexture = null, this._reflectionTexture = null, this._emissiveTexture = null, this._specularTexture = null, this._bumpTexture = null, this._lightmapTexture = null, this._refractionTexture = null, this.ambientColor = new se(0, 0, 0), this.diffuseColor = new se(1, 1, 1), this.specularColor = new se(1, 1, 1), this.emissiveColor = new se(0, 0, 0), this.specularPower = 64, this._useAlphaFromDiffuseTexture = !1, this._useEmissiveAsIllumination = !1, this._linkEmissiveWithDiffuse = !1, this._useSpecularOverAlpha = !1, this._useReflectionOverAlpha = !1, this._disableLighting = !1, this._useObjectSpaceNormalMap = !1, this._useParallax = !1, this._useParallaxOcclusion = !1, this.parallaxScaleBias = 0.05, this._roughness = 0, this.indexOfRefraction = 0.98, this.invertRefractionY = !0, this.alphaCutOff = 0.4, this._useLightmapAsShadowmap = !1, this._useReflectionFresnelFromSpecular = !1, this._useGlossinessFromSpecularMapAlpha = !1, this._maxSimultaneousLights = 4, this._invertNormalMapX = !1, this._invertNormalMapY = !1, this._twoSidedLighting = !1, this._renderTargets = new Qe(16), this._worldViewProjectionMatrix = x.Zero(), this._globalAmbientColor = new se(0, 0, 0), this._cacheHasRenderTargetTextures = !1, this.detailMap = new fi(this), this._attachImageProcessingConfiguration(null), this.prePassConfiguration = new vr(), this.getRenderTargetTextures = () => (this._renderTargets.reset(), N.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget && this._renderTargets.push(this._reflectionTexture), N.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget && this._renderTargets.push(this._refractionTexture), this._eventInfo.renderTargets = this._renderTargets, this._callbackPluginEventFillRenderTargetTextures(this._eventInfo), this._renderTargets);
  }
  get imageProcessingConfiguration() {
    return this._imageProcessingConfiguration;
  }
  set imageProcessingConfiguration(e) {
    this._attachImageProcessingConfiguration(e), this._markAllSubMeshesAsTexturesDirty();
  }
  _attachImageProcessingConfiguration(e) {
    e !== this._imageProcessingConfiguration && (this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), e ? this._imageProcessingConfiguration = e : this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration, this._imageProcessingConfiguration && (this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
      this._markAllSubMeshesAsImageProcessingDirty();
    })));
  }
  get isPrePassCapable() {
    return !this.disableDepthWrite;
  }
  get cameraColorCurvesEnabled() {
    return this.imageProcessingConfiguration.colorCurvesEnabled;
  }
  set cameraColorCurvesEnabled(e) {
    this.imageProcessingConfiguration.colorCurvesEnabled = e;
  }
  get cameraColorGradingEnabled() {
    return this.imageProcessingConfiguration.colorGradingEnabled;
  }
  set cameraColorGradingEnabled(e) {
    this.imageProcessingConfiguration.colorGradingEnabled = e;
  }
  get cameraToneMappingEnabled() {
    return this._imageProcessingConfiguration.toneMappingEnabled;
  }
  set cameraToneMappingEnabled(e) {
    this._imageProcessingConfiguration.toneMappingEnabled = e;
  }
  get cameraExposure() {
    return this._imageProcessingConfiguration.exposure;
  }
  set cameraExposure(e) {
    this._imageProcessingConfiguration.exposure = e;
  }
  get cameraContrast() {
    return this._imageProcessingConfiguration.contrast;
  }
  set cameraContrast(e) {
    this._imageProcessingConfiguration.contrast = e;
  }
  get cameraColorGradingTexture() {
    return this._imageProcessingConfiguration.colorGradingTexture;
  }
  set cameraColorGradingTexture(e) {
    this._imageProcessingConfiguration.colorGradingTexture = e;
  }
  get cameraColorCurves() {
    return this._imageProcessingConfiguration.colorCurves;
  }
  set cameraColorCurves(e) {
    this._imageProcessingConfiguration.colorCurves = e;
  }
  get canRenderToMRT() {
    return !0;
  }
  get hasRenderTargetTextures() {
    return N.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget || N.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget ? !0 : this._cacheHasRenderTargetTextures;
  }
  getClassName() {
    return "StandardMaterial";
  }
  get useLogarithmicDepth() {
    return this._useLogarithmicDepth;
  }
  set useLogarithmicDepth(e) {
    this._useLogarithmicDepth = e && this.getScene().getEngine().getCaps().fragmentDepthSupported, this._markAllSubMeshesAsMiscDirty();
  }
  needAlphaBlending() {
    return this._disableAlphaBlending ? !1 : this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
  }
  needAlphaTesting() {
    return this._forceAlphaTest ? !0 : this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === P.MATERIAL_ALPHATEST);
  }
  _shouldUseAlphaFromDiffuseTexture() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== P.MATERIAL_OPAQUE;
  }
  _hasAlphaChannel() {
    return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
  }
  getAlphaTestTexture() {
    return this._diffuseTexture;
  }
  isReadyForSubMesh(e, t, i = !1) {
    if (this._uniformBufferLayoutBuilt || this.buildUniformLayout(), t.effect && this.isFrozen && t.effect._wasPreviouslyReady && t.effect._wasPreviouslyUsingInstances === i)
      return !0;
    t.materialDefines || (this._callbackPluginEventGeneric(je.GetDefineNames, this._eventInfo), t.materialDefines = new xl(this._eventInfo.defineNames));
    const s = this.getScene(), r = t.materialDefines;
    if (this._isReadyForSubMesh(t))
      return !0;
    const n = s.getEngine();
    r._needNormals = te.PrepareDefinesForLights(s, e, r, !0, this._maxSimultaneousLights, this._disableLighting), te.PrepareDefinesForMultiview(s, r);
    const a = this.needAlphaBlendingForMesh(e) && this.getScene().useOrderIndependentTransparency;
    if (te.PrepareDefinesForPrePass(s, r, this.canRenderToMRT && !a), te.PrepareDefinesForOIT(s, r, a), r._areTexturesDirty) {
      this._eventInfo.hasRenderTargetTextures = !1, this._callbackPluginEventHasRenderTargetTextures(this._eventInfo), this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures, r._needUVs = !1;
      for (let h = 1; h <= 6; ++h)
        r["MAINUV" + h] = !1;
      if (s.texturesEnabled) {
        if (r.DIFFUSEDIRECTUV = 0, r.BUMPDIRECTUV = 0, r.AMBIENTDIRECTUV = 0, r.OPACITYDIRECTUV = 0, r.EMISSIVEDIRECTUV = 0, r.SPECULARDIRECTUV = 0, r.LIGHTMAPDIRECTUV = 0, this._diffuseTexture && N.DiffuseTextureEnabled)
          if (this._diffuseTexture.isReadyOrNotBlocking())
            te.PrepareDefinesForMergedUV(this._diffuseTexture, r, "DIFFUSE");
          else
            return !1;
        else
          r.DIFFUSE = !1;
        if (this._ambientTexture && N.AmbientTextureEnabled)
          if (this._ambientTexture.isReadyOrNotBlocking())
            te.PrepareDefinesForMergedUV(this._ambientTexture, r, "AMBIENT");
          else
            return !1;
        else
          r.AMBIENT = !1;
        if (this._opacityTexture && N.OpacityTextureEnabled)
          if (this._opacityTexture.isReadyOrNotBlocking())
            te.PrepareDefinesForMergedUV(this._opacityTexture, r, "OPACITY"), r.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
          else
            return !1;
        else
          r.OPACITY = !1;
        if (this._reflectionTexture && N.ReflectionTextureEnabled)
          if (this._reflectionTexture.isReadyOrNotBlocking()) {
            switch (r._needNormals = !0, r.REFLECTION = !0, r.ROUGHNESS = this._roughness > 0, r.REFLECTIONOVERALPHA = this._useReflectionOverAlpha, r.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === B.INVCUBIC_MODE, r.REFLECTIONMAP_3D = this._reflectionTexture.isCube, r.REFLECTIONMAP_OPPOSITEZ = r.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ, r.RGBDREFLECTION = this._reflectionTexture.isRGBD, this._reflectionTexture.coordinatesMode) {
              case B.EXPLICIT_MODE:
                r.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                break;
              case B.PLANAR_MODE:
                r.setReflectionMode("REFLECTIONMAP_PLANAR");
                break;
              case B.PROJECTION_MODE:
                r.setReflectionMode("REFLECTIONMAP_PROJECTION");
                break;
              case B.SKYBOX_MODE:
                r.setReflectionMode("REFLECTIONMAP_SKYBOX");
                break;
              case B.SPHERICAL_MODE:
                r.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                break;
              case B.EQUIRECTANGULAR_MODE:
                r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                break;
              case B.FIXED_EQUIRECTANGULAR_MODE:
                r.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                break;
              case B.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                r.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                break;
              case B.CUBIC_MODE:
              case B.INVCUBIC_MODE:
              default:
                r.setReflectionMode("REFLECTIONMAP_CUBIC");
                break;
            }
            r.USE_LOCAL_REFLECTIONMAP_CUBIC = !!this._reflectionTexture.boundingBoxSize;
          } else
            return !1;
        else
          r.REFLECTION = !1, r.REFLECTIONMAP_OPPOSITEZ = !1;
        if (this._emissiveTexture && N.EmissiveTextureEnabled)
          if (this._emissiveTexture.isReadyOrNotBlocking())
            te.PrepareDefinesForMergedUV(this._emissiveTexture, r, "EMISSIVE");
          else
            return !1;
        else
          r.EMISSIVE = !1;
        if (this._lightmapTexture && N.LightmapTextureEnabled)
          if (this._lightmapTexture.isReadyOrNotBlocking())
            te.PrepareDefinesForMergedUV(this._lightmapTexture, r, "LIGHTMAP"), r.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap, r.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
          else
            return !1;
        else
          r.LIGHTMAP = !1;
        if (this._specularTexture && N.SpecularTextureEnabled)
          if (this._specularTexture.isReadyOrNotBlocking())
            te.PrepareDefinesForMergedUV(this._specularTexture, r, "SPECULAR"), r.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
          else
            return !1;
        else
          r.SPECULAR = !1;
        if (s.getEngine().getCaps().standardDerivatives && this._bumpTexture && N.BumpTextureEnabled) {
          if (this._bumpTexture.isReady())
            te.PrepareDefinesForMergedUV(this._bumpTexture, r, "BUMP"), r.PARALLAX = this._useParallax, r.PARALLAXOCCLUSION = this._useParallaxOcclusion;
          else
            return !1;
          r.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
        } else
          r.BUMP = !1, r.PARALLAX = !1, r.PARALLAXOCCLUSION = !1;
        if (this._refractionTexture && N.RefractionTextureEnabled)
          if (this._refractionTexture.isReadyOrNotBlocking())
            r._needUVs = !0, r.REFRACTION = !0, r.REFRACTIONMAP_3D = this._refractionTexture.isCube, r.RGBDREFRACTION = this._refractionTexture.isRGBD, r.USE_LOCAL_REFRACTIONMAP_CUBIC = !!this._refractionTexture.boundingBoxSize;
          else
            return !1;
        else
          r.REFRACTION = !1;
        r.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
      } else
        r.DIFFUSE = !1, r.AMBIENT = !1, r.OPACITY = !1, r.REFLECTION = !1, r.EMISSIVE = !1, r.LIGHTMAP = !1, r.BUMP = !1, r.REFRACTION = !1;
      r.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture(), r.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination, r.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse, r.SPECULAROVERALPHA = this._useSpecularOverAlpha, r.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8, r.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null, r.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(e);
    }
    if (this._eventInfo.isReadyForSubMesh = !0, this._eventInfo.defines = r, this._callbackPluginEventIsReadyForSubMesh(this._eventInfo), !this._eventInfo.isReadyForSubMesh)
      return !1;
    if (r._areImageProcessingDirty && this._imageProcessingConfiguration) {
      if (!this._imageProcessingConfiguration.isReady())
        return !1;
      this._imageProcessingConfiguration.prepareDefines(r), r.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace, r.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
    }
    r._areFresnelDirty && (N.FresnelEnabled ? (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) && (r.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled, r.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled, r.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled, r.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular, r.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled, r.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled, r._needNormals = !0, r.FRESNEL = !0) : r.FRESNEL = !1), te.PrepareDefinesForMisc(e, s, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e) || this._forceAlphaTest, r), te.PrepareDefinesForFrameBoundValues(s, n, this, r, i, null, t.getRenderingMesh().hasThinInstances), this._eventInfo.defines = r, this._eventInfo.mesh = e, this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo), te.PrepareDefinesForAttributes(e, r, !0, !0, !0), this._callbackPluginEventPrepareDefines(this._eventInfo);
    let o = !1;
    if (r.isDirty) {
      const h = r._areLightsDisposed;
      r.markAsProcessed();
      const l = new qs();
      r.REFLECTION && l.addFallback(0, "REFLECTION"), r.SPECULAR && l.addFallback(0, "SPECULAR"), r.BUMP && l.addFallback(0, "BUMP"), r.PARALLAX && l.addFallback(1, "PARALLAX"), r.PARALLAXOCCLUSION && l.addFallback(0, "PARALLAXOCCLUSION"), r.SPECULAROVERALPHA && l.addFallback(0, "SPECULAROVERALPHA"), r.FOG && l.addFallback(1, "FOG"), r.POINTSIZE && l.addFallback(0, "POINTSIZE"), r.LOGARITHMICDEPTH && l.addFallback(0, "LOGARITHMICDEPTH"), te.HandleFallbacksForShadows(r, l, this._maxSimultaneousLights), r.SPECULARTERM && l.addFallback(0, "SPECULARTERM"), r.DIFFUSEFRESNEL && l.addFallback(1, "DIFFUSEFRESNEL"), r.OPACITYFRESNEL && l.addFallback(2, "OPACITYFRESNEL"), r.REFLECTIONFRESNEL && l.addFallback(3, "REFLECTIONFRESNEL"), r.EMISSIVEFRESNEL && l.addFallback(4, "EMISSIVEFRESNEL"), r.FRESNEL && l.addFallback(4, "FRESNEL"), r.MULTIVIEW && l.addFallback(0, "MULTIVIEW");
      const u = [g.PositionKind];
      r.NORMAL && u.push(g.NormalKind), r.TANGENT && u.push(g.TangentKind);
      for (let A = 1; A <= 6; ++A)
        r["UV" + A] && u.push(`uv${A === 1 ? "" : A}`);
      r.VERTEXCOLOR && u.push(g.ColorKind), te.PrepareAttributesForBones(u, e, r, l), te.PrepareAttributesForInstances(u, r), te.PrepareAttributesForMorphTargets(u, e, r), te.PrepareAttributesForBakedVertexAnimation(u, e, r);
      let d = "default";
      const f = [
        "world",
        "view",
        "viewProjection",
        "vEyePosition",
        "vLightsType",
        "vAmbientColor",
        "vDiffuseColor",
        "vSpecularColor",
        "vEmissiveColor",
        "visibility",
        "vFogInfos",
        "vFogColor",
        "pointSize",
        "vDiffuseInfos",
        "vAmbientInfos",
        "vOpacityInfos",
        "vReflectionInfos",
        "vEmissiveInfos",
        "vSpecularInfos",
        "vBumpInfos",
        "vLightmapInfos",
        "vRefractionInfos",
        "mBones",
        "diffuseMatrix",
        "ambientMatrix",
        "opacityMatrix",
        "reflectionMatrix",
        "emissiveMatrix",
        "specularMatrix",
        "bumpMatrix",
        "normalMatrix",
        "lightmapMatrix",
        "refractionMatrix",
        "diffuseLeftColor",
        "diffuseRightColor",
        "opacityParts",
        "reflectionLeftColor",
        "reflectionRightColor",
        "emissiveLeftColor",
        "emissiveRightColor",
        "refractionLeftColor",
        "refractionRightColor",
        "vReflectionPosition",
        "vReflectionSize",
        "vRefractionPosition",
        "vRefractionSize",
        "logarithmicDepthConstant",
        "vTangentSpaceParams",
        "alphaCutOff",
        "boneTextureWidth",
        "morphTargetTextureInfo",
        "morphTargetTextureIndices"
      ], _ = [
        "diffuseSampler",
        "ambientSampler",
        "opacitySampler",
        "reflectionCubeSampler",
        "reflection2DSampler",
        "emissiveSampler",
        "specularSampler",
        "bumpSampler",
        "lightmapSampler",
        "refractionCubeSampler",
        "refraction2DSampler",
        "boneSampler",
        "morphTargets",
        "oitDepthSampler",
        "oitFrontColorSampler"
      ], E = ["Material", "Scene", "Mesh"];
      this._eventInfo.fallbacks = l, this._eventInfo.fallbackRank = 0, this._eventInfo.defines = r, this._eventInfo.uniforms = f, this._eventInfo.attributes = u, this._eventInfo.samplers = _, this._eventInfo.uniformBuffersNames = E, this._eventInfo.customCode = void 0, this._eventInfo.mesh = e, this._callbackPluginEventGeneric(je.PrepareEffect, this._eventInfo), vr.AddUniforms(f), me && (me.PrepareUniforms(f, r), me.PrepareSamplers(_, r)), te.PrepareUniformsAndSamplersList({
        uniformsNames: f,
        uniformBuffersNames: E,
        samplers: _,
        defines: r,
        maxSimultaneousLights: this._maxSimultaneousLights
      }), ls(f);
      const m = {};
      this.customShaderNameResolve && (d = this.customShaderNameResolve(d, f, E, _, r, u, m));
      const v = r.toString(), S = t.effect;
      let y = s.getEngine().createEffect(d, {
        attributes: u,
        uniformsNames: f,
        uniformBuffersNames: E,
        samplers: _,
        defines: v,
        fallbacks: l,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: r.NUM_MORPH_INFLUENCERS },
        processFinalCode: m.processFinalCode,
        processCodeAfterIncludes: this._eventInfo.customCode,
        multiTarget: r.PREPASS
      }, n);
      if (this._eventInfo.customCode = void 0, y)
        if (this._onEffectCreatedObservable && (Ds.effect = y, Ds.subMesh = t, this._onEffectCreatedObservable.notifyObservers(Ds)), this.allowShaderHotSwapping && S && !y.isReady()) {
          if (y = S, r.markAsUnprocessed(), o = this.isFrozen, h)
            return r._areLightsDisposed = !0, !1;
        } else
          s.resetCachedMaterial(), t.setEffect(y, r, this._materialContext);
    }
    return !t.effect || !t.effect.isReady() ? !1 : (r._renderId = s.getRenderId(), t.effect._wasPreviouslyReady = !o, t.effect._wasPreviouslyUsingInstances = i, s.performancePriority !== Ct.BackwardCompatible && (this.checkReadyOnlyOnce = !0), !0);
  }
  buildUniformLayout() {
    const e = this._uniformBuffer;
    e.addUniform("diffuseLeftColor", 4), e.addUniform("diffuseRightColor", 4), e.addUniform("opacityParts", 4), e.addUniform("reflectionLeftColor", 4), e.addUniform("reflectionRightColor", 4), e.addUniform("refractionLeftColor", 4), e.addUniform("refractionRightColor", 4), e.addUniform("emissiveLeftColor", 4), e.addUniform("emissiveRightColor", 4), e.addUniform("vDiffuseInfos", 2), e.addUniform("vAmbientInfos", 2), e.addUniform("vOpacityInfos", 2), e.addUniform("vReflectionInfos", 2), e.addUniform("vReflectionPosition", 3), e.addUniform("vReflectionSize", 3), e.addUniform("vEmissiveInfos", 2), e.addUniform("vLightmapInfos", 2), e.addUniform("vSpecularInfos", 2), e.addUniform("vBumpInfos", 3), e.addUniform("diffuseMatrix", 16), e.addUniform("ambientMatrix", 16), e.addUniform("opacityMatrix", 16), e.addUniform("reflectionMatrix", 16), e.addUniform("emissiveMatrix", 16), e.addUniform("lightmapMatrix", 16), e.addUniform("specularMatrix", 16), e.addUniform("bumpMatrix", 16), e.addUniform("vTangentSpaceParams", 2), e.addUniform("pointSize", 1), e.addUniform("alphaCutOff", 1), e.addUniform("refractionMatrix", 16), e.addUniform("vRefractionInfos", 4), e.addUniform("vRefractionPosition", 3), e.addUniform("vRefractionSize", 3), e.addUniform("vSpecularColor", 4), e.addUniform("vEmissiveColor", 3), e.addUniform("vDiffuseColor", 4), e.addUniform("vAmbientColor", 3), super.buildUniformLayout();
  }
  bindForSubMesh(e, t, i) {
    var s;
    const r = this.getScene(), n = i.materialDefines;
    if (!n)
      return;
    const a = i.effect;
    if (!a)
      return;
    this._activeEffect = a, t.getMeshUniformBuffer().bindToEffect(a, "Mesh"), t.transferToEffect(e), this._uniformBuffer.bindToEffect(a, "Material"), this.prePassConfiguration.bindForSubMesh(this._activeEffect, r, t, e, this.isFrozen), this._eventInfo.subMesh = i, this._callbackPluginEventHardBindForSubMesh(this._eventInfo), n.OBJECTSPACE_NORMALMAP && (e.toNormalMatrix(this._normalMatrix), this.bindOnlyNormalMatrix(this._normalMatrix));
    const o = a._forceRebindOnNextCall || this._mustRebind(r, a, t.visibility);
    te.BindBonesParameters(t, a);
    const h = this._uniformBuffer;
    if (o) {
      if (this.bindViewProjection(a), !h.useUbo || !this.isFrozen || !h.isSync || a._forceRebindOnNextCall) {
        if (N.FresnelEnabled && n.FRESNEL && (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled && (h.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power), h.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias)), this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled && h.updateColor4("opacityParts", new se(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power), this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled && (h.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power), h.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias)), this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled && (h.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power), h.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias)), this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled && (h.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power), h.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias))), r.texturesEnabled) {
          if (this._diffuseTexture && N.DiffuseTextureEnabled && (h.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level), te.BindTextureMatrix(this._diffuseTexture, h, "diffuse")), this._ambientTexture && N.AmbientTextureEnabled && (h.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level), te.BindTextureMatrix(this._ambientTexture, h, "ambient")), this._opacityTexture && N.OpacityTextureEnabled && (h.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level), te.BindTextureMatrix(this._opacityTexture, h, "opacity")), this._hasAlphaChannel() && h.updateFloat("alphaCutOff", this.alphaCutOff), this._reflectionTexture && N.ReflectionTextureEnabled && (h.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness), h.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix()), this._reflectionTexture.boundingBoxSize)) {
            const l = this._reflectionTexture;
            h.updateVector3("vReflectionPosition", l.boundingBoxPosition), h.updateVector3("vReflectionSize", l.boundingBoxSize);
          }
          if (this._emissiveTexture && N.EmissiveTextureEnabled && (h.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level), te.BindTextureMatrix(this._emissiveTexture, h, "emissive")), this._lightmapTexture && N.LightmapTextureEnabled && (h.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level), te.BindTextureMatrix(this._lightmapTexture, h, "lightmap")), this._specularTexture && N.SpecularTextureEnabled && (h.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level), te.BindTextureMatrix(this._specularTexture, h, "specular")), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && N.BumpTextureEnabled && (h.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias), te.BindTextureMatrix(this._bumpTexture, h, "bump"), r._mirroredCameraPosition ? h.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1) : h.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1)), this._refractionTexture && N.RefractionTextureEnabled) {
            let l = 1;
            if (this._refractionTexture.isCube || (h.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix()), this._refractionTexture.depth && (l = this._refractionTexture.depth)), h.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, l, this.invertRefractionY ? -1 : 1), this._refractionTexture.boundingBoxSize) {
              const u = this._refractionTexture;
              h.updateVector3("vRefractionPosition", u.boundingBoxPosition), h.updateVector3("vRefractionSize", u.boundingBoxSize);
            }
          }
        }
        this.pointsCloud && h.updateFloat("pointSize", this.pointSize), n.SPECULARTERM && h.updateColor4("vSpecularColor", this.specularColor, this.specularPower), h.updateColor3("vEmissiveColor", N.EmissiveTextureEnabled ? this.emissiveColor : se.BlackReadOnly), h.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha), r.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor), h.updateColor3("vAmbientColor", this._globalAmbientColor);
      }
      r.texturesEnabled && (this._diffuseTexture && N.DiffuseTextureEnabled && a.setTexture("diffuseSampler", this._diffuseTexture), this._ambientTexture && N.AmbientTextureEnabled && a.setTexture("ambientSampler", this._ambientTexture), this._opacityTexture && N.OpacityTextureEnabled && a.setTexture("opacitySampler", this._opacityTexture), this._reflectionTexture && N.ReflectionTextureEnabled && (this._reflectionTexture.isCube ? a.setTexture("reflectionCubeSampler", this._reflectionTexture) : a.setTexture("reflection2DSampler", this._reflectionTexture)), this._emissiveTexture && N.EmissiveTextureEnabled && a.setTexture("emissiveSampler", this._emissiveTexture), this._lightmapTexture && N.LightmapTextureEnabled && a.setTexture("lightmapSampler", this._lightmapTexture), this._specularTexture && N.SpecularTextureEnabled && a.setTexture("specularSampler", this._specularTexture), this._bumpTexture && r.getEngine().getCaps().standardDerivatives && N.BumpTextureEnabled && a.setTexture("bumpSampler", this._bumpTexture), this._refractionTexture && N.RefractionTextureEnabled && (this._refractionTexture.isCube ? a.setTexture("refractionCubeSampler", this._refractionTexture) : a.setTexture("refraction2DSampler", this._refractionTexture))), this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(t) && this.getScene().depthPeelingRenderer.bind(a), this._eventInfo.subMesh = i, this._callbackPluginEventBindForSubMesh(this._eventInfo), cs(a, this, r), this.bindEyePosition(a);
    } else
      r.getEngine()._features.needToAlwaysBindUniformBuffers && (this._needToBindSceneUbo = !0);
    (o || !this.isFrozen) && (r.lightsEnabled && !this._disableLighting && te.BindLights(r, t, a, n, this._maxSimultaneousLights), (r.fogEnabled && t.applyFog && r.fogMode !== re.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || t.receiveShadows || n.PREPASS) && this.bindView(a), te.BindFogParameters(r, t, a), n.NUM_MORPH_INFLUENCERS && te.BindMorphTargetParameters(t, a), n.BAKED_VERTEX_ANIMATION_TEXTURE && ((s = t.bakedVertexAnimationManager) === null || s === void 0 || s.bind(a, n.INSTANCES)), this.useLogarithmicDepth && te.BindLogDepth(n, a, r), this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess && this._imageProcessingConfiguration.bind(this._activeEffect)), this._afterBind(t, this._activeEffect), h.update();
  }
  getAnimatables() {
    const e = super.getAnimatables();
    return this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0 && e.push(this._diffuseTexture), this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0 && e.push(this._ambientTexture), this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0 && e.push(this._opacityTexture), this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0 && e.push(this._reflectionTexture), this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0 && e.push(this._emissiveTexture), this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0 && e.push(this._specularTexture), this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0 && e.push(this._bumpTexture), this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0 && e.push(this._lightmapTexture), this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0 && e.push(this._refractionTexture), e;
  }
  getActiveTextures() {
    const e = super.getActiveTextures();
    return this._diffuseTexture && e.push(this._diffuseTexture), this._ambientTexture && e.push(this._ambientTexture), this._opacityTexture && e.push(this._opacityTexture), this._reflectionTexture && e.push(this._reflectionTexture), this._emissiveTexture && e.push(this._emissiveTexture), this._specularTexture && e.push(this._specularTexture), this._bumpTexture && e.push(this._bumpTexture), this._lightmapTexture && e.push(this._lightmapTexture), this._refractionTexture && e.push(this._refractionTexture), e;
  }
  hasTexture(e) {
    return !!(super.hasTexture(e) || this._diffuseTexture === e || this._ambientTexture === e || this._opacityTexture === e || this._reflectionTexture === e || this._emissiveTexture === e || this._specularTexture === e || this._bumpTexture === e || this._lightmapTexture === e || this._refractionTexture === e);
  }
  dispose(e, t) {
    var i, s, r, n, a, o, h, l, u;
    t && ((i = this._diffuseTexture) === null || i === void 0 || i.dispose(), (s = this._ambientTexture) === null || s === void 0 || s.dispose(), (r = this._opacityTexture) === null || r === void 0 || r.dispose(), (n = this._reflectionTexture) === null || n === void 0 || n.dispose(), (a = this._emissiveTexture) === null || a === void 0 || a.dispose(), (o = this._specularTexture) === null || o === void 0 || o.dispose(), (h = this._bumpTexture) === null || h === void 0 || h.dispose(), (l = this._lightmapTexture) === null || l === void 0 || l.dispose(), (u = this._refractionTexture) === null || u === void 0 || u.dispose()), this._imageProcessingConfiguration && this._imageProcessingObserver && this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver), super.dispose(e, t);
  }
  clone(e) {
    const t = ae.Clone(() => new N(e, this.getScene()), this);
    return t.name = e, t.id = e, this.stencil.copyTo(t.stencil), t;
  }
  static Parse(e, t, i) {
    const s = ae.Parse(() => new N(e.name, t), e, t, i);
    return e.stencil && s.stencil.parse(e.stencil, t, i), s;
  }
  static get DiffuseTextureEnabled() {
    return de.DiffuseTextureEnabled;
  }
  static set DiffuseTextureEnabled(e) {
    de.DiffuseTextureEnabled = e;
  }
  static get DetailTextureEnabled() {
    return de.DetailTextureEnabled;
  }
  static set DetailTextureEnabled(e) {
    de.DetailTextureEnabled = e;
  }
  static get AmbientTextureEnabled() {
    return de.AmbientTextureEnabled;
  }
  static set AmbientTextureEnabled(e) {
    de.AmbientTextureEnabled = e;
  }
  static get OpacityTextureEnabled() {
    return de.OpacityTextureEnabled;
  }
  static set OpacityTextureEnabled(e) {
    de.OpacityTextureEnabled = e;
  }
  static get ReflectionTextureEnabled() {
    return de.ReflectionTextureEnabled;
  }
  static set ReflectionTextureEnabled(e) {
    de.ReflectionTextureEnabled = e;
  }
  static get EmissiveTextureEnabled() {
    return de.EmissiveTextureEnabled;
  }
  static set EmissiveTextureEnabled(e) {
    de.EmissiveTextureEnabled = e;
  }
  static get SpecularTextureEnabled() {
    return de.SpecularTextureEnabled;
  }
  static set SpecularTextureEnabled(e) {
    de.SpecularTextureEnabled = e;
  }
  static get BumpTextureEnabled() {
    return de.BumpTextureEnabled;
  }
  static set BumpTextureEnabled(e) {
    de.BumpTextureEnabled = e;
  }
  static get LightmapTextureEnabled() {
    return de.LightmapTextureEnabled;
  }
  static set LightmapTextureEnabled(e) {
    de.LightmapTextureEnabled = e;
  }
  static get RefractionTextureEnabled() {
    return de.RefractionTextureEnabled;
  }
  static set RefractionTextureEnabled(e) {
    de.RefractionTextureEnabled = e;
  }
  static get ColorGradingTextureEnabled() {
    return de.ColorGradingTextureEnabled;
  }
  static set ColorGradingTextureEnabled(e) {
    de.ColorGradingTextureEnabled = e;
  }
  static get FresnelEnabled() {
    return de.FresnelEnabled;
  }
  static set FresnelEnabled(e) {
    de.FresnelEnabled = e;
  }
}
T([
  vt("diffuseTexture")
], N.prototype, "_diffuseTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesAndMiscDirty")
], N.prototype, "diffuseTexture", void 0);
T([
  vt("ambientTexture")
], N.prototype, "_ambientTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "ambientTexture", void 0);
T([
  vt("opacityTexture")
], N.prototype, "_opacityTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesAndMiscDirty")
], N.prototype, "opacityTexture", void 0);
T([
  vt("reflectionTexture")
], N.prototype, "_reflectionTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "reflectionTexture", void 0);
T([
  vt("emissiveTexture")
], N.prototype, "_emissiveTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "emissiveTexture", void 0);
T([
  vt("specularTexture")
], N.prototype, "_specularTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "specularTexture", void 0);
T([
  vt("bumpTexture")
], N.prototype, "_bumpTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "bumpTexture", void 0);
T([
  vt("lightmapTexture")
], N.prototype, "_lightmapTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "lightmapTexture", void 0);
T([
  vt("refractionTexture")
], N.prototype, "_refractionTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "refractionTexture", void 0);
T([
  di("ambient")
], N.prototype, "ambientColor", void 0);
T([
  di("diffuse")
], N.prototype, "diffuseColor", void 0);
T([
  di("specular")
], N.prototype, "specularColor", void 0);
T([
  di("emissive")
], N.prototype, "emissiveColor", void 0);
T([
  R()
], N.prototype, "specularPower", void 0);
T([
  R("useAlphaFromDiffuseTexture")
], N.prototype, "_useAlphaFromDiffuseTexture", void 0);
T([
  be("_markAllSubMeshesAsTexturesAndMiscDirty")
], N.prototype, "useAlphaFromDiffuseTexture", void 0);
T([
  R("useEmissiveAsIllumination")
], N.prototype, "_useEmissiveAsIllumination", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useEmissiveAsIllumination", void 0);
T([
  R("linkEmissiveWithDiffuse")
], N.prototype, "_linkEmissiveWithDiffuse", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "linkEmissiveWithDiffuse", void 0);
T([
  R("useSpecularOverAlpha")
], N.prototype, "_useSpecularOverAlpha", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useSpecularOverAlpha", void 0);
T([
  R("useReflectionOverAlpha")
], N.prototype, "_useReflectionOverAlpha", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useReflectionOverAlpha", void 0);
T([
  R("disableLighting")
], N.prototype, "_disableLighting", void 0);
T([
  be("_markAllSubMeshesAsLightsDirty")
], N.prototype, "disableLighting", void 0);
T([
  R("useObjectSpaceNormalMap")
], N.prototype, "_useObjectSpaceNormalMap", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useObjectSpaceNormalMap", void 0);
T([
  R("useParallax")
], N.prototype, "_useParallax", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useParallax", void 0);
T([
  R("useParallaxOcclusion")
], N.prototype, "_useParallaxOcclusion", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useParallaxOcclusion", void 0);
T([
  R()
], N.prototype, "parallaxScaleBias", void 0);
T([
  R("roughness")
], N.prototype, "_roughness", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "roughness", void 0);
T([
  R()
], N.prototype, "indexOfRefraction", void 0);
T([
  R()
], N.prototype, "invertRefractionY", void 0);
T([
  R()
], N.prototype, "alphaCutOff", void 0);
T([
  R("useLightmapAsShadowmap")
], N.prototype, "_useLightmapAsShadowmap", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useLightmapAsShadowmap", void 0);
T([
  Vi("diffuseFresnelParameters")
], N.prototype, "_diffuseFresnelParameters", void 0);
T([
  be("_markAllSubMeshesAsFresnelDirty")
], N.prototype, "diffuseFresnelParameters", void 0);
T([
  Vi("opacityFresnelParameters")
], N.prototype, "_opacityFresnelParameters", void 0);
T([
  be("_markAllSubMeshesAsFresnelAndMiscDirty")
], N.prototype, "opacityFresnelParameters", void 0);
T([
  Vi("reflectionFresnelParameters")
], N.prototype, "_reflectionFresnelParameters", void 0);
T([
  be("_markAllSubMeshesAsFresnelDirty")
], N.prototype, "reflectionFresnelParameters", void 0);
T([
  Vi("refractionFresnelParameters")
], N.prototype, "_refractionFresnelParameters", void 0);
T([
  be("_markAllSubMeshesAsFresnelDirty")
], N.prototype, "refractionFresnelParameters", void 0);
T([
  Vi("emissiveFresnelParameters")
], N.prototype, "_emissiveFresnelParameters", void 0);
T([
  be("_markAllSubMeshesAsFresnelDirty")
], N.prototype, "emissiveFresnelParameters", void 0);
T([
  R("useReflectionFresnelFromSpecular")
], N.prototype, "_useReflectionFresnelFromSpecular", void 0);
T([
  be("_markAllSubMeshesAsFresnelDirty")
], N.prototype, "useReflectionFresnelFromSpecular", void 0);
T([
  R("useGlossinessFromSpecularMapAlpha")
], N.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
T([
  R("maxSimultaneousLights")
], N.prototype, "_maxSimultaneousLights", void 0);
T([
  be("_markAllSubMeshesAsLightsDirty")
], N.prototype, "maxSimultaneousLights", void 0);
T([
  R("invertNormalMapX")
], N.prototype, "_invertNormalMapX", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "invertNormalMapX", void 0);
T([
  R("invertNormalMapY")
], N.prototype, "_invertNormalMapY", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "invertNormalMapY", void 0);
T([
  R("twoSidedLighting")
], N.prototype, "_twoSidedLighting", void 0);
T([
  be("_markAllSubMeshesAsTexturesDirty")
], N.prototype, "twoSidedLighting", void 0);
T([
  R()
], N.prototype, "useLogarithmicDepth", null);
st("BABYLON.StandardMaterial", N);
re.DefaultMaterialFactory = (c) => new N("default material", c);
const Ml = "imageProcessingCompatibility", Al = `#ifdef IMAGEPROCESSINGPOSTPROCESS
gl_FragColor.rgb=pow(gl_FragColor.rgb,vec3(2.2));
#endif
`;
U.IncludesShadersStore[Ml] = Al;
const Rl = "shadowOnlyPixelShader", yl = `precision highp float;
uniform vec4 vEyePosition;
uniform float alpha;
uniform vec3 shadowColor;
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=vec3(1.0,1.0,1.0);
#endif
vec3 diffuseBase=vec3(0.,0.,0.);
lightingInfo info;
float shadow=1.;
float glossiness=0.;
#include<lightFragment>[0..1]
vec4 color=vec4(shadowColor,(1.0-clamp(shadow,0.,1.))*alpha);
#include<fogFragment>
gl_FragColor=color;
#include<imageProcessingCompatibility>
#define CUSTOM_FRAGMENT_MAIN_END
}`;
U.ShadersStore[Rl] = yl;
const Cl = "shadowOnlyVertexShader", Il = `precision highp float;
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
uniform mat4 view;
uniform mat4 viewProjection;
#ifdef POINTSIZE
uniform float pointSize;
#endif
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#ifdef VERTEXCOLOR
varying vec4 vColor;
#endif
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
#include<instancesVertex>
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(position,1.0);
gl_Position=viewProjection*worldPos;
vPositionW=vec3(worldPos);
#ifdef NORMAL
vNormalW=normalize(vec3(finalWorld*vec4(normal,0.0)));
#endif
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#define CUSTOM_VERTEX_MAIN_END
}
`;
U.ShadersStore[Cl] = Il;
class Pl extends Hs {
  constructor() {
    super(), this.CLIPPLANE = !1, this.CLIPPLANE2 = !1, this.CLIPPLANE3 = !1, this.CLIPPLANE4 = !1, this.CLIPPLANE5 = !1, this.CLIPPLANE6 = !1, this.POINTSIZE = !1, this.FOG = !1, this.NORMAL = !1, this.NUM_BONE_INFLUENCERS = 0, this.BonesPerMesh = 0, this.INSTANCES = !1, this.IMAGEPROCESSINGPOSTPROCESS = !1, this.SKIPFINALCOLORCLAMP = !1, this.rebuild();
  }
}
class Li extends Wr {
  constructor(e, t) {
    super(e, t), this._needAlphaBlending = !0, this.shadowColor = se.Black();
  }
  needAlphaBlending() {
    return this._needAlphaBlending;
  }
  needAlphaTesting() {
    return !1;
  }
  getAlphaTestTexture() {
    return null;
  }
  get activeLight() {
    return this._activeLight;
  }
  set activeLight(e) {
    this._activeLight = e;
  }
  _getFirstShadowLightForMesh(e) {
    for (const t of e.lightSources)
      if (t.shadowEnabled)
        return t;
    return null;
  }
  isReadyForSubMesh(e, t, i) {
    var s;
    if (this.isFrozen && t.effect && t.effect._wasPreviouslyReady && t.effect._wasPreviouslyUsingInstances === i)
      return !0;
    t.materialDefines || (t.materialDefines = new Pl());
    const r = t.materialDefines, n = this.getScene();
    if (this._isReadyForSubMesh(t))
      return !0;
    const a = n.getEngine();
    if (this._activeLight) {
      for (const h of e.lightSources)
        if (h.shadowEnabled) {
          if (this._activeLight === h)
            break;
          const l = e.lightSources.indexOf(this._activeLight);
          l !== -1 && (e.lightSources.splice(l, 1), e.lightSources.splice(0, 0, this._activeLight));
          break;
        }
    }
    te.PrepareDefinesForFrameBoundValues(n, a, this, r, !!i), te.PrepareDefinesForMisc(e, n, !1, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(e), r), r._needNormals = te.PrepareDefinesForLights(n, e, r, !1, 1);
    const o = (s = this._getFirstShadowLightForMesh(e)) === null || s === void 0 ? void 0 : s.getShadowGenerator();
    if (this._needAlphaBlending = !0, o && o.getClassName && o.getClassName() === "CascadedShadowGenerator") {
      const h = o;
      this._needAlphaBlending = !h.autoCalcDepthBounds;
    }
    if (te.PrepareDefinesForAttributes(e, r, !1, !0), r.isDirty) {
      r.markAsProcessed(), n.resetCachedMaterial();
      const h = new qs();
      r.FOG && h.addFallback(1, "FOG"), te.HandleFallbacksForShadows(r, h, 1), r.NUM_BONE_INFLUENCERS > 0 && h.addCPUSkinningFallback(0, e), r.IMAGEPROCESSINGPOSTPROCESS = n.imageProcessingConfiguration.applyByPostProcess;
      const l = [g.PositionKind];
      r.NORMAL && l.push(g.NormalKind), te.PrepareAttributesForBones(l, e, r, h), te.PrepareAttributesForInstances(l, r);
      const u = "shadowOnly", d = r.toString(), f = ["world", "view", "viewProjection", "vEyePosition", "vLightsType", "vFogInfos", "vFogColor", "pointSize", "alpha", "shadowColor", "mBones"], _ = new Array(), E = new Array();
      ls(f), te.PrepareUniformsAndSamplersList({
        uniformsNames: f,
        uniformBuffersNames: E,
        samplers: _,
        defines: r,
        maxSimultaneousLights: 1
      }), t.setEffect(n.getEngine().createEffect(u, {
        attributes: l,
        uniformsNames: f,
        uniformBuffersNames: E,
        samplers: _,
        defines: d,
        fallbacks: h,
        onCompiled: this.onCompiled,
        onError: this.onError,
        indexParameters: { maxSimultaneousLights: 1 }
      }, a), r, this._materialContext);
    }
    return !t.effect || !t.effect.isReady() ? !1 : (r._renderId = n.getRenderId(), t.effect._wasPreviouslyReady = !0, t.effect._wasPreviouslyUsingInstances = !!i, !0);
  }
  bindForSubMesh(e, t, i) {
    const s = this.getScene(), r = i.materialDefines;
    if (!r)
      return;
    const n = i.effect;
    if (!!n) {
      if (this._activeEffect = n, this.bindOnlyWorldMatrix(e), this._activeEffect.setMatrix("viewProjection", s.getTransformMatrix()), te.BindBonesParameters(t, this._activeEffect), this._mustRebind(s, n) && (cs(n, this, s), this.pointsCloud && this._activeEffect.setFloat("pointSize", this.pointSize), this._activeEffect.setFloat("alpha", this.alpha), this._activeEffect.setColor3("shadowColor", this.shadowColor), s.bindEyePosition(n)), s.lightsEnabled) {
        te.BindLights(s, t, this._activeEffect, r, 1);
        const a = this._getFirstShadowLightForMesh(t);
        a && (a._renderId = -1);
      }
      (s.fogEnabled && t.applyFog && s.fogMode !== re.FOGMODE_NONE || r.SHADOWCSM0) && this._activeEffect.setMatrix("view", s.getViewMatrix()), te.BindFogParameters(s, t, this._activeEffect), this._afterBind(t, this._activeEffect);
    }
  }
  clone(e) {
    return ae.Clone(() => new Li(e, this.getScene()), this);
  }
  serialize() {
    const e = super.serialize();
    return e.customType = "BABYLON.ShadowOnlyMaterial", e;
  }
  getClassName() {
    return "ShadowOnlyMaterial";
  }
  static Parse(e, t, i) {
    return ae.Parse(() => new Li(e.name, t), e, t, i);
  }
}
st("BABYLON.ShadowOnlyMaterial", Li);
const Dl = {
  aspect: 300 / 150,
  enableDebugging: !1,
  enableShadows: !0
};
class Fl {
  constructor(e) {
    gt(this, "size", 9.5);
    this.config = { ...Dl, ...e }, this.create();
  }
  create(e) {
    this.destroy(), Object.assign(this.config, e);
    const { aspect: t, enableDebugging: i = !0, enableShadows: s } = this.config, r = 30;
    let n;
    this.box = new $("diceBox"), i ? (n = new N("diceBox_material"), n.alpha = 0.7, n.diffuseColor = new se(1, 1, 0)) : s && (n = new Li("shadowOnly", this.config.scene));
    const a = Ei("ground", {
      width: this.size * 2,
      height: 1,
      depth: this.size * 2
    }, this.config.scene);
    if (a.scaling = new p(t, 1, 1), a.material = n, a.receiveShadows = !0, a.setParent(this.box), i) {
      const o = Ei("wallTop", {
        width: this.size,
        height: r,
        depth: 1
      }, this.config.scene);
      o.position.y = r / 2, o.position.z = this.size / -2, o.scaling = new p(t, 1, 1), o.material = n, o.setParent(this.box);
      const h = Ei("wallRight", {
        width: 1,
        height: r,
        depth: this.size
      }, this.config.scene);
      h.position.x = this.size * t / 2, h.position.y = r / 2, h.material = n, h.setParent(this.box);
      const l = Ei("wallBottom", {
        width: this.size,
        height: r,
        depth: 1
      }, this.config.scene);
      l.position.y = r / 2, l.position.z = this.size / 2, l.scaling = new p(t, 1, 1), l.material = n, l.setParent(this.box);
      const u = Ei("wallLeft", {
        width: 1,
        height: r,
        depth: this.size
      }, this.config.scene);
      u.position.x = this.size * t / -2, u.position.y = r / 2, u.material = n, u.setParent(this.box);
    }
  }
  destroy() {
    this.box && this.box.dispose();
  }
}
var Zt;
(function(c) {
  c[c.Clean = 0] = "Clean", c[c.Stop = 1] = "Stop", c[c.Sync = 2] = "Sync", c[c.NoSync = 3] = "NoSync";
})(Zt || (Zt = {}));
class oe {
  static get ForceFullSceneLoadingForIncremental() {
    return we.ForceFullSceneLoadingForIncremental;
  }
  static set ForceFullSceneLoadingForIncremental(e) {
    we.ForceFullSceneLoadingForIncremental = e;
  }
  static get ShowLoadingScreen() {
    return we.ShowLoadingScreen;
  }
  static set ShowLoadingScreen(e) {
    we.ShowLoadingScreen = e;
  }
  static get loggingLevel() {
    return we.loggingLevel;
  }
  static set loggingLevel(e) {
    we.loggingLevel = e;
  }
  static get CleanBoneMatrixWeights() {
    return we.CleanBoneMatrixWeights;
  }
  static set CleanBoneMatrixWeights(e) {
    we.CleanBoneMatrixWeights = e;
  }
  static GetDefaultPlugin() {
    return oe._RegisteredPlugins[".babylon"];
  }
  static _GetPluginForExtension(e) {
    const t = oe._RegisteredPlugins[e];
    return t || (O.Warn("Unable to find a plugin to load " + e + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes"), oe.GetDefaultPlugin());
  }
  static _GetPluginForDirectLoad(e) {
    for (const t in oe._RegisteredPlugins) {
      const i = oe._RegisteredPlugins[t].plugin;
      if (i.canDirectLoad && i.canDirectLoad(e))
        return oe._RegisteredPlugins[t];
    }
    return oe.GetDefaultPlugin();
  }
  static _GetPluginForFilename(e) {
    const t = e.indexOf("?");
    t !== -1 && (e = e.substring(0, t));
    const i = e.lastIndexOf("."), s = e.substring(i, e.length).toLowerCase();
    return oe._GetPluginForExtension(s);
  }
  static _GetDirectLoad(e) {
    return e.substr(0, 5) === "data:" ? e.substr(5) : null;
  }
  static _FormatErrorMessage(e, t, i) {
    let s = "Unable to load from " + e.url;
    return t ? s += `: ${t}` : i && (s += `: ${i}`), s;
  }
  static _LoadData(e, t, i, s, r, n, a) {
    const o = oe._GetDirectLoad(e.url), h = a ? oe._GetPluginForExtension(a) : o ? oe._GetPluginForDirectLoad(e.url) : oe._GetPluginForFilename(e.url);
    let l;
    if (h.plugin.createPlugin !== void 0 ? l = h.plugin.createPlugin() : l = h.plugin, !l)
      throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
    if (oe.OnPluginActivatedObservable.notifyObservers(l), o && (l.canDirectLoad && l.canDirectLoad(e.url) || !Gs(e.url))) {
      if (l.directLoad) {
        const y = l.directLoad(t, o);
        y.then ? y.then((A) => {
          i(l, A);
        }).catch((A) => {
          r("Error in directLoad of _loadData: " + A, A);
        }) : i(l, y);
      } else
        i(l, o);
      return l;
    }
    const u = h.isBinary, d = (y, A) => {
      if (t.isDisposed) {
        r("Scene has been disposed");
        return;
      }
      i(l, y, A);
    };
    let f = null, _ = !1;
    const E = l.onDisposeObservable;
    E && E.add(() => {
      _ = !0, f && (f.abort(), f = null), n();
    });
    const m = () => {
      if (_)
        return;
      const y = (C, b) => {
        r(C == null ? void 0 : C.statusText, b);
      }, A = e.file || e.url;
      f = l.loadFile ? l.loadFile(t, A, d, s, u, y) : t._loadFile(A, d, s, !0, u, y);
    }, v = t.getEngine();
    let S = v.enableOfflineSupport;
    if (S) {
      let y = !1;
      for (const A of t.disableOfflineSupportExceptionRules)
        if (A.test(e.url)) {
          y = !0;
          break;
        }
      S = !y;
    }
    return S && I.OfflineProviderFactory ? t.offlineProvider = I.OfflineProviderFactory(e.url, m, v.disableManifestCheck) : m(), l;
  }
  static _GetFileInfo(e, t) {
    let i, s, r = null;
    if (!t)
      i = e, s = X.GetFilename(e), e = X.GetFolderPath(e);
    else if (t.name) {
      const n = t;
      i = `file:${n.name}`, s = n.name, r = n;
    } else if (typeof t == "string" && t.startsWith("data:"))
      i = t, s = "";
    else {
      const n = t;
      if (n.substr(0, 1) === "/")
        return X.Error("Wrong sceneFilename parameter"), null;
      i = e + n, s = n;
    }
    return {
      url: i,
      rootUrl: e,
      name: s,
      file: r
    };
  }
  static GetPluginForExtension(e) {
    return oe._GetPluginForExtension(e).plugin;
  }
  static IsPluginForExtensionAvailable(e) {
    return !!oe._RegisteredPlugins[e];
  }
  static RegisterPlugin(e) {
    if (typeof e.extensions == "string") {
      const t = e.extensions;
      oe._RegisteredPlugins[t.toLowerCase()] = {
        plugin: e,
        isBinary: !1
      };
    } else {
      const t = e.extensions;
      Object.keys(t).forEach((i) => {
        oe._RegisteredPlugins[i.toLowerCase()] = {
          plugin: e,
          isBinary: t[i].isBinary
        };
      });
    }
  }
  static ImportMesh(e, t, i = "", s = fe.LastCreatedScene, r = null, n = null, a = null, o = null) {
    if (!s)
      return O.Error("No scene available to import mesh to"), null;
    const h = oe._GetFileInfo(t, i);
    if (!h)
      return null;
    const l = {};
    s.addPendingData(l);
    const u = () => {
      s.removePendingData(l);
    }, d = (E, m) => {
      const v = oe._FormatErrorMessage(h, E, m);
      a ? a(s, v, new Wt(v, oi.SceneLoaderError, m)) : O.Error(v), u();
    }, f = n ? (E) => {
      try {
        n(E);
      } catch (m) {
        d("Error in onProgress callback: " + m, m);
      }
    } : void 0, _ = (E, m, v, S, y, A, C) => {
      if (s.importedMeshesFiles.push(h.url), r)
        try {
          r(E, m, v, S, y, A, C);
        } catch (b) {
          d("Error in onSuccess callback: " + b, b);
        }
      s.removePendingData(l);
    };
    return oe._LoadData(h, s, (E, m, v) => {
      if (E.rewriteRootURL && (h.rootUrl = E.rewriteRootURL(h.rootUrl, v)), E.importMesh) {
        const S = E, y = new Array(), A = new Array(), C = new Array();
        if (!S.importMesh(e, s, m, h.rootUrl, y, A, C, d))
          return;
        s.loadingPluginName = E.name, _(y, A, C, [], [], [], []);
      } else
        E.importMeshAsync(e, s, m, h.rootUrl, f, h.name).then((y) => {
          s.loadingPluginName = E.name, _(y.meshes, y.particleSystems, y.skeletons, y.animationGroups, y.transformNodes, y.geometries, y.lights);
        }).catch((y) => {
          d(y.message, y);
        });
    }, f, d, u, o);
  }
  static ImportMeshAsync(e, t, i = "", s = fe.LastCreatedScene, r = null, n = null) {
    return new Promise((a, o) => {
      oe.ImportMesh(e, t, i, s, (h, l, u, d, f, _, E) => {
        a({
          meshes: h,
          particleSystems: l,
          skeletons: u,
          animationGroups: d,
          transformNodes: f,
          geometries: _,
          lights: E
        });
      }, r, (h, l, u) => {
        o(u || new Error(l));
      }, n);
    });
  }
  static Load(e, t = "", i = fe.LastCreatedEngine, s = null, r = null, n = null, a = null) {
    return i ? oe.Append(e, t, new re(i), s, r, n, a) : (X.Error("No engine available"), null);
  }
  static LoadAsync(e, t = "", i = fe.LastCreatedEngine, s = null, r = null) {
    return new Promise((n, a) => {
      oe.Load(e, t, i, (o) => {
        n(o);
      }, s, (o, h, l) => {
        a(l || new Error(h));
      }, r);
    });
  }
  static Append(e, t = "", i = fe.LastCreatedScene, s = null, r = null, n = null, a = null) {
    if (!i)
      return O.Error("No scene available to append to"), null;
    const o = oe._GetFileInfo(e, t);
    if (!o)
      return null;
    const h = {};
    i.addPendingData(h);
    const l = () => {
      i.removePendingData(h);
    };
    oe.ShowLoadingScreen && !this._ShowingLoadingScreen && (this._ShowingLoadingScreen = !0, i.getEngine().displayLoadingUI(), i.executeWhenReady(() => {
      i.getEngine().hideLoadingUI(), this._ShowingLoadingScreen = !1;
    }));
    const u = (_, E) => {
      const m = oe._FormatErrorMessage(o, _, E);
      n ? n(i, m, new Wt(m, oi.SceneLoaderError, E)) : O.Error(m), l();
    }, d = r ? (_) => {
      try {
        r(_);
      } catch (E) {
        u("Error in onProgress callback", E);
      }
    } : void 0, f = () => {
      if (s)
        try {
          s(i);
        } catch (_) {
          u("Error in onSuccess callback", _);
        }
      i.removePendingData(h);
    };
    return oe._LoadData(o, i, (_, E) => {
      if (_.load) {
        if (!_.load(i, E, o.rootUrl, u))
          return;
        i.loadingPluginName = _.name, f();
      } else
        _.loadAsync(i, E, o.rootUrl, d, o.name).then(() => {
          i.loadingPluginName = _.name, f();
        }).catch((v) => {
          u(v.message, v);
        });
    }, d, u, l, a);
  }
  static AppendAsync(e, t = "", i = fe.LastCreatedScene, s = null, r = null) {
    return new Promise((n, a) => {
      oe.Append(e, t, i, (o) => {
        n(o);
      }, s, (o, h, l) => {
        a(l || new Error(h));
      }, r);
    });
  }
  static LoadAssetContainer(e, t = "", i = fe.LastCreatedScene, s = null, r = null, n = null, a = null) {
    if (!i)
      return O.Error("No scene available to load asset container to"), null;
    const o = oe._GetFileInfo(e, t);
    if (!o)
      return null;
    const h = {};
    i.addPendingData(h);
    const l = () => {
      i.removePendingData(h);
    }, u = (_, E) => {
      const m = oe._FormatErrorMessage(o, _, E);
      n ? n(i, m, new Wt(m, oi.SceneLoaderError, E)) : O.Error(m), l();
    }, d = r ? (_) => {
      try {
        r(_);
      } catch (E) {
        u("Error in onProgress callback", E);
      }
    } : void 0, f = (_) => {
      if (s)
        try {
          s(_);
        } catch (E) {
          u("Error in onSuccess callback", E);
        }
      i.removePendingData(h);
    };
    return oe._LoadData(o, i, (_, E) => {
      if (_.loadAssetContainer) {
        const v = _.loadAssetContainer(i, E, o.rootUrl, u);
        if (!v)
          return;
        i.loadingPluginName = _.name, f(v);
      } else
        _.loadAssetContainerAsync ? _.loadAssetContainerAsync(i, E, o.rootUrl, d, o.name).then((v) => {
          i.loadingPluginName = _.name, f(v);
        }).catch((v) => {
          u(v.message, v);
        }) : u("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
    }, d, u, l, a);
  }
  static LoadAssetContainerAsync(e, t = "", i = fe.LastCreatedScene, s = null, r = null) {
    return new Promise((n, a) => {
      oe.LoadAssetContainer(e, t, i, (o) => {
        n(o);
      }, s, (o, h, l) => {
        a(l || new Error(h));
      }, r);
    });
  }
  static ImportAnimations(e, t = "", i = fe.LastCreatedScene, s = !0, r = Zt.Clean, n = null, a = null, o = null, h = null, l = null) {
    if (!i) {
      O.Error("No scene available to load animations to");
      return;
    }
    if (s) {
      for (const _ of i.animatables)
        _.reset();
      i.stopAllAnimations(), i.animationGroups.slice().forEach((_) => {
        _.dispose();
      }), i.getNodes().forEach((_) => {
        _.animations && (_.animations = []);
      });
    } else
      switch (r) {
        case Zt.Clean:
          i.animationGroups.slice().forEach((f) => {
            f.dispose();
          });
          break;
        case Zt.Stop:
          i.animationGroups.forEach((f) => {
            f.stop();
          });
          break;
        case Zt.Sync:
          i.animationGroups.forEach((f) => {
            f.reset(), f.restart();
          });
          break;
        case Zt.NoSync:
          break;
        default:
          O.Error("Unknown animation group loading mode value '" + r + "'");
          return;
      }
    const u = i.animatables.length, d = (f) => {
      f.mergeAnimationsTo(i, i.animatables.slice(u), n), f.dispose(), i.onAnimationFileImportedObservable.notifyObservers(i), a && a(i);
    };
    this.LoadAssetContainer(e, t, i, d, o, h, l);
  }
  static ImportAnimationsAsync(e, t = "", i = fe.LastCreatedScene, s = !0, r = Zt.Clean, n = null, a = null, o = null, h = null, l = null) {
    return new Promise((u, d) => {
      oe.ImportAnimations(e, t, i, s, r, n, (f) => {
        u(f);
      }, o, (f, _, E) => {
        d(E || new Error(_));
      }, l);
    });
  }
}
oe.NO_LOGGING = 0;
oe.MINIMAL_LOGGING = 1;
oe.SUMMARY_LOGGING = 2;
oe.DETAILED_LOGGING = 3;
oe.OnPluginActivatedObservable = new w();
oe._RegisteredPlugins = {};
oe._ShowingLoadingScreen = !1;
class _e {
  constructor(e, t, i = Number.MAX_VALUE) {
    this.origin = e, this.direction = t, this.length = i;
  }
  clone() {
    return new _e(this.origin.clone(), this.direction.clone(), this.length);
  }
  intersectsBoxMinMax(e, t, i = 0) {
    const s = _e._TmpVector3[0].copyFromFloats(e.x - i, e.y - i, e.z - i), r = _e._TmpVector3[1].copyFromFloats(t.x + i, t.y + i, t.z + i);
    let n = 0, a = Number.MAX_VALUE, o, h, l, u;
    if (Math.abs(this.direction.x) < 1e-7) {
      if (this.origin.x < s.x || this.origin.x > r.x)
        return !1;
    } else if (o = 1 / this.direction.x, h = (s.x - this.origin.x) * o, l = (r.x - this.origin.x) * o, l === -1 / 0 && (l = 1 / 0), h > l && (u = h, h = l, l = u), n = Math.max(h, n), a = Math.min(l, a), n > a)
      return !1;
    if (Math.abs(this.direction.y) < 1e-7) {
      if (this.origin.y < s.y || this.origin.y > r.y)
        return !1;
    } else if (o = 1 / this.direction.y, h = (s.y - this.origin.y) * o, l = (r.y - this.origin.y) * o, l === -1 / 0 && (l = 1 / 0), h > l && (u = h, h = l, l = u), n = Math.max(h, n), a = Math.min(l, a), n > a)
      return !1;
    if (Math.abs(this.direction.z) < 1e-7) {
      if (this.origin.z < s.z || this.origin.z > r.z)
        return !1;
    } else if (o = 1 / this.direction.z, h = (s.z - this.origin.z) * o, l = (r.z - this.origin.z) * o, l === -1 / 0 && (l = 1 / 0), h > l && (u = h, h = l, l = u), n = Math.max(h, n), a = Math.min(l, a), n > a)
      return !1;
    return !0;
  }
  intersectsBox(e, t = 0) {
    return this.intersectsBoxMinMax(e.minimum, e.maximum, t);
  }
  intersectsSphere(e, t = 0) {
    const i = e.center.x - this.origin.x, s = e.center.y - this.origin.y, r = e.center.z - this.origin.z, n = i * i + s * s + r * r, a = e.radius + t, o = a * a;
    if (n <= o)
      return !0;
    const h = i * this.direction.x + s * this.direction.y + r * this.direction.z;
    return h < 0 ? !1 : n - h * h <= o;
  }
  intersectsTriangle(e, t, i) {
    const s = _e._TmpVector3[0], r = _e._TmpVector3[1], n = _e._TmpVector3[2], a = _e._TmpVector3[3], o = _e._TmpVector3[4];
    t.subtractToRef(e, s), i.subtractToRef(e, r), p.CrossToRef(this.direction, r, n);
    const h = p.Dot(s, n);
    if (h === 0)
      return null;
    const l = 1 / h;
    this.origin.subtractToRef(e, a);
    const u = p.Dot(a, n) * l;
    if (u < 0 || u > 1)
      return null;
    p.CrossToRef(a, s, o);
    const d = p.Dot(this.direction, o) * l;
    if (d < 0 || u + d > 1)
      return null;
    const f = p.Dot(r, o) * l;
    return f > this.length ? null : new Ns(1 - u - d, u, f);
  }
  intersectsPlane(e) {
    let t;
    const i = p.Dot(e.normal, this.direction);
    if (Math.abs(i) < 999999997475243e-21)
      return null;
    {
      const s = p.Dot(e.normal, this.origin);
      return t = (-e.d - s) / i, t < 0 ? t < -999999997475243e-21 ? null : 0 : t;
    }
  }
  intersectsAxis(e, t = 0) {
    switch (e) {
      case "y": {
        const i = (this.origin.y - t) / this.direction.y;
        return i > 0 ? null : new p(this.origin.x + this.direction.x * -i, t, this.origin.z + this.direction.z * -i);
      }
      case "x": {
        const i = (this.origin.x - t) / this.direction.x;
        return i > 0 ? null : new p(t, this.origin.y + this.direction.y * -i, this.origin.z + this.direction.z * -i);
      }
      case "z": {
        const i = (this.origin.z - t) / this.direction.z;
        return i > 0 ? null : new p(this.origin.x + this.direction.x * -i, this.origin.y + this.direction.y * -i, t);
      }
      default:
        return null;
    }
  }
  intersectsMesh(e, t) {
    const i = D.Matrix[0];
    return e.getWorldMatrix().invertToRef(i), this._tmpRay ? _e.TransformToRef(this, i, this._tmpRay) : this._tmpRay = _e.Transform(this, i), e.intersects(this._tmpRay, t);
  }
  intersectsMeshes(e, t, i) {
    i ? i.length = 0 : i = [];
    for (let s = 0; s < e.length; s++) {
      const r = this.intersectsMesh(e[s], t);
      r.hit && i.push(r);
    }
    return i.sort(this._comparePickingInfo), i;
  }
  _comparePickingInfo(e, t) {
    return e.distance < t.distance ? -1 : e.distance > t.distance ? 1 : 0;
  }
  intersectionSegment(e, t, i) {
    const s = this.origin, r = D.Vector3[0], n = D.Vector3[1], a = D.Vector3[2], o = D.Vector3[3];
    t.subtractToRef(e, r), this.direction.scaleToRef(_e._Rayl, a), s.addToRef(a, n), e.subtractToRef(s, o);
    const h = p.Dot(r, r), l = p.Dot(r, a), u = p.Dot(a, a), d = p.Dot(r, o), f = p.Dot(a, o), _ = h * u - l * l;
    let E, m = _, v, S = _;
    _ < _e._Smallnum ? (E = 0, m = 1, v = f, S = u) : (E = l * f - u * d, v = h * f - l * d, E < 0 ? (E = 0, v = f, S = u) : E > m && (E = m, v = f + l, S = u)), v < 0 ? (v = 0, -d < 0 ? E = 0 : -d > h ? E = m : (E = -d, m = h)) : v > S && (v = S, -d + l < 0 ? E = 0 : -d + l > h ? E = m : (E = -d + l, m = h));
    const y = Math.abs(E) < _e._Smallnum ? 0 : E / m, A = Math.abs(v) < _e._Smallnum ? 0 : v / S, C = D.Vector3[4];
    a.scaleToRef(A, C);
    const b = D.Vector3[5];
    r.scaleToRef(y, b), b.addInPlace(o);
    const M = D.Vector3[6];
    return b.subtractToRef(C, M), A > 0 && A <= this.length && M.lengthSquared() < i * i ? b.length() : -1;
  }
  update(e, t, i, s, r, n, a, o = !1) {
    if (o) {
      _e._RayDistant || (_e._RayDistant = _e.Zero()), _e._RayDistant.unprojectRayToRef(e, t, i, s, x.IdentityReadOnly, n, a);
      const h = D.Matrix[0];
      r.invertToRef(h), _e.TransformToRef(_e._RayDistant, h, this);
    } else
      this.unprojectRayToRef(e, t, i, s, r, n, a);
    return this;
  }
  static Zero() {
    return new _e(p.Zero(), p.Zero());
  }
  static CreateNew(e, t, i, s, r, n, a) {
    return _e.Zero().update(e, t, i, s, r, n, a);
  }
  static CreateNewFromTo(e, t, i = x.IdentityReadOnly) {
    const s = t.subtract(e), r = Math.sqrt(s.x * s.x + s.y * s.y + s.z * s.z);
    return s.normalize(), _e.Transform(new _e(e, s, r), i);
  }
  static Transform(e, t) {
    const i = new _e(new p(0, 0, 0), new p(0, 0, 0));
    return _e.TransformToRef(e, t, i), i;
  }
  static TransformToRef(e, t, i) {
    p.TransformCoordinatesToRef(e.origin, t, i.origin), p.TransformNormalToRef(e.direction, t, i.direction), i.length = e.length;
    const s = i.direction, r = s.length();
    if (!(r === 0 || r === 1)) {
      const n = 1 / r;
      s.x *= n, s.y *= n, s.z *= n, i.length *= r;
    }
  }
  unprojectRayToRef(e, t, i, s, r, n, a) {
    var o;
    const h = D.Matrix[0];
    r.multiplyToRef(n, h), h.multiplyToRef(a, h), h.invert();
    const l = D.Vector3[0];
    l.x = e / i * 2 - 1, l.y = -(t / s * 2 - 1), l.z = !((o = fe.LastCreatedEngine) === null || o === void 0) && o.isNDCHalfZRange ? 0 : -1;
    const u = D.Vector3[1].copyFromFloats(l.x, l.y, 1 - 1e-8), d = D.Vector3[2], f = D.Vector3[3];
    p._UnprojectFromInvertedMatrixToRef(l, h, d), p._UnprojectFromInvertedMatrixToRef(u, h, f), this.origin.copyFrom(d), f.subtractToRef(d, this.direction), this.direction.normalize();
  }
}
_e._TmpVector3 = Ye.BuildArray(6, p.Zero);
_e._RayDistant = _e.Zero();
_e._Smallnum = 1e-8;
_e._Rayl = 1e9;
re.prototype.createPickingRay = function(c, e, t, i, s = !1) {
  const r = _e.Zero();
  return this.createPickingRayToRef(c, e, t, r, i, s), r;
};
re.prototype.createPickingRayToRef = function(c, e, t, i, s, r = !1, n = !1) {
  const a = this.getEngine();
  if (!s) {
    if (!this.activeCamera)
      return this;
    s = this.activeCamera;
  }
  const h = s.viewport.toGlobal(a.getRenderWidth(), a.getRenderHeight());
  return c = c / a.getHardwareScalingLevel() - h.x, e = e / a.getHardwareScalingLevel() - (a.getRenderHeight() - h.y - h.height), i.update(c, e, h.width, h.height, t || x.IdentityReadOnly, r ? x.IdentityReadOnly : s.getViewMatrix(), s.getProjectionMatrix(), n), this;
};
re.prototype.createPickingRayInCameraSpace = function(c, e, t) {
  const i = _e.Zero();
  return this.createPickingRayInCameraSpaceToRef(c, e, i, t), i;
};
re.prototype.createPickingRayInCameraSpaceToRef = function(c, e, t, i) {
  if (!zt)
    return this;
  const s = this.getEngine();
  if (!i) {
    if (!this.activeCamera)
      throw new Error("Active camera not set");
    i = this.activeCamera;
  }
  const n = i.viewport.toGlobal(s.getRenderWidth(), s.getRenderHeight()), a = x.Identity();
  return c = c / s.getHardwareScalingLevel() - n.x, e = e / s.getHardwareScalingLevel() - (s.getRenderHeight() - n.y - n.height), t.update(c, e, n.width, n.height, a, a, i.getProjectionMatrix()), this;
};
re.prototype._internalPickForMesh = function(c, e, t, i, s, r, n, a) {
  const o = e(i, t.enableDistantPicking), h = t.intersects(o, s, n, r, i, a);
  return !h || !h.hit || !s && c != null && h.distance >= c.distance ? null : h;
};
re.prototype._internalPick = function(c, e, t, i, s) {
  let r = null;
  for (let n = 0; n < this.meshes.length; n++) {
    const a = this.meshes[n];
    if (e) {
      if (!e(a))
        continue;
    } else if (!a.isEnabled() || !a.isVisible || !a.isPickable)
      continue;
    const o = a.getWorldMatrix();
    if (a.hasThinInstances && a.thinInstanceEnablePicking) {
      const h = this._internalPickForMesh(r, c, a, o, !0, !0, s);
      if (h) {
        if (i)
          return h;
        const l = D.Matrix[1], u = a.thinInstanceGetWorldMatrices();
        for (let d = 0; d < u.length; d++) {
          u[d].multiplyToRef(o, l);
          const _ = this._internalPickForMesh(r, c, a, l, t, i, s, !0);
          if (_ && (r = _, r.thinInstanceIndex = d, t))
            return r;
        }
      }
    } else {
      const h = this._internalPickForMesh(r, c, a, o, t, i, s);
      if (h && (r = h, t))
        return r;
    }
  }
  return r || new zt();
};
re.prototype._internalMultiPick = function(c, e, t) {
  if (!zt)
    return null;
  const i = new Array();
  for (let s = 0; s < this.meshes.length; s++) {
    const r = this.meshes[s];
    if (e) {
      if (!e(r))
        continue;
    } else if (!r.isEnabled() || !r.isVisible || !r.isPickable)
      continue;
    const n = r.getWorldMatrix();
    if (r.hasThinInstances && r.thinInstanceEnablePicking) {
      if (this._internalPickForMesh(null, c, r, n, !0, !0, t)) {
        const o = D.Matrix[1], h = r.thinInstanceGetWorldMatrices();
        for (let l = 0; l < h.length; l++) {
          h[l].multiplyToRef(n, o);
          const d = this._internalPickForMesh(null, c, r, o, !1, !1, t, !0);
          d && (d.thinInstanceIndex = l, i.push(d));
        }
      }
    } else {
      const a = this._internalPickForMesh(null, c, r, n, !1, !1, t);
      a && i.push(a);
    }
  }
  return i;
};
re.prototype.pickWithBoundingInfo = function(c, e, t, i, s) {
  if (!zt)
    return null;
  const r = this._internalPick((n) => (this._tempPickingRay || (this._tempPickingRay = _e.Zero()), this.createPickingRayToRef(c, e, n, this._tempPickingRay, s || null), this._tempPickingRay), t, i, !0);
  return r && (r.ray = this.createPickingRay(c, e, x.Identity(), s || null)), r;
};
Object.defineProperty(re.prototype, "_pickingAvailable", {
  get: () => !0,
  enumerable: !1,
  configurable: !1
});
re.prototype.pick = function(c, e, t, i, s, r, n = !1) {
  const a = this._internalPick((o, h) => (this._tempPickingRay || (this._tempPickingRay = _e.Zero()), this.createPickingRayToRef(c, e, o, this._tempPickingRay, s || null, !1, h), this._tempPickingRay), t, i, !1, r);
  return a && (a.ray = this.createPickingRay(c, e, x.Identity(), s || null)), a;
};
re.prototype.pickWithRay = function(c, e, t, i) {
  const s = this._internalPick((r) => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = x.Identity()), r.invertToRef(this._pickWithRayInverseMatrix), this._cachedRayForTransform || (this._cachedRayForTransform = _e.Zero()), _e.TransformToRef(c, this._pickWithRayInverseMatrix, this._cachedRayForTransform), this._cachedRayForTransform), e, t, !1, i);
  return s && (s.ray = c), s;
};
re.prototype.multiPick = function(c, e, t, i, s) {
  return this._internalMultiPick((r) => this.createPickingRay(c, e, r, i || null), t, s);
};
re.prototype.multiPickWithRay = function(c, e, t) {
  return this._internalMultiPick((i) => (this._pickWithRayInverseMatrix || (this._pickWithRayInverseMatrix = x.Identity()), i.invertToRef(this._pickWithRayInverseMatrix), this._cachedRayForTransform || (this._cachedRayForTransform = _e.Zero()), _e.TransformToRef(c, this._pickWithRayInverseMatrix, this._cachedRayForTransform), this._cachedRayForTransform), e, t);
};
q.prototype.getForwardRay = function(c = 100, e, t) {
  return this.getForwardRayToRef(new _e(p.Zero(), p.Zero(), c), c, e, t);
};
q.prototype.getForwardRayToRef = function(c, e = 100, t, i) {
  return t || (t = this.getWorldMatrix()), c.length = e, i ? c.origin.copyFrom(i) : c.origin.copyFrom(this.position), D.Vector3[2].set(0, 0, this._scene.useRightHandedSystem ? -1 : 1), p.TransformNormalToRef(D.Vector3[2], t, D.Vector3[3]), p.NormalizeToRef(D.Vector3[3], c.direction), c;
};
var wl = function(c, e, t) {
  for (var i in e)
    if (c.name === e[i])
      return t.push(c.id), !0;
  return c.parentId && t.indexOf(c.parentId) !== -1 ? (t.push(c.id), !0) : !1;
}, Zi = function(c, e) {
  return c + " of " + (e ? e.file + " from " + e.name + " version: " + e.version + ", exporter version: " + e.exporter_version : "unknown");
};
oe.RegisterPlugin({
  name: "babylon.js",
  extensions: ".json",
  canDirectLoad: function(c) {
    return c.indexOf("json") !== -1, !0;
  },
  importMesh: function(c, e, t, i, s, r, n, a) {
    var o = "importMesh has failed JSON parse";
    try {
      var h = JSON.parse(t);
      h.physicsEnabled = !1, h == null || h.meshes.map((S) => delete S.physicsImpostor), o = "";
      var l = oe.loggingLevel === oe.DETAILED_LOGGING;
      c ? Array.isArray(c) || (c = [c]) : c = null;
      var u = new Array();
      if (h.meshes !== void 0 && h.meshes !== null) {
        var d, f;
        for (d = 0, f = h.meshes.length; d < f; d++) {
          var _ = h.meshes[d];
          if (c === null || wl(_, c, u)) {
            c !== null && delete c[c.indexOf(_.name)];
            var E = W.Parse(_, e, i);
            s.push(E), o += `
	Mesh ` + E.toString(l);
          }
        }
        var m;
        for (d = 0, f = e.meshes.length; d < f; d++)
          m = e.meshes[d], m._waitingParentId && (m.parent = e.getLastEntryByID(m._waitingParentId), m._waitingParentId = null), m.computeWorldMatrix(!0);
      }
      return !0;
    } catch (S) {
      var v = Zi("importMesh", h ? h.producer : "Unknown") + o;
      if (a)
        a(v, S);
      else
        throw O.Log(v), S;
    } finally {
      o !== null && oe.loggingLevel !== oe.NO_LOGGING && O.Log(Zi("importMesh", h ? h.producer : "Unknown") + (oe.loggingLevel !== oe.MINIMAL_LOGGING ? o : ""));
    }
    return !1;
  },
  load: function(c, e, t, i) {
    var s = "importScene has failed JSON parse";
    try {
      var r = JSON.parse(e);
      s = "", r.clearColor !== void 0 && r.clearColor !== null && (c.clearColor = Color4.FromArray(r.clearColor));
      var n = loadAssetContainer(c, e, t, i, !0);
      return !!n;
    } catch (o) {
      var a = Zi("importScene", r ? r.producer : "Unknown") + s;
      if (i)
        i(a, o);
      else
        throw O.Log(a), o;
    } finally {
      s !== null && oe.loggingLevel !== oe.NO_LOGGING && O.Log(Zi("importScene", r ? r.producer : "Unknown") + (oe.loggingLevel !== oe.MINIMAL_LOGGING ? s : ""));
    }
    return !1;
  },
  loadAssetContainer: function(c, e, t, i) {
    var s = loadAssetContainer(c, e, t, i);
    return s;
  }
});
W._instancedMeshFactory = (c, e) => {
  const t = new Ol(c, e);
  if (e.instancedBuffers) {
    t.instancedBuffers = {};
    for (const i in e.instancedBuffers)
      t.instancedBuffers[i] = e.instancedBuffers[i];
  }
  return t;
};
class Ol extends ot {
  constructor(e, t) {
    super(e, t.getScene()), this._indexInSourceMeshInstanceArray = -1, this._distanceToCamera = 0, t.addInstance(this), this._sourceMesh = t, this._unIndexed = t._unIndexed, this.position.copyFrom(t.position), this.rotation.copyFrom(t.rotation), this.scaling.copyFrom(t.scaling), t.rotationQuaternion && (this.rotationQuaternion = t.rotationQuaternion.clone()), this.animations = t.animations.slice();
    for (const i of t.getAnimationRanges())
      i != null && this.createAnimationRange(i.name, i.from, i.to);
    this.infiniteDistance = t.infiniteDistance, this.setPivotMatrix(t.getPivotMatrix()), this.refreshBoundingInfo(!0, !0), this._syncSubMeshes();
  }
  getClassName() {
    return "InstancedMesh";
  }
  get lightSources() {
    return this._sourceMesh._lightSources;
  }
  _resyncLightSources() {
  }
  _resyncLightSource() {
  }
  _removeLightSource() {
  }
  get receiveShadows() {
    return this._sourceMesh.receiveShadows;
  }
  get material() {
    return this._sourceMesh.material;
  }
  get visibility() {
    return this._sourceMesh.visibility;
  }
  get skeleton() {
    return this._sourceMesh.skeleton;
  }
  get renderingGroupId() {
    return this._sourceMesh.renderingGroupId;
  }
  set renderingGroupId(e) {
    !this._sourceMesh || e === this._sourceMesh.renderingGroupId || O.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
  }
  getTotalVertices() {
    return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
  }
  getTotalIndices() {
    return this._sourceMesh.getTotalIndices();
  }
  get sourceMesh() {
    return this._sourceMesh;
  }
  createInstance(e) {
    return this._sourceMesh.createInstance(e);
  }
  isReady(e = !1) {
    return this._sourceMesh.isReady(e, !0);
  }
  getVerticesData(e, t) {
    return this._sourceMesh.getVerticesData(e, t);
  }
  setVerticesData(e, t, i, s) {
    return this.sourceMesh && this.sourceMesh.setVerticesData(e, t, i, s), this.sourceMesh;
  }
  updateVerticesData(e, t, i, s) {
    return this.sourceMesh && this.sourceMesh.updateVerticesData(e, t, i, s), this.sourceMesh;
  }
  setIndices(e, t = null) {
    return this.sourceMesh && this.sourceMesh.setIndices(e, t), this.sourceMesh;
  }
  isVerticesDataPresent(e) {
    return this._sourceMesh.isVerticesDataPresent(e);
  }
  getIndices() {
    return this._sourceMesh.getIndices();
  }
  get _positions() {
    return this._sourceMesh._positions;
  }
  refreshBoundingInfo(e = !1, t = !1) {
    if (this.hasBoundingInfo && this.getBoundingInfo().isLocked)
      return this;
    const i = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
    return this._refreshBoundingInfo(this._sourceMesh._getPositionData(e, t), i), this;
  }
  _preActivate() {
    return this._currentLOD && this._currentLOD._preActivate(), this;
  }
  _activate(e, t) {
    if (super._activate(e, t), this._sourceMesh.subMeshes || O.Warn("Instances should only be created for meshes with geometry."), this._currentLOD) {
      if (this._currentLOD._getWorldMatrixDeterminant() >= 0 != this._getWorldMatrixDeterminant() >= 0)
        return this._internalAbstractMeshDataInfo._actAsRegularMesh = !0, !0;
      if (this._internalAbstractMeshDataInfo._actAsRegularMesh = !1, this._currentLOD._registerInstanceForRenderId(this, e), t) {
        if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate)
          return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = !0, !0;
      } else if (!this._currentLOD._internalAbstractMeshDataInfo._isActive)
        return this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = !0, !0;
    }
    return !1;
  }
  _postActivate() {
    this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup ? (this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer), this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix())) : this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup && this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
  }
  getWorldMatrix() {
    if (this._currentLOD && this._currentLOD.billboardMode !== $.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
      this._billboardWorldMatrix || (this._billboardWorldMatrix = new x());
      const e = this._currentLOD._masterMesh;
      return this._currentLOD._masterMesh = this, D.Vector3[7].copyFrom(this._currentLOD.position), this._currentLOD.position.set(0, 0, 0), this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(!0)), this._currentLOD.position.copyFrom(D.Vector3[7]), this._currentLOD._masterMesh = e, this._billboardWorldMatrix;
    }
    return super.getWorldMatrix();
  }
  get isAnInstance() {
    return !0;
  }
  getLOD(e) {
    if (!e)
      return this;
    const t = this.sourceMesh.getLODLevels();
    if (!t || t.length === 0)
      this._currentLOD = this.sourceMesh;
    else {
      const i = this.getBoundingInfo();
      this._currentLOD = this.sourceMesh.getLOD(e, i.boundingSphere);
    }
    return this._currentLOD;
  }
  _preActivateForIntermediateRendering(e) {
    return this.sourceMesh._preActivateForIntermediateRendering(e);
  }
  _syncSubMeshes() {
    if (this.releaseSubMeshes(), this._sourceMesh.subMeshes)
      for (let e = 0; e < this._sourceMesh.subMeshes.length; e++)
        this._sourceMesh.subMeshes[e].clone(this, this._sourceMesh);
    return this;
  }
  _generatePointsArray() {
    return this._sourceMesh._generatePointsArray();
  }
  _updateBoundingInfo() {
    return this.hasBoundingInfo ? this.getBoundingInfo().update(this.worldMatrixFromCache) : this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache), this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache), this;
  }
  clone(e, t = null, i, s) {
    const r = (s || this._sourceMesh).createInstance(e);
    if (Us.DeepCopy(this, r, [
      "name",
      "subMeshes",
      "uniqueId",
      "parent",
      "lightSources",
      "receiveShadows",
      "material",
      "visibility",
      "skeleton",
      "sourceMesh",
      "isAnInstance",
      "facetNb",
      "isFacetDataEnabled",
      "isBlocked",
      "useBones",
      "hasInstances",
      "collider",
      "edgesRenderer",
      "forward",
      "up",
      "right",
      "absolutePosition",
      "absoluteScaling",
      "absoluteRotationQuaternion",
      "isWorldMatrixFrozen",
      "nonUniformScaling",
      "behaviors",
      "worldMatrixFromCache",
      "hasThinInstances",
      "hasBoundingInfo"
    ], []), this.refreshBoundingInfo(), t && (r.parent = t), !i)
      for (let n = 0; n < this.getScene().meshes.length; n++) {
        const a = this.getScene().meshes[n];
        a.parent === this && a.clone(a.name, r);
      }
    return r.computeWorldMatrix(!0), this.onClonedObservable.notifyObservers(r), r;
  }
  dispose(e, t = !1) {
    this._sourceMesh.removeInstance(this), super.dispose(e, t);
  }
  _serializeAsParent(e) {
    super._serializeAsParent(e), e.parentId = this._sourceMesh.uniqueId, e.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
  }
  instantiateHierarchy(e = null, t, i) {
    const s = this.clone("Clone of " + (this.name || this.id), e || this.parent, !0, t && t.newSourcedMesh);
    s && i && i(this, s);
    for (const r of this.getChildTransformNodes(!0))
      r.instantiateHierarchy(s, t, i);
    return s;
  }
}
W.prototype.registerInstancedBuffer = function(c, e) {
  var t, i;
  if ((i = (t = this._userInstancedBuffersStorage) === null || t === void 0 ? void 0 : t.vertexBuffers[c]) === null || i === void 0 || i.dispose(), !this.instancedBuffers) {
    this.instancedBuffers = {};
    for (const s of this.instances)
      s.instancedBuffers = {};
    this._userInstancedBuffersStorage || (this._userInstancedBuffersStorage = {
      data: {},
      vertexBuffers: {},
      strides: {},
      sizes: {},
      vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
    });
  }
  this.instancedBuffers[c] = null, this._userInstancedBuffersStorage.strides[c] = e, this._userInstancedBuffersStorage.sizes[c] = e * 32, this._userInstancedBuffersStorage.data[c] = new Float32Array(this._userInstancedBuffersStorage.sizes[c]), this._userInstancedBuffersStorage.vertexBuffers[c] = new g(this.getEngine(), this._userInstancedBuffersStorage.data[c], c, !0, !1, e, !0);
  for (const s of this.instances)
    s.instancedBuffers[c] = null;
  this._invalidateInstanceVertexArrayObject(), this._markSubMeshesAsAttributesDirty();
};
W.prototype._processInstancedBuffers = function(c, e) {
  const t = c ? c.length : 0;
  for (const i in this.instancedBuffers) {
    let s = this._userInstancedBuffersStorage.sizes[i];
    const r = this._userInstancedBuffersStorage.strides[i], n = (t + 1) * r;
    for (; s < n; )
      s *= 2;
    this._userInstancedBuffersStorage.data[i].length != s && (this._userInstancedBuffersStorage.data[i] = new Float32Array(s), this._userInstancedBuffersStorage.sizes[i] = s, this._userInstancedBuffersStorage.vertexBuffers[i] && (this._userInstancedBuffersStorage.vertexBuffers[i].dispose(), this._userInstancedBuffersStorage.vertexBuffers[i] = null));
    const a = this._userInstancedBuffersStorage.data[i];
    let o = 0;
    if (e) {
      const h = this.instancedBuffers[i];
      h.toArray ? h.toArray(a, o) : h.copyToArray ? h.copyToArray(a, o) : a[o] = h, o += r;
    }
    for (let h = 0; h < t; h++) {
      const u = c[h].instancedBuffers[i];
      u.toArray ? u.toArray(a, o) : u.copyToArray ? u.copyToArray(a, o) : a[o] = u, o += r;
    }
    this._userInstancedBuffersStorage.vertexBuffers[i] ? this._userInstancedBuffersStorage.vertexBuffers[i].updateDirectly(a, 0) : (this._userInstancedBuffersStorage.vertexBuffers[i] = new g(this.getEngine(), this._userInstancedBuffersStorage.data[i], i, !0, !1, r, !0), this._invalidateInstanceVertexArrayObject());
  }
};
W.prototype._invalidateInstanceVertexArrayObject = function() {
  if (!(!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0)) {
    for (const c in this._userInstancedBuffersStorage.vertexArrayObjects)
      this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[c]);
    this._userInstancedBuffersStorage.vertexArrayObjects = {};
  }
};
W.prototype._disposeInstanceSpecificData = function() {
  for (this._instanceDataStorage.instancesBuffer && (this._instanceDataStorage.instancesBuffer.dispose(), this._instanceDataStorage.instancesBuffer = null); this.instances.length; )
    this.instances[0].dispose();
  for (const c in this.instancedBuffers)
    this._userInstancedBuffersStorage.vertexBuffers[c] && this._userInstancedBuffersStorage.vertexBuffers[c].dispose();
  this._invalidateInstanceVertexArrayObject(), this.instancedBuffers = {};
};
const Ll = {
  assetPath: "",
  enableShadows: !1,
  groupId: null,
  id: null,
  lights: [],
  rollId: null,
  scene: null
}, Nt = class {
  constructor(e, t) {
    gt(this, "value", 0);
    gt(this, "asleep", !1);
    this.config = { ...Ll, ...e }, this.id = this.config.id !== void 0 ? this.config.id : Date.now(), this.dieType = this.config.sides, this.comboKey = `${this.config.theme}_${this.dieType}`, this.scene = t, this.createInstance();
  }
  createInstance() {
    const e = `${this.config.meshName}_${this.dieType}_${this.config.theme}${this.config.colorSuffix}`, t = `${e}-instance-${this.id}`, i = this.scene.getMeshByName(e).createInstance(t);
    if (this.config.colorSuffix.length > 0) {
      const s = se.FromHexString(this.config.themeColor);
      i.instancedBuffers.customColor = s;
    }
    i.position.y = -100, i.scaling = new p(
      i.scaling.x * this.config.scale,
      i.scaling.y * this.config.scale,
      i.scaling.z * this.config.scale
    ), this.config.enableShadows && this.config.lights.directional.shadowGenerator.addShadowCaster(i), this.mesh = i;
  }
  static async loadDie(e, t) {
    const { sides: i, theme: s = "default", meshName: r, colorSuffix: n } = e, a = r + "_" + i, o = a + "_" + s + n;
    let h = t.getMeshByName(o);
    return h || (h = t.getMeshByName(a).clone(o)), h.material || (h.material = t.getMaterialByName(s + n), n.length > 0 && h.registerInstancedBuffer("customColor", 3)), e;
  }
  static async loadModels(e, t) {
    const { meshFilePath: i, meshName: s, scale: r, d4FaceDown: n = !0 } = e;
    let a = !1, o = !1;
    const h = await fetch(`${i}`).then((l) => {
      if (l.ok) {
        const u = l.headers.get("content-type");
        if (u && u.indexOf("application/json") !== -1)
          return l.json();
        if (l.type && l.type === "basic")
          return l.json();
        throw new Error(`Incorrect contentType: ${u}. Expected "application/json" or "basic"`);
      } else
        throw new Error(`Unable to load 3D mesh file: '${i}'. Request rejected with status ${l.status}: ${l.statusText}`);
    }).catch((l) => console.error(l));
    if (!!h)
      return oe.ImportMeshAsync(null, null, "data:" + JSON.stringify(h), t).then((l) => {
        if (l.meshes.forEach((u) => {
          u.name === "__root__" && u.dispose(), u.name.includes("collider") && (u.scaling = new p(
            u.scaling.x * 0.9,
            u.scaling.y * 0.9,
            u.scaling.z * 0.9
          )), a || (a = u.name === "d100"), o || (o = u.name === "d10"), u.setEnabled(!1), u.freezeNormals(), u.freezeWorldMatrix(), u.isPickable = !1, u.doNotSyncBoundingInfo = !0, u.name = s + "_" + u.name;
        }), !a && o && (t.getMeshByName(s + "_d10").clone(s + "_d100"), t.getMeshByName(s + "_d10_collider").clone(s + "_d100_collider"), h.colliderFaceMap && (h.colliderFaceMap.d100 = Tr(h.colliderFaceMap.d10), Object.values(h.colliderFaceMap.d100).forEach((u, d) => {
          h.colliderFaceMap.d100[d] = u * (u === 10 ? 0 : 10);
        }))), !h.colliderFaceMap)
          throw new Error(`'colliderFaceMap' data not found in ${i}. Without the colliderFaceMap data dice values can not be resolved.`);
        t.themeData[s] = {}, t.themeData[s].colliderFaceMap = h.colliderFaceMap, t.themeData[s].d4FaceDown = n;
      }).catch((l) => console.error(l)), h.meshes.filter((l) => l.name.includes("collider"));
  }
  updateConfig(e) {
    this.config = { ...this.config, ...e };
  }
  static setVector3(e, t, i) {
    return Nt.vector3.set(e, t, i);
  }
  static getVector3() {
    return Nt.vector3;
  }
  static async getRollResult(e, t) {
    const i = (s = e) => new Promise((r, n) => {
      const a = e.config.parentMesh || e.config.meshName, o = t.themeData[a].colliderFaceMap, h = t.themeData[a].d4FaceDown;
      if (!o[s.dieType])
        throw new Error(`No colliderFaceMap data for ${s.dieType}`);
      const l = t.getMeshByName(`${a}_${s.dieType}_collider`).createInstance(`${a}_${s.dieType}-hitbox-${s.id}`);
      l.isPickable = !0, l.isVisible = !0, l.setEnabled(!0), l.position = s.mesh.position, l.rotationQuaternion = s.mesh.rotationQuaternion;
      let u = Nt.setVector3(0, 1, 0);
      s.dieType === "d4" && h && (u = Nt.setVector3(0, -1, 0)), Nt.ray.direction = u, Nt.ray.origin = e.mesh.position;
      const d = t.pickWithRay(Nt.ray);
      if (l.dispose(), s.value = o[s.dieType][d.faceId], s.value === void 0)
        throw new Error(`colliderFaceMap Error: No value found for ${s.dieType} mesh face ${d.faceId}`);
      return r(s.value);
    }).catch((r) => console.error(r));
    return e.mesh ? await i() : e.value;
  }
};
let Rt = Nt;
gt(Rt, "ray", new _e(p.Zero(), p.Zero(), 1)), gt(Rt, "vector3", p.Zero());
class Nl {
  constructor() {
  }
}
class ei extends N {
  constructor(e, t) {
    super(e, t), this.CustomParts = new Nl(), this.customShaderNameResolve = this.Builder, this.FragmentShader = De.ShadersStore.defaultPixelShader, this.VertexShader = De.ShadersStore.defaultVertexShader;
  }
  AttachAfterBind(e, t) {
    if (this._newUniformInstances)
      for (const i in this._newUniformInstances) {
        const s = i.toString().split("-");
        s[0] == "vec2" ? t.setVector2(s[1], this._newUniformInstances[i]) : s[0] == "vec3" ? t.setVector3(s[1], this._newUniformInstances[i]) : s[0] == "vec4" ? t.setVector4(s[1], this._newUniformInstances[i]) : s[0] == "mat4" ? t.setMatrix(s[1], this._newUniformInstances[i]) : s[0] == "float" && t.setFloat(s[1], this._newUniformInstances[i]);
      }
    if (this._newSamplerInstances)
      for (const i in this._newSamplerInstances) {
        const s = i.toString().split("-");
        s[0] == "sampler2D" && this._newSamplerInstances[i].isReady && this._newSamplerInstances[i].isReady() && t.setTexture(s[1], this._newSamplerInstances[i]);
      }
  }
  ReviewUniform(e, t) {
    if (e == "uniform" && this._newUniforms)
      for (let i = 0; i < this._newUniforms.length; i++)
        this._customUniform[i].indexOf("sampler") == -1 && t.push(this._newUniforms[i]);
    if (e == "sampler" && this._newUniforms)
      for (let i = 0; i < this._newUniforms.length; i++)
        this._customUniform[i].indexOf("sampler") != -1 && t.push(this._newUniforms[i]);
    return t;
  }
  Builder(e, t, i, s, r, n) {
    if (n && this._customAttributes && this._customAttributes.length > 0 && n.push(...this._customAttributes), this.ReviewUniform("uniform", t), this.ReviewUniform("sampler", s), this._isCreatedShader)
      return this._createdShaderName;
    this._isCreatedShader = !1, ei.ShaderIndexer++;
    const a = "custom_" + ei.ShaderIndexer, o = this._afterBind.bind(this);
    return this._afterBind = (h, l) => {
      if (!!l) {
        this.AttachAfterBind(h, l);
        try {
          o(h, l);
        } catch {
        }
      }
    }, De.ShadersStore[a + "VertexShader"] = this.VertexShader.replace("#define CUSTOM_VERTEX_BEGIN", this.CustomParts.Vertex_Begin ? this.CustomParts.Vertex_Begin : "").replace("#define CUSTOM_VERTEX_DEFINITIONS", (this._customUniform ? this._customUniform.join(`
`) : "") + (this.CustomParts.Vertex_Definitions ? this.CustomParts.Vertex_Definitions : "")).replace("#define CUSTOM_VERTEX_MAIN_BEGIN", this.CustomParts.Vertex_MainBegin ? this.CustomParts.Vertex_MainBegin : "").replace("#define CUSTOM_VERTEX_UPDATE_POSITION", this.CustomParts.Vertex_Before_PositionUpdated ? this.CustomParts.Vertex_Before_PositionUpdated : "").replace("#define CUSTOM_VERTEX_UPDATE_NORMAL", this.CustomParts.Vertex_Before_NormalUpdated ? this.CustomParts.Vertex_Before_NormalUpdated : "").replace("#define CUSTOM_VERTEX_MAIN_END", this.CustomParts.Vertex_MainEnd ? this.CustomParts.Vertex_MainEnd : ""), this.CustomParts.Vertex_After_WorldPosComputed && (De.ShadersStore[a + "VertexShader"] = De.ShadersStore[a + "VertexShader"].replace("#define CUSTOM_VERTEX_UPDATE_WORLDPOS", this.CustomParts.Vertex_After_WorldPosComputed)), De.ShadersStore[a + "PixelShader"] = this.FragmentShader.replace("#define CUSTOM_FRAGMENT_BEGIN", this.CustomParts.Fragment_Begin ? this.CustomParts.Fragment_Begin : "").replace("#define CUSTOM_FRAGMENT_MAIN_BEGIN", this.CustomParts.Fragment_MainBegin ? this.CustomParts.Fragment_MainBegin : "").replace("#define CUSTOM_FRAGMENT_DEFINITIONS", (this._customUniform ? this._customUniform.join(`
`) : "") + (this.CustomParts.Fragment_Definitions ? this.CustomParts.Fragment_Definitions : "")).replace("#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE", this.CustomParts.Fragment_Custom_Diffuse ? this.CustomParts.Fragment_Custom_Diffuse : "").replace("#define CUSTOM_FRAGMENT_UPDATE_ALPHA", this.CustomParts.Fragment_Custom_Alpha ? this.CustomParts.Fragment_Custom_Alpha : "").replace("#define CUSTOM_FRAGMENT_BEFORE_LIGHTS", this.CustomParts.Fragment_Before_Lights ? this.CustomParts.Fragment_Before_Lights : "").replace("#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR", this.CustomParts.Fragment_Before_FragColor ? this.CustomParts.Fragment_Before_FragColor : "").replace("#define CUSTOM_FRAGMENT_MAIN_END", this.CustomParts.Fragment_MainEnd ? this.CustomParts.Fragment_MainEnd : ""), this.CustomParts.Fragment_Before_Fog && (De.ShadersStore[a + "PixelShader"] = De.ShadersStore[a + "PixelShader"].replace("#define CUSTOM_FRAGMENT_BEFORE_FOG", this.CustomParts.Fragment_Before_Fog)), this._isCreatedShader = !0, this._createdShaderName = a, a;
  }
  AddUniform(e, t, i) {
    return this._customUniform || (this._customUniform = new Array(), this._newUniforms = new Array(), this._newSamplerInstances = {}, this._newUniformInstances = {}), i && (t.indexOf("sampler") != -1 ? this._newSamplerInstances[t + "-" + e] = i : this._newUniformInstances[t + "-" + e] = i), this._customUniform.push("uniform " + t + " " + e + ";"), this._newUniforms.push(e), this;
  }
  AddAttribute(e) {
    return this._customAttributes || (this._customAttributes = []), this._customAttributes.push(e), this;
  }
  Fragment_Begin(e) {
    return this.CustomParts.Fragment_Begin = e, this;
  }
  Fragment_Definitions(e) {
    return this.CustomParts.Fragment_Definitions = e, this;
  }
  Fragment_MainBegin(e) {
    return this.CustomParts.Fragment_MainBegin = e, this;
  }
  Fragment_MainEnd(e) {
    return this.CustomParts.Fragment_MainEnd = e, this;
  }
  Fragment_Custom_Diffuse(e) {
    return this.CustomParts.Fragment_Custom_Diffuse = e.replace("result", "diffuseColor"), this;
  }
  Fragment_Custom_Alpha(e) {
    return this.CustomParts.Fragment_Custom_Alpha = e.replace("result", "alpha"), this;
  }
  Fragment_Before_Lights(e) {
    return this.CustomParts.Fragment_Before_Lights = e, this;
  }
  Fragment_Before_Fog(e) {
    return this.CustomParts.Fragment_Before_Fog = e, this;
  }
  Fragment_Before_FragColor(e) {
    return this.CustomParts.Fragment_Before_FragColor = e.replace("result", "color"), this;
  }
  Vertex_Begin(e) {
    return this.CustomParts.Vertex_Begin = e, this;
  }
  Vertex_Definitions(e) {
    return this.CustomParts.Vertex_Definitions = e, this;
  }
  Vertex_MainBegin(e) {
    return this.CustomParts.Vertex_MainBegin = e, this;
  }
  Vertex_Before_PositionUpdated(e) {
    return this.CustomParts.Vertex_Before_PositionUpdated = e.replace("result", "positionUpdated"), this;
  }
  Vertex_Before_NormalUpdated(e) {
    return this.CustomParts.Vertex_Before_NormalUpdated = e.replace("result", "normalUpdated"), this;
  }
  Vertex_After_WorldPosComputed(e) {
    return this.CustomParts.Vertex_After_WorldPosComputed = e, this;
  }
  Vertex_MainEnd(e) {
    return this.CustomParts.Vertex_MainEnd = e, this;
  }
}
ei.ShaderIndexer = 1;
st("BABYLON.CustomMaterial", ei);
ei.prototype.clone = function(c) {
  const e = this, t = ae.Clone(() => new ei(c, this.getScene()), this);
  return t.name = c, t.id = c, t.CustomParts.Fragment_Begin = e.CustomParts.Fragment_Begin, t.CustomParts.Fragment_Definitions = e.CustomParts.Fragment_Definitions, t.CustomParts.Fragment_MainBegin = e.CustomParts.Fragment_MainBegin, t.CustomParts.Fragment_Custom_Diffuse = e.CustomParts.Fragment_Custom_Diffuse, t.CustomParts.Fragment_Before_Lights = e.CustomParts.Fragment_Before_Lights, t.CustomParts.Fragment_Before_Fog = e.CustomParts.Fragment_Before_Fog, t.CustomParts.Fragment_Custom_Alpha = e.CustomParts.Fragment_Custom_Alpha, t.CustomParts.Fragment_Before_FragColor = e.CustomParts.Fragment_Before_FragColor, t.CustomParts.Vertex_Begin = e.CustomParts.Vertex_Begin, t.CustomParts.Vertex_Definitions = e.CustomParts.Vertex_Definitions, t.CustomParts.Vertex_MainBegin = e.CustomParts.Vertex_MainBegin, t.CustomParts.Vertex_Before_PositionUpdated = e.CustomParts.Vertex_Before_PositionUpdated, t.CustomParts.Vertex_Before_NormalUpdated = e.CustomParts.Vertex_Before_NormalUpdated, t.CustomParts.Vertex_After_WorldPosComputed = e.CustomParts.Vertex_After_WorldPosComputed, t.CustomParts.Vertex_MainEnd = e.CustomParts.Vertex_MainEnd, t;
};
class Bl {
  constructor(e) {
    gt(this, "loadedThemes", {});
    gt(this, "themeData", {});
    this.scene = e.scene;
  }
  async loadStandardMaterial(e) {
    const { theme: t, material: i } = e, s = new N(t, this.scene);
    i.diffuseTexture && (s.diffuseTexture = await this.getTexture("diffuse", e)), i.bumpTexture && (s.bumpTexture = await this.getTexture("bump", e)), i.specularTexture && (s.specularTexture = await this.getTexture("specular", e)), s.allowShaderHotSwapping = !1;
  }
  async loadColorMaterial(e) {
    const { theme: t, material: i } = e, s = new ei(t + "_light", this.scene), r = Tr(e);
    i.diffuseTexture && i.diffuseTexture.light && (r.material.diffuseTexture = e.material.diffuseTexture.light, s.diffuseTexture = await this.getTexture("diffuse", r)), i.bumpTexture && (s.bumpTexture = await this.getTexture("bump", e)), i.specularTexture && (s.specularTexture = await this.getTexture("specular", e)), s.allowShaderHotSwapping = !1, s.Vertex_Definitions(`
      attribute vec3 customColor;
      varying vec3 vColor;
    `).Vertex_MainEnd(`
      vColor = customColor;
    `).Fragment_Definitions(`
      varying vec3 vColor;
    `).Fragment_Custom_Diffuse(`
      baseColor.rgb = mix(vColor.rgb, baseColor.rgb, baseColor.a);
    `), s.AddAttribute("customColor");
    const n = s.clone(t + "_dark");
    i.diffuseTexture && i.diffuseTexture.dark && (r.material.diffuseTexture = e.material.diffuseTexture.dark, n.diffuseTexture = await this.getTexture("diffuse", r)), n.AddAttribute("customColor");
  }
  async getTexture(e, t) {
    const { basePath: i, material: s, theme: r } = t;
    let n;
    const a = e + "Level", o = e + "Texture";
    try {
      switch (e) {
        case "diffuse":
          n = await this.importTextureAsync(`${i}/${s[o]}`, r), s[a] && (n.level = s[a]);
          break;
        case "bump":
          n = await this.importTextureAsync(`${i}/${s[o]}`, r), s[a] && (n.level = s[a]);
          break;
        case "specular":
          n = await this.importTextureAsync(`${i}/${s[o]}`, r), s.specularPower && (n.specularPower = s.specularPower);
          break;
        default:
          throw new Error(`Texture type: ${e} is not supported`);
      }
    } catch (h) {
      console.error(h);
    }
    return n;
  }
  async importTextureAsync(e, t) {
    return new Promise((i, s) => {
      let r = e.match(/^(.*\/)(.*)$/), n = new B(
        e,
        this.scene,
        void 0,
        !0,
        void 0,
        () => i(n),
        () => s(`Unable to load texture '${r[2]}' for theme: '${t}'. Check that your assetPath is configured correctly and that the files exist at path: '${r[1]}'`)
      );
    }).catch((i) => console.error(i));
  }
  async load(e) {
    const { material: t } = e;
    t.type === "color" ? await this.loadColorMaterial(e) : t.type === "standard" ? await this.loadStandardMaterial(e) : console.error(`Material type: ${t.type} not supported`);
  }
}
var Ve, Si, At, xi, bt, pt, qe, rs, St, Ni, Bi, lt, Ui, ns, zr;
class Vl {
  constructor(e) {
    et(this, ns);
    gt(this, "config");
    gt(this, "initialized", !1);
    et(this, Ve, {});
    et(this, Si, 0);
    et(this, At, 0);
    et(this, xi, []);
    et(this, bt, void 0);
    et(this, pt, void 0);
    et(this, qe, void 0);
    et(this, rs, void 0);
    et(this, St, void 0);
    et(this, Ni, void 0);
    et(this, Bi, void 0);
    et(this, lt, void 0);
    et(this, Ui, {});
    gt(this, "noop", () => {
    });
    gt(this, "diceBufferView", new Float32Array(8e3));
    this.onInitComplete = e.onInitComplete || this.noop, this.onThemeLoaded = e.onThemeLoaded || this.noop, this.onRollResult = e.onRollResult || this.noop, this.onRollComplete = e.onRollComplete || this.noop, this.onDieRemoved = e.onDieRemoved || this.noop, this.initialized = this.initScene(e);
  }
  async initScene(e) {
    nt(this, bt, e.canvas), K(this, bt).width = e.width, K(this, bt).height = e.height, this.config = e.options, nt(this, pt, En(K(this, bt))), nt(this, qe, Qn({ engine: K(this, pt) })), nt(this, rs, $n({ engine: K(this, pt), scene: K(this, qe) })), nt(this, St, Er({
      enableShadows: this.config.enableShadows,
      shadowTransparency: this.config.shadowTransparency,
      intensity: this.config.lightIntensity,
      scene: K(this, qe)
    })), nt(this, Ni, new Fl({
      enableShadows: this.config.enableShadows,
      aspect: K(this, bt).width / K(this, bt).height,
      lights: K(this, St),
      scene: K(this, qe)
    })), nt(this, Bi, new Bl({ scene: K(this, qe) })), this.onInitComplete();
  }
  connect(e) {
    nt(this, lt, e), K(this, lt).postMessage({
      action: "initBuffer",
      diceBuffer: this.diceBufferView.buffer
    }, [this.diceBufferView.buffer]), K(this, lt).onmessage = (t) => {
      switch (t.data.action) {
        case "updates":
          this.updatesFromPhysics(t.data.diceBuffer);
          break;
        default:
          console.error("action from physicsWorker not found in offscreen worker");
          break;
      }
    };
  }
  updateConfig(e) {
    const t = this.config;
    this.config = e, t.enableShadows !== this.config.enableShadows && (Object.values(K(this, St)).forEach((i) => i.dispose()), nt(this, St, Er({ enableShadows: this.config.enableShadows }))), t.scale !== this.config.scale && Object.values(K(this, Ve)).forEach(({ mesh: i }) => {
      i && (i.scaling = new p(this.config.scale, this.config.scale, this.config.scale));
    }), t.shadowTransparency !== this.config.shadowTransparency && (K(this, St).directional.shadowGenerator.darkness = this.config.shadowTransparency), t.lightIntensity !== this.config.lightIntensity && (K(this, St).directional.intensity = 0.65 * this.config.lightIntensity, K(this, St).hemispheric.intensity = 0.4 * this.config.lightIntensity);
  }
  render(e) {
    K(this, pt).runRenderLoop(this.renderLoop.bind(this)), K(this, lt).postMessage({
      action: "resumeSimulation",
      newStartPoint: e
    });
  }
  renderLoop() {
    K(this, At) && K(this, At) === Object.keys(K(this, Ve)).length ? (K(this, pt).stopRenderLoop(), K(this, lt).postMessage({
      action: "stopSimulation"
    }), this.onRollComplete()) : K(this, qe).render();
  }
  async loadTheme(e) {
    const { theme: t, basePath: i, material: s, meshFilePath: r, meshName: n } = e;
    if (await K(this, Bi).load({ theme: t, basePath: i, material: s }), !Object.keys(K(this, Ui)).includes(n)) {
      K(this, Ui)[n] = r;
      const a = await Rt.loadModels({ meshFilePath: r, meshName: n }, K(this, qe));
      if (!a)
        throw new Error("No colliders returned from the 3D mesh file. Low poly colliders are expected to be in the same file as the high poly dice and the mesh name contains the word 'collider'");
      K(this, lt).postMessage({
        action: "loadModels",
        options: {
          colliders: a,
          meshName: n
        }
      });
    }
    this.onThemeLoaded({ id: t });
  }
  clear() {
    !Object.keys(K(this, Ve)).length && !K(this, At) || (this.diceBufferView.byteLength && this.diceBufferView.fill(0), K(this, xi).forEach((e) => clearTimeout(e)), K(this, pt).stopRenderLoop(), Object.values(K(this, Ve)).forEach((e) => {
      e.mesh && e.mesh.dispose();
    }), nt(this, Ve, {}), nt(this, Si, 0), nt(this, At, 0), K(this, qe).render());
  }
  add(e) {
    Rt.loadDie(e, K(this, qe)).then((t) => {
      K(this, xi).push(setTimeout(() => {
        js(this, ns, zr).call(this, t);
      }, _i(this, Si)._++ * this.config.delay));
    });
  }
  addNonDie(e) {
    K(this, pt).activeRenderLoops.length === 0 && this.render(!1);
    const { id: t, value: i, ...s } = e, r = {
      id: t,
      value: i,
      config: s
    };
    K(this, Ve)[t] = r, setTimeout(() => {
      K(this, xi).push(setTimeout(() => {
        this.handleAsleep(r);
      }, _i(this, Si)._++ * this.config.delay));
    }, 10);
  }
  remove(e) {
    const t = K(this, Ve)[e.id];
    t.hasOwnProperty("d10Instance") && (K(this, Ve)[t.d10Instance.id].mesh && (K(this, Ve)[t.d10Instance.id].mesh.dispose(), K(this, lt).postMessage({
      action: "removeDie",
      id: t.d10Instance.id
    })), delete K(this, Ve)[t.d10Instance.id], _i(this, At)._--), K(this, Ve)[e.id].mesh && K(this, Ve)[e.id].mesh.dispose(), delete K(this, Ve)[e.id], _i(this, At)._--, K(this, qe).render(), this.onDieRemoved(e.rollId);
  }
  updatesFromPhysics(e) {
    this.diceBufferView = new Float32Array(e);
    let t = 1;
    for (let i = 0, s = this.diceBufferView[0]; i < s; i++) {
      if (!Object.keys(K(this, Ve)).length)
        continue;
      const r = K(this, Ve)[`${this.diceBufferView[t]}`];
      if (!r) {
        console.log("Error: die not available in scene to animate");
        break;
      }
      if (this.diceBufferView[t + 1] === -1)
        this.handleAsleep(r);
      else {
        const n = this.diceBufferView[t + 1], a = this.diceBufferView[t + 2], o = this.diceBufferView[t + 3], h = this.diceBufferView[t + 4], l = this.diceBufferView[t + 5], u = this.diceBufferView[t + 6], d = this.diceBufferView[t + 7];
        r.mesh.position.set(n, a, o), r.mesh.rotationQuaternion.set(h, l, u, d);
      }
      t = t + 8;
    }
    requestAnimationFrame(() => {
      K(this, lt).postMessage({
        action: "stepSimulation",
        diceBuffer: this.diceBufferView.buffer
      }, [this.diceBufferView.buffer]);
    });
  }
  async handleAsleep(e) {
    var t, i;
    if (e.asleep = !0, await Rt.getRollResult(e, K(this, qe)), e.d10Instance || e.dieParent) {
      if (((t = e == null ? void 0 : e.d10Instance) == null ? void 0 : t.asleep) || ((i = e == null ? void 0 : e.dieParent) == null ? void 0 : i.asleep)) {
        const s = e.config.sides === 100 ? e : e.dieParent, r = e.config.sides === 10 ? e : e.d10Instance;
        r.value === 0 && s.value === 0 ? s.value = 100 : s.value = s.value + r.value, this.onRollResult({
          rollId: s.config.rollId,
          value: s.value
        });
      }
    } else
      e.config.sides === 10 && e.value === 0 && (e.value = 10), this.onRollResult({
        rollId: e.config.rollId,
        value: e.value
      });
    _i(this, At)._++;
  }
  resize(e) {
    const t = K(this, bt).width = e.width, i = K(this, bt).height = e.height;
    K(this, Ni).create({ aspect: t / i }), K(this, pt).resize();
  }
}
Ve = new WeakMap(), Si = new WeakMap(), At = new WeakMap(), xi = new WeakMap(), bt = new WeakMap(), pt = new WeakMap(), qe = new WeakMap(), rs = new WeakMap(), St = new WeakMap(), Ni = new WeakMap(), Bi = new WeakMap(), lt = new WeakMap(), Ui = new WeakMap(), ns = new WeakSet(), zr = async function(e) {
  K(this, pt).activeRenderLoops.length === 0 && this.render(e.newStartPoint);
  const t = {
    ...e,
    assetPath: this.config.assetPath,
    enableShadows: this.config.enableShadows,
    scale: this.config.scale,
    lights: K(this, St)
  }, i = new Rt(t, K(this, qe));
  return K(this, Ve)[i.id] = i, K(this, lt).postMessage({
    action: "addDie",
    options: {
      sides: e.sides,
      scale: this.config.scale,
      id: i.id,
      newStartPoint: e.newStartPoint,
      theme: e.theme,
      meshName: e.meshName
    }
  }), e.sides === 100 && (i.d10Instance = await Rt.loadDie({ ...t, sides: 10, id: i.id + 1e4 }, K(this, qe)).then((s) => {
    const r = new Rt(s, K(this, qe));
    return r.dieParent = i, r;
  }), K(this, Ve)[`${i.d10Instance.id}`] = i.d10Instance, K(this, lt).postMessage({
    action: "addDie",
    options: {
      sides: 10,
      scale: this.config.scale,
      id: i.d10Instance.id,
      theme: e.theme,
      meshName: e.meshName
    }
  })), i;
};
export {
  Vl as default
};
//# sourceMappingURL=world.onscreen.js.map
