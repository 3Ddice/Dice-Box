{"version":3,"file":"dice-box.es.js","sources":["../src/components/world/canvas.js","../src/helpers/index.js","../src/WorldFacade.js"],"sourcesContent":["function createCanvas(options) {\n  const { selector, id } = options\n\n  if (!selector || typeof selector !== 'string') {\n    throw(new Error(\"You must provide a DOM selector as the first argument in order to render the Dice Box\"))\n  }\n\n  let canvas\n  const container = document.querySelector(selector)\n\n  if(!container?.nodeName){\n    throw(new Error(`DiceBox target DOM node: '${selector}' not found or not available yet. Try invoking inside a DOMContentLoaded event`))\n  }\n  \n  if(container.nodeName.toLowerCase() !== 'canvas') {\n    canvas = document.createElement('canvas')\n    canvas.id = id\n    container.appendChild(canvas)\n  } \n  else {\n    canvas = container\n  }\n  return canvas\n}\n\nexport { createCanvas }","export function lerp(a, b, alpha) {\n  return a * (1 - alpha) + b * alpha;\n}\n\n/**\n * Create UUIDs \n * @return {string} Unique UUID\n */\nexport const createUUID = () => {\n  return ([1e7]+-1e3+-4e3+-8e3+-1e11).replace(/[018]/g, c => {\n    const crypto = window.crypto || window.msCrypto\n    //eslint-disable-next-line\n    return (c ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)\n  })\n}\n\nexport const recursiveSearch = (obj, searchKey, results = []) => {\n\tconst r = results;\n\tObject.keys(obj).forEach(key => {\n\t\tconst value = obj[key];\n\t\t// if(key === searchKey && typeof value !== 'object'){\n\t\tif(key === searchKey){\n\t\t\tr.push(value);\n\t\t} else if(value && typeof value === 'object'){\n\t\t\trecursiveSearch(value, searchKey, r);\n\t\t}\n\t});\n\treturn r;\n};\n\n/**\n * Debounce functions for better performance\n * (c) 2021 Chris Ferdinandi, MIT License, https://gomakethings.com\n * @param  {Function} fn The function to debounce\n */\nexport const debounce = (fn) => {\n\n\t// Setup a timer\n\tlet timeout;\n\n\t// Return a function to run debounced\n\treturn function () {\n\n\t\t// Setup the arguments\n\t\tlet context = this;\n\t\tlet args = arguments;\n\n\t\t// If there's a timer, cancel it\n\t\tif (timeout) {\n\t\t\twindow.cancelAnimationFrame(timeout);\n\t\t}\n\n\t\t// Setup the new requestAnimationFrame()\n\t\ttimeout = window.requestAnimationFrame(function () {\n\t\t\tfn.apply(context, args);\n\t\t});\n\t};\n}\n\n/**\n * Function Queue - ensures async function calls are triggered in the order they are queued\n * By David Adler (david_adler) @ https://stackoverflow.com/questions/53540348/js-async-await-tasks-queue\n * @param  {object} opts Option to dedupe concurrent executions\n * @return {object} returns object with \"push\" function, \"queue\" array, and \"flush\" function\n */\nexport const createAsyncQueue = (opts = { dedupe: false }) => {\n  const { dedupe } = opts\n  let queue = []\n  let running\n  const push = task => {\n    if (dedupe) queue = []\n    queue.push(task)\n    if (!running) running = start()\n    return running.finally(() => {\n      running = undefined\n    })\n  }\n  const start = async () => {\n    const res = []\n    while (queue.length) {\n      const item = queue.shift()\n      res.push(await item())\n    }\n    return res\n  }\n  return { push, queue, flush: () => running || Promise.resolve([]) }\n}\n\n// deep copy objects and break references to original object\n// Note: does not work with the 'scene' object or objects with circular references\nexport const deepCopy = obj => JSON.parse(JSON.stringify(obj))\n\n// Sleeper function to delay execution for testing\nexport const sleeper = (ms) => {\n  return new Promise(resolve => setTimeout(() => resolve(), ms));\n}\n\nexport class Random {\n  /**\n   * Generate a random number between 0 (inclusive) and 1 (exclusive).\n   * A drop in replacement for Math.random()\n   * @return {number}\n   */\n  static value() {\n    const crypto = window.crypto || window.msCrypto;\n    const buffer = new Uint32Array(1);\n    const int = crypto.getRandomValues(buffer)[0];\n\n    return int / 2**32\n  }\n  /**\n   * Generate a very good random number between min (inclusive) and max (exclusive) by using crypto.getRandomValues() twice.\n   * @param  {number} min\n   * @param  {number} max\n   * @return {number}\n   */\n  static range(min, max) {\n    // return Math.floor(this.value() * (max - min) + min); // plain random\n    return (Math.floor(Math.pow(10,14)*this.value()*this.value())%(max-min+1))+min // super random!\n  }\n}\n\n// https://www.30secondsofcode.org/c/js-colors/p/1\nexport const hexToRGB = hex => {\n  let alpha = false,\n    h = hex.slice(hex.startsWith('#') ? 1 : 0);\n  if (h.length === 3) h = [...h].map(x => x + x).join('');\n  else if (h.length === 8) alpha = true;\n  h = parseInt(h, 16);\n  let val = {\n    r: h >>> 16,\n    g: (h & 0x00ff00) >>> 8,\n    b: (h & 0x0000ff)\n  }\n  if(alpha) {\n    val.r = h >>> 24\n    val.g = (h & 0x00ff0000) >>> 16\n    val.b = (h & 0x0000ff00) >>> 8\n    val.a = (h & 0x000000ff)\n  }\n  return val\n\n};\n\nexport const RGBToHSB = (r, g, b) => {\n  r /= 255;\n  g /= 255;\n  b /= 255;\n  const v = Math.max(r, g, b),\n    n = v - Math.min(r, g, b);\n  const h =\n    n === 0 ? 0 : n && v === r ? (g - b) / n : v === g ? 2 + (b - r) / n : 4 + (r - g) / n;\n  return [60 * (h < 0 ? h + 6 : h), v && (n / v) * 100, v * 100];\n};\n\nexport const hexToHSB = (hex) => {\n  const rgb = hexToRGB(hex)\n  return RGBToHSB(rgb.r,rgb.g,rgb.b)\n}","import { createCanvas } from \"./components/world/canvas\";\nimport physicsWorker from \"./components/physics.worker.js?worker&inline\";\nimport { debounce, createAsyncQueue, Random, hexToRGB } from \"./helpers\";\n\nconst defaultOptions = {\n  id: `dice-canvas-${Date.now()}`, // set the canvas id\n  enableShadows: true, // do dice cast shadows onto DiceBox mesh?\n  shadowTransparency: 0.8,\n  lightIntensity: 1,\n  delay: 10, // delay between dice being generated - 0 causes stuttering and physics popping\n  scale: 5, // scale the dice\n  theme: \"default\", // can be a hex color or a pre-defined theme such as 'purpleRock'\n  themeColor: \"#2e8555\", // used for color values or named theme variants - not fully implemented yet // green: #2e8555 // yellow: #feea03\n  offscreen: true, // use offscreen canvas browser feature for performance improvements - will fallback to false based on feature detection\n  assetPath: \"/assets/dice-box/\", // path to 'ammo', 'models', 'themes' folders and web workers\n  origin: location.origin,\n  meshFile: `models/default.json`,\n  suspendSimulation: false,\n};\n\nclass WorldFacade {\n  rollCollectionData = {};\n  rollGroupData = {};\n  rollDiceData = {};\n  themeData = [];\n  themesLoadedData = {};\n  #collectionIndex = 0;\n  #groupIndex = 0;\n  #rollIndex = 0;\n  #idIndex = 0;\n  #DiceWorld = {};\n  #diceWorldPromise;\n  #diceWorldResolve;\n  #DicePhysics;\n  #dicePhysicsPromise;\n  #dicePhysicsResolve;\n  noop = () => {};\n\n  constructor(container, options = {}) {\n    if (typeof options !== \"object\") {\n      throw new Error(\n        \"Config options should be an object. Config reference: https://fantasticdice.games/docs/usage/config#configuration-options\"\n      );\n    }\n    // pull out callback functions from options\n    const {\n      onDieComplete,\n      onRollComplete,\n      onRemoveComplete,\n      onThemeConfigLoaded,\n      onThemeLoaded,\n      ...boxOptions\n    } = options;\n\n    // extend defaults with options\n    this.config = { ...defaultOptions, ...boxOptions };\n\n    // assign callback functions\n    this.onDieComplete = options.onDieComplete || this.noop;\n    this.onRollComplete = options.onRollComplete || this.noop;\n    this.onRemoveComplete = options.onRemoveComplete || this.noop;\n    this.onThemeLoaded = options.onThemeLoaded || this.noop;\n    this.onThemeConfigLoaded = options.onThemeConfigLoaded || this.noop;\n\n    // if a canvas selector is provided then that will be used for the dicebox, otherwise a canvas will be created using the config.id\n    this.canvas = createCanvas({\n      selector: container,\n      id: this.config.id,\n    });\n    // create a queue to prevent theme being loaded multiple times\n    this.loadThemeQueue = createAsyncQueue({ dedupe: true });\n  }\n\n  // Load the BabylonJS World\n  async #loadWorld() {\n    // set up a promise to be fulfilled when a message comes back from DiceWorld indicating init is complete\n    this.#diceWorldPromise = new Promise((resolve, reject) => {\n      this.#diceWorldResolve = resolve;\n    });\n\n    // resolve the promise one onInitComplete callback is triggered\n    const onInitComplete = () => {\n      this.#diceWorldResolve();\n    };\n\n    if (\n      \"OffscreenCanvas\" in window &&\n      \"transferControlToOffscreen\" in this.canvas &&\n      this.config.offscreen\n    ) {\n      // Ok to use offscreen canvas - transfer control offscreen\n      const WorldOffscreen = await import(\"./components/world.offscreen\").then(\n        (module) => module.default\n      );\n      // WorldOffscreen is just a container class that passes all method calls to the Offscreen Canvas worker\n      this.#DiceWorld = new WorldOffscreen({\n        canvas: this.canvas,\n        options: this.config,\n        onInitComplete,\n      });\n    } else {\n      if (this.config.offscreen) {\n        console.warn(\n          \"This browser does not support OffscreenCanvas. Using standard canvas fallback.\"\n        );\n        this.config.offscreen = false;\n      }\n      // code splitting out WorldOnscreen. It's essentially the same as offscreenCanvas.worker.js but communicates with the main thread differently\n      const WorldOnscreen = await import(\"./components/world.onscreen\").then(\n        (module) => module.default\n      );\n      this.#DiceWorld = new WorldOnscreen({\n        canvas: this.canvas,\n        options: this.config,\n        onInitComplete,\n      });\n    }\n  }\n\n  // Load the AmmoJS physics world\n  #loadPhysics() {\n    // initialize physics world in which AmmoJS runs\n    this.#DicePhysics = new physicsWorker();\n    // set up a promise to be fulfilled when a message comes back from physics.worker indicating init is complete\n    this.#dicePhysicsPromise = new Promise((resolve, reject) => {\n      this.#dicePhysicsResolve = resolve;\n    });\n    this.#DicePhysics.onmessage = (e) => {\n      switch (e.data.action) {\n        case \"init-complete\":\n          this.#dicePhysicsResolve(); // fulfill promise so other things can run\n      }\n    };\n    // initialize the AmmoJS physics worker\n    this.#DicePhysics.postMessage({\n      action: \"init\",\n      width: this.canvas.clientWidth,\n      height: this.canvas.clientHeight,\n      options: this.config,\n    });\n  }\n\n  #connectWorld() {\n    const channel = new MessageChannel();\n\n    // create message channel for the visual world and the physics world to communicate through\n    this.#DiceWorld.connect(channel.port1);\n\n    // create message channel for this WorldFacade class to communicate with physics world\n    this.#DicePhysics.postMessage(\n      {\n        action: \"connect\",\n      },\n      [channel.port2]\n    );\n  }\n\n  resizeWorld(resize) {\n    this.#DiceWorld.resize(resize);\n    this.#DicePhysics.postMessage({\n      action: \"resize\",\n      ...resize,\n    });\n  }\n\n  async init() {\n    // trigger physics first so it can load in parallel with world\n    this.#loadPhysics();\n    await this.#loadWorld();\n\n    // now that DiceWorld is ready we can attach our callbacks\n    this.#DiceWorld.onRollResult = (result) => {\n      const die = this.rollDiceData[result.rollId];\n      const group = this.rollGroupData[die.groupId];\n      const collection = this.rollCollectionData[die.collectionId];\n\n      // map die results back to our rollData\n      // since all rolls are references to this.rollDiceDate the values will be added to those objects\n      group.rolls[die.rollId].value = result.value;\n\n      // increment the completed roll count for this group\n      collection.completedRolls++;\n      // if all rolls are completed then resolve the collection promise - returning dice that were in this collection\n      if (collection.completedRolls == collection.rolls.length) {\n        // pull out roll.collectionId and roll.id? They're meant to be internal values\n        collection.resolve(\n          Object.values(collection.rolls).map(\n            ({ collectionId, id, meshName, ...rest }) => rest\n          )\n        );\n      }\n\n      // trigger callback passing individual die result\n      const { collectionId, id, ...returnDie } = die;\n      this.onDieComplete(returnDie);\n    };\n    this.#DiceWorld.onRollComplete = () => {\n      // trigger callback passing the roll results\n      this.onRollComplete(this.getRollResults());\n    };\n\n    this.#DiceWorld.onDieRemoved = (rollId) => {\n      // get die information from cache\n      let die = this.rollDiceData[rollId];\n      const collection = this.rollCollectionData[die.removeCollectionId];\n      collection.completedRolls++;\n\n      // remove this die from cache\n      delete this.rollDiceData[die.rollId];\n\n      // remove this die from it's group rolls\n      const group = this.rollGroupData[die.groupId];\n      delete group.rolls[die.rollId];\n\n      // parse the group value now that the die has been removed from data\n      const groupData = this.#parseGroup(die.groupId);\n      // update the value and quantity values\n      group.value = groupData.value;\n      group.qty = groupData.rollsArray.length;\n\n      // if all rolls are completed then resolve the collection promise - returning dice that were removed\n      if (collection.completedRolls == collection.rolls.length) {\n        collection.resolve(\n          Object.values(collection.rolls).map(({ id, ...rest }) => rest)\n        );\n      }\n      const { collectionId, id, removeCollectionId, meshName, ...returnDie } =\n        die;\n      this.onRemoveComplete(returnDie);\n    };\n\n    // wait for both DiceWorld and DicePhysics to initialize\n    await Promise.all([this.#diceWorldPromise, this.#dicePhysicsPromise]);\n    // set up message channels between Dice World and Dice Physics\n\n    this.#connectWorld();\n\n    // queue load of the theme defined in the config\n    await this.loadThemeQueue.push(() => this.loadTheme(this.config.theme));\n\n    //TODO: this should probably return a promise\n    // make this method chainable\n    return this;\n  }\n\n  // fetch the theme config and return a themeData object\n  async getThemeConfig(theme) {\n    const basePath = `${this.config.origin}${this.config.assetPath}themes/${theme}`;\n    let themeData;\n\n    if (theme === \"default\") {\n      // sensible defaults\n      themeData = {\n        name: \"Default Colors\",\n        material: {\n          type: \"color\",\n          diffuseTexture: {\n            light: \"diffuse-light.png\",\n            dark: \"diffuse-dark.png\",\n          },\n          diffuseLevel: 1,\n          bumpTexture: \"normal.png\",\n          bumpLevel: 0.5,\n          specularTexture: \"specular.jpg\",\n          specularPower: 1,\n        },\n      };\n    } else {\n      // fetch the theme.config file\n      themeData = await fetch(`${basePath}/theme.config.json`)\n        .then((resp) => {\n          if (resp.ok) {\n            const contentType = resp.headers.get(\"content-type\");\n            if (contentType && contentType.indexOf(\"application/json\") !== -1) {\n              return resp.json();\n            } else if (resp.type && resp.type === \"basic\") {\n              return resp.json();\n            } else {\n              // return resp\n              throw new Error(\n                `Incorrect contentType: ${contentType}. Expected \"application/json\" or \"basic\"`\n              );\n            }\n          } else {\n            throw new Error(\n              `Unable to fetch config file for theme: '${theme}'. Request rejected with status ${resp.status}: ${resp.statusText}`\n            );\n          }\n        })\n        .catch((error) => console.error(error));\n    }\n\n    let meshFilePath =\n      this.config.origin + this.config.assetPath + this.config.meshFile;\n    let meshName = \"default\";\n    if (!themeData) {\n      throw new Error(\"No theme config data to work with.\");\n    }\n    if (themeData.hasOwnProperty(\"meshFile\")) {\n      meshFilePath = `${basePath}/${themeData.meshFile}`;\n      if (!themeData.hasOwnProperty(\"meshName\")) {\n        console.warn(\n          \"You should provide a meshName in your theme.config.json file\"\n        );\n        // fallback to fileName as meshName without extension\n        meshName = themeData.meshFile.replace(/(.*)\\..{2,4}$/, \"$1\");\n      } else {\n        meshName = themeData.meshName;\n      }\n    }\n\n    // if diceAvailable is not specified then assume the default set of seven\n    if (!themeData.hasOwnProperty(\"diceAvailable\")) {\n      themeData.diceAvailable = [\"d4\", \"d6\", \"d8\", \"d10\", \"d12\", \"d20\", \"d100\"];\n    }\n\n    if (themeData.hasOwnProperty(\"extends\")) {\n      let target = this.themesLoadedData[themeData.extends];\n      if (!target) {\n        target = await this.loadTheme(themeData.extends).catch((error) =>\n          console.error(error)\n        );\n      }\n      if (target) {\n        themeData.diceInherited = [...(themeData.diceInherited || [])];\n        target.diceAvailable.map((die) => {\n          themeData.diceInherited[die] = target.systemName;\n        });\n      }\n    }\n\n    Object.assign(themeData, {\n      basePath,\n      meshFilePath,\n      meshName,\n      theme,\n    });\n\n    // this.onThemeConfigLoaded(themeData)\n\n    return themeData;\n  }\n\n  async loadTheme(theme) {\n    // check the cache\n    if (this.themesLoadedData[theme]) {\n      // short circuit if theme has been previously loaded\n      // console.log(`${theme} has already been loaded. Returning cache`)\n      return this.themesLoadedData[theme];\n    }\n    // console.log(`${theme} is loading ...`)\n\n    // fetch and save the themeData for later\n    const themeConfig = (this.themesLoadedData[theme] =\n      await this.getThemeConfig(theme).catch((error) => console.error(error)));\n    this.onThemeConfigLoaded(themeConfig);\n\n    if (!themeConfig) return;\n\n    // pass config onto DiceWorld to load - the theme loader needs 'scene' from DiceWorld\n    await this.#DiceWorld\n      .loadTheme(themeConfig)\n      .catch((error) => console.error(error));\n\n    this.onThemeLoaded(themeConfig);\n\n    return themeConfig;\n  }\n\n  // TODO: use getter and setter\n  // change config options\n  async updateConfig(options) {\n    const newConfig = { ...this.config, ...options };\n    // console.log('newConfig', newConfig)\n    const config = await this.loadThemeQueue.push(() =>\n      this.loadTheme(newConfig.theme)\n    );\n    // const themeData = config.at(-1) //get the last entry returned from the queue\n\n    this.config = newConfig;\n    // pass updates to DiceWorld\n    this.#DiceWorld.updateConfig(newConfig);\n    // pass updates to PhysicsWorld\n    this.#DicePhysics.postMessage({\n      action: \"updateConfig\",\n      options: newConfig,\n    });\n\n    // make this method chainable\n    return this;\n  }\n\n  clear() {\n    // reset indexes\n    this.#collectionIndex = 0;\n    this.#groupIndex = 0;\n    this.#rollIndex = 0;\n    this.#idIndex = 0;\n    // reset internal data objects\n    this.rollCollectionData = {};\n    this.rollGroupData = {};\n    this.rollDiceData = {};\n    // clear all rendered die bodies\n    this.#DiceWorld.clear();\n    // clear all physics die bodies\n    this.#DicePhysics.postMessage({ action: \"clearDice\" });\n\n    // make this method chainable\n    return this;\n  }\n\n  hide() {\n    this.canvas.style.display = \"none\";\n\n    // make this method chainable\n    return this;\n  }\n\n  show() {\n    this.canvas.style.display = \"block\";\n\n    this.resizeWorld({\n      width: this.canvas.clientWidth,\n      height: this.canvas.clientHeight,\n    });\n\n    // make this method chainable\n    return this;\n  }\n\n  // TODO: pass data with roll - such as roll name. Passed back at the end in the results\n  roll(\n    notation,\n    {\n      theme = this.config.theme,\n      themeColor = this.config.themeColor,\n      newStartPoint = true,\n    } = {}\n  ) {\n    // note: to add to a roll on screen use .add method\n    // reset the offscreen worker and physics worker with each new roll\n    this.clear();\n    const collectionId = this.#collectionIndex++;\n\n    this.rollCollectionData[collectionId] = new Collection({\n      id: collectionId,\n      notation,\n      theme,\n      themeColor,\n      newStartPoint,\n    });\n\n    const parsedNotation = this.createNotationArray(\n      notation,\n      this.themesLoadedData[theme].diceAvailable\n    );\n    this.#makeRoll(parsedNotation, collectionId);\n\n    // returns a Promise that is resolved in onRollComplete\n    return this.rollCollectionData[collectionId].promise;\n  }\n\n  add(\n    notation,\n    {\n      theme = this.config.theme,\n      themeColor = this.config.themeColor,\n      newStartPoint = true,\n    } = {}\n  ) {\n    const collectionId = this.#collectionIndex++;\n\n    this.rollCollectionData[collectionId] = new Collection({\n      id: collectionId,\n      notation,\n      theme,\n      themeColor,\n      newStartPoint,\n    });\n\n    const parsedNotation = this.createNotationArray(\n      notation,\n      this.themesLoadedData[theme].diceAvailable\n    );\n    this.#makeRoll(parsedNotation, collectionId);\n\n    // returns a Promise that is resolved in onRollComplete\n    return this.rollCollectionData[collectionId].promise;\n  }\n\n  reroll(\n    notation,\n    { remove = false, hide = false, newStartPoint = true } = {}\n  ) {\n    // TODO: add hide if you want to keep the die result for an external parser\n\n    // ensure notation is an array\n    const rollArray = Array.isArray(notation) ? notation : [notation];\n\n    // destructure out 'sides', 'theme', 'groupId', 'rollId' - basically just getting rid of value - could do ({value, ...rest}) => rest\n    const cleanNotation = rollArray.map(({ value, ...rest }) => rest);\n\n    if (remove === true) {\n      this.remove(cleanNotation, { hide });\n    }\n\n    // .add will return a promise that will then be returned here\n    return this.add(cleanNotation, { newStartPoint });\n  }\n\n  remove(notation, { hide = false } = {}) {\n    // ensure notation is an array\n    const rollArray = Array.isArray(notation) ? notation : [notation];\n\n    const collectionId = this.#collectionIndex++;\n\n    this.rollCollectionData[collectionId] = new Collection({\n      id: collectionId,\n      notation,\n      rolls: rollArray,\n    });\n\n    // loop through each die to be removed\n    rollArray.map((die) => {\n      // add the collectionId to the die so it can be looked up in the callback\n      this.rollDiceData[die.rollId].removeCollectionId = collectionId;\n      // assign the id for this die from our cache - required for removal\n      // die.id = this.rollDiceData[die.rollId].id - note: can appear in async roll result data if attached to die object\n      let id = this.rollDiceData[die.rollId].id;\n      // remove the die from the render - don't like having to pass two ids. rollId is passed over just so it can be passed back for callback\n      this.#DiceWorld.remove({ id, rollId: die.rollId });\n      // remove the die from the physics bodies\n      this.#DicePhysics.postMessage({ action: \"removeDie\", id });\n    });\n\n    return this.rollCollectionData[collectionId].promise;\n  }\n\n  // used by both .add and .roll - .roll clears the box and .add does not\n  async #makeRoll(parsedNotation, collectionId) {\n    const collection = this.rollCollectionData[collectionId];\n    let newStartPoint = collection.newStartPoint;\n\n    // loop through the number of dice in the group and roll each one\n    parsedNotation.forEach(async (notation) => {\n      if (!notation.sides) {\n        throw new Error(\"Improper dice notation or unable to parse notation\");\n      }\n      const theme = notation.theme || collection.theme || this.config.theme;\n      const themeColor =\n        notation.themeColor || collection.themeColor || this.config.themeColor;\n      const rolls = {};\n      const hasGroupId = notation.groupId !== undefined;\n      let index;\n\n      // load the theme, will be short circuited if previously loaded\n      const loadTheme = () => this.loadTheme(theme);\n      await this.loadThemeQueue.push(loadTheme);\n\n      const {\n        meshName,\n        diceAvailable,\n        diceInherited = {},\n        material: { type: materialType },\n      } = this.themesLoadedData[theme];\n      const diceExtra = Object.keys(diceInherited);\n\n      let colorSuffix = \"\",\n        color;\n\n      if (materialType === \"color\") {\n        color = hexToRGB(themeColor);\n        // dat.gui uses HSB(a.k.a HSV) brightness greater than .5 and saturation less than .5\n        colorSuffix =\n          color.r * 0.299 + color.g * 0.587 + color.b * 0.114 > 175\n            ? \"_dark\"\n            : \"_light\";\n      }\n\n      // TODO: should I validate that added dice are only joining groups of the same \"sides\" value - e.g.: d6's can only be added to groups when sides: 6? Probably.\n      for (var i = 0, len = notation.qty; i < len; i++) {\n        // id's start at zero and zero can be falsy, so we check for undefined\n        let rollId =\n          notation.rollId !== undefined ? notation.rollId : this.#rollIndex++;\n        let id = notation.id !== undefined ? notation.id : this.#idIndex++;\n        index = hasGroupId ? notation.groupId : this.#groupIndex;\n\n        const dieType = Number.isInteger(notation.sides)\n          ? `d${notation.sides}`\n          : notation.sides;\n\n        notation.sides = dieType;\n\n        const roll = {\n          sides: dieType,\n          groupId: index,\n          collectionId: collection.id,\n          rollId,\n          id,\n          theme,\n          themeColor,\n          meshName,\n        };\n\n        rolls[rollId] = roll;\n        this.rollDiceData[rollId] = roll;\n        collection.rolls.push(this.rollDiceData[rollId]);\n\n        // TODO: eliminate the 'd' for more flexible naming such as 'fate' - ensure numbers are strings\n        if (\n          roll.sides === \"fate\" &&\n          !diceAvailable.includes(roll.sides) &&\n          !diceExtra.includes(roll.sides)\n        ) {\n          console.warn(\n            `fate die unavailable in '${theme}' theme. Using fallback.`\n          );\n          const min = -1;\n          const max = 1;\n          roll.value = Random.range(min, max);\n          this.#DiceWorld.addNonDie(roll);\n        } else if (\n          this.config.suspendSimulation ||\n          (!diceAvailable.includes(roll.sides) &&\n            !diceExtra.includes(roll.sides))\n        ) {\n          // check if the requested roll is available in the current theme, if not then use crypto fallback\n          console.warn(\n            this.config.suspendSimulation\n              ? \"3D simulation suspended. Using fallback.\"\n              : `${roll.sides} die unavailable in '${theme}' theme. Using fallback.`\n          );\n          roll.value = Random.range(1, roll.sides);\n          this.#DiceWorld.addNonDie(roll);\n        } else {\n          let parentTheme;\n          if (diceExtra.includes(roll.sides)) {\n            const parentThemeName = diceInherited[roll.sides];\n            parentTheme = this.themesLoadedData[parentThemeName];\n          }\n          this.#DiceWorld.add({\n            ...roll,\n            newStartPoint,\n            theme: parentTheme?.systemName || theme,\n            meshName: parentTheme?.meshName || meshName,\n            colorSuffix,\n          });\n        }\n\n        // turn flag off\n        newStartPoint = false;\n      }\n\n      if (hasGroupId) {\n        Object.assign(this.rollGroupData[index].rolls, rolls);\n      } else {\n        // save this roll group for later\n        notation.rolls = rolls;\n        notation.id = index;\n        this.rollGroupData[index] = notation;\n        ++this.#groupIndex;\n      }\n    });\n  }\n\n  // accepts simple notations eg: 4d6\n  // accepts array of notations eg: ['4d6','2d10']\n  // accepts object {sides:int, qty:int}\n  // accepts array of objects eg: [{sides:int, qty:int, mods:[]}]\n  createNotationArray(input, diceAvailable) {\n    const notation = Array.isArray(input) ? input : [input];\n    let parsedNotation = [];\n\n    const verifyObject = (object) => {\n      if (!object.hasOwnProperty(\"qty\")) {\n        object.qty = 1;\n      }\n      if (object.hasOwnProperty(\"sides\")) {\n        return true;\n      } else {\n        const err = \"Roll notation is missing sides\";\n        throw new Error(err);\n      }\n    };\n\n    const incrementId = (key) => {\n      key = key.toString();\n      let splitKey = key.split(\".\");\n      if (splitKey[1]) {\n        splitKey[1] = parseInt(splitKey[1]) + 1;\n      } else {\n        splitKey[1] = 1;\n      }\n      return splitKey[0] + \".\" + splitKey[1];\n    };\n\n    // verify that the rollId is unique. If not then increment it by .1\n    // rollIds become keys in the rollDiceData object, so they must be unique or they will overwrite another entry\n    const verifyRollId = (object) => {\n      if (object.hasOwnProperty(\"rollId\")) {\n        if (this.rollDiceData.hasOwnProperty(object.rollId)) {\n          object.rollId = incrementId(object.rollId);\n        }\n      }\n    };\n\n    // notation is an array of strings or objects\n    notation.forEach((roll) => {\n      // console.log('roll', roll)\n      // if notation is an array of strings\n      if (typeof roll === \"string\") {\n        parsedNotation.push(this.parse(roll, diceAvailable));\n      } else if (typeof notation === \"object\") {\n        verifyRollId(roll);\n        verifyObject(roll) && parsedNotation.push(roll);\n      }\n    });\n\n    return parsedNotation;\n  }\n\n  // parse text die notation such as 2d10+3 => {number:2, type:6, modifier:3}\n  // taken from https://github.com/ChapelR/dice-notation\n  parse(notation, diceAvailable) {\n    const diceNotation = /(\\d+)([dD]{1}\\d+)(.*)$/i;\n    const percentNotation = /(\\d+)[dD]([0%]+)(.*)$/i;\n    const fudgeNotation = /(\\d+)[dD](f+[ate]*)(.*)$/i;\n    // const customNotation = /(\\d+)[dD](.*)([+-])/i\n    const customNotation = /(\\d+)[dD]([\\d\\w]+)([+-]{0,1}\\d+)?/i;\n    const modifier = /([+-])(\\d+)/;\n    const cleanNotation = notation.trim().replace(/\\s+/g, \"\");\n    const validNumber = (n, err) => {\n      n = Number(n);\n      if (Number.isNaN(n) || !Number.isInteger(n) || n < 1) {\n        throw new Error(err);\n      }\n      return n;\n    };\n\n    // match percentNotation before diceNotation\n    const roll =\n      cleanNotation.match(percentNotation) ||\n      cleanNotation.match(diceNotation) ||\n      cleanNotation.match(fudgeNotation) ||\n      cleanNotation.match(customNotation);\n\n    let mod = 0;\n    const msg = \"Invalid notation: \" + notation + \"\";\n\n    if (!roll || !roll.length || roll.length < 3) {\n      throw new Error(msg);\n    }\n    if (roll[3] && modifier.test(roll[3])) {\n      const modParts = roll[3].match(modifier);\n      let basicMod = validNumber(modParts[2], msg);\n      if (modParts[1].trim() === \"-\") {\n        basicMod *= -1;\n      }\n      mod = basicMod;\n    }\n\n    const returnObj = {\n      qty: validNumber(roll[1], msg),\n      modifier: mod,\n    };\n\n    if (cleanNotation.match(percentNotation)) {\n      returnObj.sides = \"100\"; // as string, not number\n    } else if (cleanNotation.match(fudgeNotation)) {\n      returnObj.sides = \"fate\"; // force lowercase\n    } else if (diceAvailable.includes(cleanNotation.match(customNotation)[2])) {\n      returnObj.sides = roll[2]; // dice type instead of number\n    } else {\n      returnObj.sides = roll[2];\n    }\n\n    return returnObj;\n  }\n\n  #parseGroup(groupId) {\n    // console.log('groupId', groupId)\n    const rollGroup = this.rollGroupData[groupId];\n    // turn object into an array\n    const rollsArray = Object.values(rollGroup.rolls).map(\n      ({ collectionId, id, meshName, ...rest }) => rest\n    );\n    // add up the values\n    // some dice may still be rolling, should this be a promise?\n    // if dice are still rolling in the group then the value is undefined - hence the isNaN check\n    let value = rollsArray.reduce((val, roll) => {\n      const rollVal = isNaN(roll.value) ? 0 : roll.value;\n      return val + rollVal;\n    }, 0);\n    // add the modifier\n    value += rollGroup.modifier ? rollGroup.modifier : 0;\n    // return the value and the rollsArray\n    return { value, rollsArray };\n  }\n\n  getRollResults() {\n    // loop through each roll group\n    return Object.entries(this.rollGroupData).map(([key, val]) => {\n      // parse the group data to get the value and the rolls as an array\n      const groupData = this.#parseGroup(key);\n      // set the value for this roll group in this.rollGroupData\n      val.value = groupData.value;\n      // set the qty equal to the number of rolls - this can be changed by rerolls and removals\n      val.qty = groupData.rollsArray.length;\n      // copy the group that will be put into the return object\n      const groupCopy = { ...val };\n      // replace the rolls object with a rolls array\n      groupCopy.rolls = groupData.rollsArray;\n      // return the groupCopy - note: we never return this.rollGroupData\n      return groupCopy;\n    });\n  }\n}\n\nclass Collection {\n  constructor(options) {\n    Object.assign(this, options);\n    this.rolls = options.rolls || [];\n    this.completedRolls = 0;\n    const that = this;\n    this.promise = new Promise((resolve, reject) => {\n      that.resolve = resolve;\n      that.reject = reject;\n    });\n  }\n}\n\nexport default WorldFacade;\n"],"names":["createCanvas","options","selector","id","canvas","container","createAsyncQueue","opts","dedupe","queue","running","push","task","start","res","item","deepCopy","obj","Random","crypto","buffer","min","max","hexToRGB","hex","alpha","h","x","val","defaultOptions","_collectionIndex","_groupIndex","_rollIndex","_idIndex","_DiceWorld","_diceWorldPromise","_diceWorldResolve","_DicePhysics","_dicePhysicsPromise","_dicePhysicsResolve","_loadWorld","loadWorld_fn","_loadPhysics","loadPhysics_fn","_connectWorld","connectWorld_fn","_makeRoll","makeRoll_fn","_parseGroup","parseGroup_fn","WorldFacade","__privateAdd","__publicField","onDieComplete","onRollComplete","onRemoveComplete","onThemeConfigLoaded","onThemeLoaded","boxOptions","resize","__privateGet","__privateMethod","result","die","group","collection","collectionId","meshName","rest","returnDie","rollId","groupData","removeCollectionId","theme","basePath","themeData","resp","contentType","error","meshFilePath","target","themeConfig","newConfig","__privateSet","notation","themeColor","newStartPoint","__privateWrapper","Collection","parsedNotation","remove","hide","cleanNotation","value","rollArray","input","diceAvailable","verifyObject","object","err","incrementId","key","splitKey","verifyRollId","roll","diceNotation","percentNotation","fudgeNotation","customNotation","modifier","validNumber","n","mod","msg","modParts","basicMod","returnObj","groupCopy","resolve","reject","onInitComplete","WorldOffscreen","module","WorldOnscreen","physicsWorker","e","channel","rolls","hasGroupId","index","loadTheme","diceInherited","materialType","diceExtra","colorSuffix","color","i","len","dieType","parentTheme","parentThemeName","groupId","rollGroup","rollsArray","rollVal","that"],"mappings":"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"}